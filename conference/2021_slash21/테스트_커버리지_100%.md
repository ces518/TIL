# 테스트 커버리지 100%

테스트 커버리지, 얼마면 되나 ? -> 100%.. 작성한 코드는 한줄도 빠짐없이 모두 테스트해야한다.

## 높은 테스트 커버리지의 이점
- 배포 부담감이 줄어듦
- 거침없는 리팩토링
- 불필요한 코드 제거
- 코드 이해도 상승
- 점점 쉬워지는 테스트코드 작성

## 느려지는 테스트
- 느려지는 원인은 스프링 애플리케이션 컨텍스트 로딩
- 대부분 HTTP API 테스트시 스프링 애플리케이션 컨텍스트 로딩때문
- WebTestClient 를 비롯한 다양한 도구들이 컨텍스트 로딩 없이 테스트 가능
- 제거가 어려운 테스트의 경우 Static Mocking 활용

## 다시 느려진 원인
- SLF4J 초기화 -> 불필요한 로깅 설정 제거
- Jackson Object Mapper 초기화 -> Gson 
- ByteBuddy 초기화 -> 테스트에서 사용 중단
- 코틀린 리플렉션 모듈 초기화 -> isSubClassOf 함수 제거
- MockK (이중 가장 느림) -> 필수적이지 않다면 모두 제거 
- 테스트 순차적 실행 -> 클래스 단위로 병렬 실행

## 어려운 테스트
- DB
- 네트워크
- 프레임워크
- 랜덤
- 시간 의존적 테스트

> 위 테스트들은 모두 할만하다.. 모킹으로 테스트 가능함 \n
> 코틀린이 생성한 바이트코드 테스트가 어렵다. \n
> 정 테스트하기 힘들다면.. ignore 하는게 답일 수 있다.

## 커버리지가 100%라도 버그는 존재한다.
- 테스트를 잘못 작성
- 요구사항에 대한 오해
- 컴포넌트간 협업 실패

> Mutation Testing \n
> 프로덕션 코드를 무작위로 조작해 테스트 케이스를 확인 \n
> pitest.org

- Consumer Driven Contracts
    - 컨슈머 (API 사용하는 쪽)가 요구사항을 machine-readable 하게 기술하면 프로바이더가 요구사항 만족시 테스트하는 기법
> Spring Cloud Contract, Pact

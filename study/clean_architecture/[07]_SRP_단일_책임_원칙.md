# 7장 SRP 단일 책임 원칙

## 3색 볼펜 스터디
- 빨강 : 매우 중요하다 생각하는 부분
- 파랑 : 중요하다 생각하는 부분
- 초록 : 흥미로운 부분

## 개요
- SOLID 원칙중 가장 의미가 잘 전달되지 못한 원칙은 단일 책임 원칙
  - 이는 부적절한 이름 때문일 가능성이 높다
- 이름만 봤을때 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽다.
- 단 하나의 일만 해야 하는 원칙은 따로 있다.
  - 하나의 함수는 하나의 일만 해야 한다는 원칙
  - 이 원칙은 커다란 함수를 작은 함수들로 리팩토링하는 저수준의 작업에서 사용된다.
  - 이는 SOLID, SRP 도 아니다.
- (빨) SRP => 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 이 원칙을 이해하는 가장 좋은 방법 => 이 원칙을 위반하는 징후들을 살펴보는 일

## 징후1 : 우발적 중복
- Employee 클래스가 있고, 이는 세가지 메소드를 가진다
  - calculatePay()
  - reportHours()
  - save()
- 이 클래스는 SRP 를 위반하는데, 이들 세 가지 메소드가 서로 매우 다른 세명의 액터를 책임지기 때문이다
    - calculatePay() : 회계팀에서의 기능을 정의하며 CFO 보고를 위함
    - reportHours() : 인사팀에서의 기능을 정의하며 COO 보고를 위함
    - save() : DBA 가 기능을 정의하고 CTO 보고를 위해 사용
- 이 세가지 기능이 단일 클래스에 배치되어, 세 액터가 서로 **결합** 되어 버렸다.
- 이로 인해 CFO 에서의 결정사항이 COO 에 무언가에 영향을 줄 수 있다
- calculatePay 와 reportHours 에서 초과근무 계산 알고리즘을 공유하고 있다고 가정
- 이중 한 군데에서 알고리즘을 약간 수정했다고 가정했을때, 그 반대편에서 영향을 받게 된다.
- 우리는 이런 상황을 목격한 경험이 있다
- (파) 이는 서로 다른 액터가 의존하는 경우는 너무 가까이 배치했기 때문에 발생한다. SRP 는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다

## 징호2 : 병합
- 두 명의 서로 다른 개발자가, Employee 클래스를 체크아웃 받은 후 변경하기 시작하면 서로 충돌하게 되며, 결과적으로 병합이 발생하게 된다
- 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수는 없다. 결국 병합에는 항상 위험이 뒤따른다
- 여기서 발생한 병합은 양쪽 모두에게 위험하다.
- (파) 이는 서로 다른 목적으로 동일한 소스파일을 변경하는 경우에 해당한다. 해결방법은 서로 다른 액터를 뒷받침 하는 코드를 서로 분리하는 것이다.

## 해결책
- 이 문제의 해결책은 다양한데, 그 모두가 메소드를 각 다른 클래스로 이동시키는 방식이다.
- 가장 확실한 해결책 => 데이터와 메소드를 분리하는 방식
- 아무런 메소드가 없는 간단한 데이터구조 EmployeeData 클래스를 만들어 세 개의 클래스가 공유한다
- 그 후 각 클래스는 자신의 메소드에 반드시 필요한 소스코드만 포함하며, 세 클래스는 서로의 존재를 몰라야 한다
- 이를 활용하 **우연한 중복** 을 피할수 있다.
- 이 방법의 단점은 개발자가 세 가지 클래스를 모두 인스턴스화 하고 추적해야 한다.
- (초) 이를 해결하기 위한 기법으로 퍼사드 패턴을 사용한다.
- 퍼사드에 코드는 거의 없다. 이 클래스는 세 클래스의 객체를 생성하고, 요청을 위임하는 책임을 진다.
- 여러 메소드가 하나의 가족을 이루고, 메소드의 가족을 포함하는 각 클래스는 하나의 **유효범위** 가 된다.
- 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구가 있는지 전혀 알 수 없다

## 결론
- (파) 단일 책임 원칙은 메소드와 클래스 수준의 원칙
- 이보다 상위의 두 수준에서도 다른 형태로 다시 등장하게 된다
- 컴포넌트 수준 => 공통 폐쇄 원칙
- 아키텍쳐 수준 => 아키텍쳐 경계의 생성을 책임지는 변경의 축
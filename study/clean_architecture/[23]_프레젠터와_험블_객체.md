## 23장 프레젠터와 험블 객체

## 3색 볼펜 스터디
- 빨강 : 매우 중요하다 생각하는 부분
- 파랑 : 중요하다 생각하는 부분
- 초록 : 흥미로운 부분

## 개요
- 프레젠터는 험블 객체 패턴을 따른 형태로, 아키텍처 경계를 식별하고, 보호하는데 도움이 된다
- 실제 이전 장 "클린 아키텍쳐" 는 험블 객체 구현체들로 가득 차 있다

## 험블 객체 패턴
- 험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다
- 행위들을 두 개의 모듈 또는 클래스로 나눈다. 이 모듈중 하나가 **험블 (humble)** 이다
  - 가장 기본적인 본질을 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다
  - 나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다
- ex) GUI 는 단위 테스트가 어려운데, 화면을 보며 적절히 표현중인지 테스트하기 매우 어렵다. 하지만 GUI 에서 수행하는 행위 대다수는 테스트하기 쉽다
- 험블 객체 패턴을 사용해 두 부류의 행위를 분리하여 프레젠터와 뷰 라는 서로 다른 클래스로 만들 수 있다

## 프레젠터와 뷰
- 뷰는 험블 객체이고 테스트하기 어렵다.
- 여기 포함된 코드는 가능한 간단하게 유지해야 한다
- 뷰 => 데이터를 GUI 로 이동시키지만 데이터를 직접 처리하지는 않는다
- 프레젠터는 테스트하기 쉬운 객체이며, 애플리케이션으로 부터 데이터를 받아 화면에 표현가능한 포맷으로 만드는 것이 역할이다
- 이를 통해 뷰는 데이터를 화면으로 전달하는 간단한 일만 처리하도록 만든다

## 테스트와 아키텍쳐
- 테스트 용이성은 좋은 아키텍쳐가 지녀야할 속성으로 오랫동안 알려져 왔다
  - 험블 객체 패턴이 좋은 예시
- 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍쳐 경계가 정의되기 때문이다
- 프레젠터와 뷰 사이의 경계는 이렇나 경계중 하나이며, 이밖에도 수 많은 경계가 존재한다

## 데이터베이스 게이트웨이
- 유스케이스 인터랙터와 데이터베이스 사이에 데이터베이스 게이트웨이가 위치한다
- 이는 다형적 인터페이스로, 애플리케이션이 데이터베이스에 수행하는 생성, 조회, 갱신, 삭제 작업과 관련된 모든 메소드를 포함한다
- ex) 애플리케이션에서 어제 로그인한 모든 사용자의 성을 알아야 한다면 UserGateway 인터페이스는 getLastNamesOfUsersWhoLoggedInAfter 라는 메소드를 제공할 것이다
- 유스케이스 계층은 SQL 을 허용하지 않는다
  - 필요한 메소드를 제공하는 게이트웨이 인터페이스를 호출한다
  - 인터페이스 구현체는 데이터베이스 계층에 위치함
  - 이 구현체는 험블 객체
- 게이트웨이는 스텁이나 테스트 더블로 적당히 교체가 가능하기 때문에 테스트하기 쉽다

## 데이터 매퍼
- 하이버네이트 ORM 같은 것은 어느 계층에 속할까 ?
- 객체 관계 매퍼 (ORM) 같은건 사실 존재하지 않는다.
- 객체는 데이터 구조가 아니기 때문이다
  - 최소한 객체를 사용하는 입장에서 객체는 데이터 구조가 아니다
- ORM 보단 차라리 데이터 매퍼 라고 부르는 편이 나아 보인다
  - 관계형 데이터베이스 테이블로부터 가져온 데이터를 구조에 맞게 담아주기 때문
- ORM 은 데이터베이스 계층에 위치해야 한다
- 실제로 ORM 은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성한다

## 서비스 리스너
- 외부로부터 데이터를 수신하는 서비스의 경우, 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경한다
- 그 이후 데이터 구조는 서비스 경계를 가로질러서 내부로 전달된다

## 결론
- 각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있을 것이다
- 경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리될 것이다
- 이런 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다
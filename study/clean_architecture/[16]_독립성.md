# 16장 독립성

## 3색 볼펜 스터디
- 빨강 : 매우 중요하다 생각하는 부분
- 파랑 : 중요하다 생각하는 부분
- 초록 : 흥미로운 부분

## 개요
- 좋은 아키텍처는 다음을 지원해야 한다
  - 시스템의 유스케이스
  - 시스템의 운영
  - 시스템의 개발
  - 시스템의 배포

## 유스케이스
- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다
- 장바구니 애플리케이션이라면, 아키텍쳐는 장바구니와 관련된 유스케이스를 지원해야 한다
- 아키텍트의 최우선 관심사는 유스케이스 이며, 아키텍쳐에서도 유스케이스가 최우선이다

## 운영
- 시스템의 운영 지원 관점에서 볼 때 아키텍처는 덜 실질적이며 덜 피상적인 역할을 맡는다
- 시스템이 초당 100,000 명의 고객을 처리해야 한다면 아키텍쳐는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다
- 시스템에서 수밀리초 안에 3차원의 빅데이터 테이블에 질의해야 한다면, 반드시 이런 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야 한다

## 개발
- 아키텍처는 개발환경을 지원하는데 있어 핵심적인 역할을 수행한다
  - 콘웨이 법칙이 작용하는 지점
- 콘 웨이 법칙
  - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어낼 것이다

## 배포
- 아키텍처는 배포 용이성을 결정하는 중요한 역할을 한다
- 목표는 즉삭적인 배포이다
- 좋은 아키텍처는 수십 개의 작은 설정 스크립트는 속성 파일을 약간씩 수정하는 방법을 사용하지 않는다
- 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려두지 않는다
- 시스템이 빌드된 후 즉각 배포가능하도록 지원 해야 한다

## 선택사항 열어놓기
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다

## 계층 결합 분리
- 아키텍트는 단일 책임원칙과 공통 폐쇄원칙을 적용하여 그 의도의 맥락에 따라 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다
- 유스케이스에서 두 가지 요소를 포함한다면 UI 부분과 업무 규칙 부분을 서로 분리한다
- 분리함으로 인해 서로 독립적으로 변경가능 함과 동시에 유스케이스는 여전히 가시적이며 분명하게 유지할 수 있다

## 유스케이스 결합 분리
- 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다
- 결합을 분리하려면 주문 추가 유스케이스 UI 와 주문 삭제 유스케이스의 UI 를 분리해야 한다
  - 유스케이스 업무 규칙과 데이터베이스 부분도 마찬가지
- 이런 식으로 시스템 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 한다
- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다

## 개발 독립성
- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다
- 업무 규칙이 UI 를 알지 못하면 UI 에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 그다지 영향을 줄 수 없다

## 배포 독립성
- 유스케이스와 계층의 결합이 서로 분리되면 배포 측면에서도 고도의 유연성이 생긴다
- 운영중인 시스템에서도 계층과 유스케이스를 교체 할 수 있다
- 새로운 유스케이스를 추가하는 것은 새로운 jar 파일이나 서비스 몇개를 추가하는 정도로 단순한 일이 된다

## 중복
- 소프트웨어에서 중복인 일반적으로 나쁜 것이다
- 하지만 중복중에도 여러 종류가 있다
- 그중 하나는 진짜 중복
  - 한 인스턴스가 변경되면 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다
- 다른 하나는 우발적 중복
  - 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면 (서로 다른 속도와 다른 이유로 변경) 이 코드는 진짜 중복이 아니다
  - 몇년이 지나 다시보면 두 코드가 매우 다르다는 사실을 알게 된다

## 결합 분리 모드 (다시)
- 계층과 유스케이스 결합을 분리하는 방법은 다양하다
- 소스코드 수준 분리 모드
  - 소스코드 모듈 사이의 의존성을 제어할 수 있다
  - 하나의 모듈이 변해도 다른 모듈을 변경하거나 재 컴파일 하지 않는다
- 배포 수준 분리 모드
  - jar, DLL, 공유 라이ㅡ러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다
  - 한 모듈의 소스코드가 변해도 다른 모듈을 빌드, 배포하지 않도록 할 수 있다
- 서비스 수준 분리 모드
  - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다
  - 모든 실행가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다
- 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나 단일 파일로 배포되더라도 이후에는 독립적으로 배포가능한 단위들의 집합으로 성장하고, 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다
- 나중에 상황이 바뀌었을때 이를 거꾸로 돌려 모노리틱 구조로 되돌릴수 있어야 한다
- 좋은 아키텍처는 일너 변경으로 부터 소스코드를 대부분 보호한다
- 결합 분리 모드를 선택사항으로 남겨두어 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다
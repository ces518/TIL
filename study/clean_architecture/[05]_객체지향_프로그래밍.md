# 5장 객체지향 프로그래밍

## 3색 볼펜 스터디
- 빨강 : 매우 중요하다 생각하는 부분
- 파랑 : 중요하다 생각하는 부분
- 초록 : 흥미로운 부분

## 개요
- (빨) 좋은 아키텍쳐를 만드는 일은 객체지향, OO 설계 원칙을 이해하고 응용하는 데서 출발한다.
- (파) 대체 OO 란 무엇인가 ?
- 흔히 "실제 세계를 모델링하는 새로운 방법" 이라고도 많이 댇바한다
  - 그냥 얼버무리는 수준의 답변
- OO 의 본질을 섦여하기 위해 세 가지 주문에 기대는 부류도 있다.
- 캡슐화, 상속, 다형성 이 그 주문들이다
- OO 가 이 세가지 개념을 적절히 조합한 것 이거나, OO 언어는 최소한 세 가지 요소를 반드시 지원해야 한다고 한다.

## 캡슐화 ?
- 캡슐화를 언급하는 이유 ? => 데이터와 함수를 쉽고 효과적으로 캡슐화 하는 방법을 OO 언어가 제공하기 때문
  - 이 방법을 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다
  - 외부에서 데이터는 은닉되고, 일부 함수만이 노출된다
  - 각 클래스의 private 멤버와 public 함수로 표현된다
- 이런 개념들은 OO 에만 국한된것이 아니고, C 언어에서도 완벽한 캡슐화가 가능하다

```c
// point.h
struct Point;
struct Point* makePoint(double x, double y);
double distnace (struct Point *p1, struct Point *p2);

// point.c
#include "point.h"
#include <stdlib.h>
#include <math.h>

struct Point {
    double x,y;
}; 

strcut Point* makePoint(double x, double y) {
    struct Point* p = malloc(sizeof(strut Point));
    p->x = x;
    p->y = y;
    return p;
}

double distnace (struct Point *p1, struct Point *p2) {
    double dx = p1->x - p2->x;
    double dy = p1->y - p2->y;
    return sqrt(dx*dx+dy*dy);
}
```
- point.h 를 사용하는 클라이언트 측에서는 struct Point 의 멤버에 접근한 방법이 전혀 없다.
- public 하게 오픈된 makePoint,distnace 함수 는 호출이 가능하지만, 구조체의 데이터 구조와 함수 구현에 대해 전혀 알지 못한다
- 이것이 바로 완벽한 캡슐화 이다.
- 자바와 C# 은 헤더와 구현체를 분리하는 방식을 모두 버렸고, 이로 인해 캡슐화는 심하게 훼손 되었다.
- (초) OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.

## 상속 ?
- OO 언어가 더 나은 캡슐화는 제공하지 못했지만, 상속만큼은 더 확실히 제공했다.
- **상속이란, 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어 재정의 하는 일에 불과하다**
- OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다 (상속을 흉내내는 요령)
- 하지만 상속만큼 편맇나 방식은 절대 아니다.
- OO 가 완전히 새로운 개념을 만들지 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다

## 다형성 ?
- OO 언어 이전에도 다형성을 표현할 수 있었다.
- (파) 함수를 가리키는 포인터를 응용한 것이 다형성 이다
- (파) 폰노이만 아키텍쳐가 처음 구현된 이후 프로그래머는 다형적 행위를 수행하기 위해 함수를 가리키는 포인터를 사용해 왔다. OO 가 새롭게 만든 것은 전혀 없다
- OO 는 다형성을 제공하진 못했찌만, 좀 더 안전하게 편리하게 사용할 수 있게 해주었다.

### 다형성이 가진 힘
- 왜 유닉스 운영체제는 입출력 장치들을 플러그인 형태로 만들었을까 ?
- 1950년 후반에 프로그램이 장치 독립적이어야 한다는 사실을 이미 배웠기 때문이다.
- **플러그인 아키텍쳐** 는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 이후 거의 모든 ㅇ누영체제에서 구현되었다.
- 하지만 개발자들은 이를 프로그램에 적용하지 않았는데, 함수 포인터를 사용하는 위험을 수반되기 때문이었다.
- OO 의 등장으로 플로그인 아키텍처를 안전하게 적용할 수 있게 되었다.

### 의존성 역전
- OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬수 있다는 뜻이다
  - 소스코드 사이에 인터페이스를 추가함으로 써 의존성을 역전시킬 수 있다
- (초) 이런 접근법을 적용한다면, **OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스코드 의존성에 대해 전부 방향을 결정할 수 있는 절대적인 권한을 갖는다**
- (초) **소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다**
- 이것이 바로 OO 가 제공하는 힘이다. 그리고 OO 가 지향하는 방향이다.

## 결론
- OO 란 무엇인가 ?
- OO 란 다형성을 이용하여 전체 시스템의 모든 소스코드 의존성에 대한 절대적인 제어 권한을 가질수 있는 능력이다
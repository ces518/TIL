# 20장 영속성
- 몽고 DB 가 저널링을 통해 복제 셋 멤버 수준에서 영속성을 보장하는 방법
- 몽고 DB 가 쓰기 결과 확인을 사용해 클러스터 수준에서 영속성을 보장하는 방법
- 필요한 영속성 수준을 제공하도록 애플리케이션과 몽고 DB 클러스터를 구성하는 방법
- 몽고 DB 가 읽기 결과 확인을 사용해 클러스터 수준에서 영속성을 보장하는 방법
- 복제 셋에서 트랜잭션의 영속성 수준을 설정하는 방법

## 저널링을 통한 멤버 수준의 영속성
- 서버 오류 발생시 영속성 제공을 위해 몽고 DB 는 **저널 (journal)** 이라는 로그 선행 기입 (WAL, write-ahead-log) 을 사용한다
  - WAL => 데이터베이스 시스템의 영속성을 위해 흔히 사용하는 기술
  - 데이터베이스 자체에 변경 사항을 적용하기 전에 영속성 있는 매체에 변경 사항을 간단히 작성한다
  - 하지만 다른 기술로 원자적 쓰기를 보장한다
- 몽고 DB 4.0 부터 애플리케이션이 복제 셋에 쓰기 수행시, 모든 복제된 컬렉션의 데이터에 대해 몽고 DB 는 저널 항목을 생성한다
- 몽고 DB 는 작업 로그를 기반으로 하는 명령문 기반 복제를 사용한다
- oplog 에 있는 명령문은 실제 몽고 DB 변경 사항을 대표한다
- oplog 는 버전, 하드웨어 등 복제 셋 멤버 간의 차이점에 관계 없이 어느 복제 셋 멤버든 쉽게 적용이 가능하다
- 각 oplog 는 멱등이기 때문에 여러 번 적용 가능하며, 결과는 항상 동일한 데이터베이스 변경 사항이 된다
- 몽고 DB 는 대부분의 데이터베이스와 마찬가지로 저널과 데이터베이스 데이터 파일의 인메모리 뷰를 유지한다
- 기본적으로 저널 항목을 50 밀리초마다 디스크로 플러시하고 데이터베이스 파일을 60초 마다 디스크로 플러시한다
  - 이 간격을 **체크포인트** 라고 한다
- 저널은 마지막 체크포인트 이후 기록된 데이터의 영속성을 제공하는 데 사용한다
  - 서버가 갑자기 중지되면 재시작시 저널을 사용해 종료전 플러시 되지 않은 쓰기를 다시 진행할 수 있음
- 저널파일 => 몽고 DB dbPath 디렉터리 하위 journal 서브 디렉터리를 생성함
- 와이어드 타이거 저널 파일에는 WiredTigerLog.<sequence> 형식의 이름이 있다
- 몽고 DB 는 저널에 기록된 데이터를 압축하며, 저널 파일의 크기 제한은 100메가 바이트이다
- 저널 파일이 제한 초과시 몽고 DB 는 새 저널 파일을 만든다
- 저널 파일은 마지막 체크포인트 이후 데이터 복구시에만 필요하므로, 새 체크 포인트 작성시 오래된 저널 파일을 제거한다
- 애플리케이션에서 저널 플러시 간격이 짧아야 한다면 두 가지 방법이 있다
  - mongod 에 --journalCommitInterval 옵션 지정 (1~500 밀리초 범위 허용)
  - 모든 쓰기가 디스크에 저널링해야 한다는 쓰기 결과 확인을 지정하는 방법

> 디스크 저널링 간격을 줄이면, 성능에 영향을 미치므로 영향도 파악이 중요하다

## 쓰기 결과 확인을 사용하는 클러스터 수준의 영속성
- 쓰기 결과 확인을 사용하면, 애플리케이션이 쓰기 요청에 응답하는 데 필요한 승인 수준을 지정할 수 있다
- 복제 셋에 복제가 중단되었다가 복원되면, 대다수 멤버에 복제되지 않은 쓰기가 롤백된다
- 이런 경우 커밋된 데이터가 클라이언트와 데이터베이스에서 서로 다르게 보일 수 있다
- 상황에 따라 쓰기 롤백이 허용되는 경우가 있다
  - 소셜 애플리케이션에서 적은 수의 댓글 롤백 등..
- 몽고 DB 는 클러스터 수준에서 다양한 영속성 보장을 지원한다

### writeConcern 에 대한 w 와 wtimeout 옵션
- 몽고 DB 쿼리 언어는 모든 삽입과 갱신 메서드에 대해 쓰기 결과 확인을 지정하도록 지원한다
- 모든 삽입과 갱신 메서드는 두 번째 매개변수, 도큐먼트를 사용한다
- 해당 도큐먼트 내에서 writeConcern 에 대한 값을 지정할 수 있다
- 쓰기 결과 확인은, 애플리케이션 복제 셋 멤버 대부분에 성공에 복제됬을 때만, 쓰기가 성공적으로 완료됨을 서버로부터 확인 받고자함을 의미한다
- 타임아웃을 처리하는 방법은 애플리케이션에게 책임이 있다
- 대부분의 경우 애플리케이션은 타임아웃이 네트워크 통신의 일시적인 속도 저하 때문에 발생했는지 혹은 더 중요한 원인이 있는지 확인해야 한다

```shell
try {
  db.products.insertOne(
    { sku : "H1100335456", item : "Electric ..", quantity : 3},
    { writeConcern : { w : "majority", wtimeout : 100 }}
  )
} catch (e) {
  print (e);
}
```
### writeConcern 에 대한 j 옵션
- w 옵션에 대한 값을 제공할 뿐 아니라 쓰기 결과 확인 도큐먼트에서 j 옵션을 사용해, 쓰기 작업이 저널에 기록됐다는 확인을 요청할 수도 있다
- j 의 값이 true 이면 몽고 DB 는 요청된 수만큼 멤버가 온디스크 저널에 작업을 기록한 후에만 쓰기가성공했다고 확인한다
- 모든 쓰기가 대다수의 멤버에 대해 저널링되도록 하려면 코드를 다음처럼 수정해야 한다

```shell
try {
  db.products.insertOne(
    { sku : "H1100335456", item : "Electric ..", quantity : 3},
    { writeConcern : { w : "majority", wtimeout : 100, j : true }}
  )
} catch (e) {
  print (e);
}
```
- 저널링되기를 기다리지 않으면, 각 멤버에 대해 약 100밀리초 동안은 서버 프로세스나 하드웨어가 다운되면 쓰기가 손실된다
- 복제 셋의 멤버에 대한 쓰기를 승인하기 전에 저널링 되기를 기다리면 성능이 저하된다
- 애플리케이션의 영속성 문제를 해결하려면 애플리케이션의 요구 사항을 신중하게 평가해야 하며, 선택한 영속성 설정의 성능 영향을 따져봐야 한다

## 읽기 결과 확인을 사용하는 클러스터 수준의 영속성
- 몽고 DB 에서 읽기 결과 확인은, 결과를 읽을 때의 구성을 허용한다
- 클라이언트는 쓰기가 영속되기 전 쓰기 결과를 볼 수 있다
- 읽기 결과 확인을 쓰기 결과 확인과 함께 사용해 애플리케이션의 일관성과 가용ㅅ어 보장 수준을 제어한다
- 읽기 결과 확인은 읽는 데이터의 일관성과 격리 속성을 결정하며, 기본적으로 readConcern : local 이다
- 애플리케이션에 대한 적절한 concern 선택 전, 쓰기 결과 확인을 사용해 읽기 결과 확인이 제공하는 영속성 및 격리 보장과 성능 영향을 따져봐야 한다

## 쓰기 결과 확인을 사용하는 트랜잭션의 영속성
- 몽고 DB 에서 개별 도큐먼트에 대한 작업은 원자적
- 정규화된 모델 사용 대신 내장 도큐먼트와 배열을 사용하여 단일 도큐먼트 내에서 개체 간의 관계를 표현한다
- 때문에 많은 애플리케이션에서 도중 도큐먼트 트랜잭션이 필요하지 않다
- 여러 도큐먼트 갱신중 원자성이 필요한 경우가 있기 때문에, 복제 셋에 대해 다중 도큐먼트 트랜잭션을 수행하는 기능을 제공한다
- 이는 여러 개의 작업, 도큐먼트, 컬렉션, 데이터베이스에서 사용한다
- 트랜잭션 사용시 작업이 실패하면 트랜잭션이 중단되고 모든 변경사항이 삭제 된다
- 모든 작업이 성공해야만 모든 변경사항이 저장되고 향후 읽기시 표시된다
- 개별 쓰기 작업과 동일하게 트랜잭션에 대한 쓰기 결과 확인을 지정할 수 있다
- 개별 수준이 아닌 트랜잭션 수준에서 쓰기 결과 확인을 설정한다
- 트랜잭션 시작시, 트랜잭션 커밋에 대한 쓰기 결과 확인 설정이 가능하다
- 쓰기 결과확인 0은 지원하지 않으며, 1을 사용하는 경우 장애조치가 있다면 롤백이 가능하다
- majority 를 사용해 네트워크와 서버 장애에도 트랜잭션이 지속되도록 할 수 있다

## 몽고 DB 가 보장하지 않는 것
- 몽고 DB 는 하드웨어 문제나 파일시스템 버그가 있는 상황에서는 영속성을 보장하지 못한다
  - 특히 하드 디스크 손상시 데이터를 보호할 수 없다
- 기본적으로 몽고 DB 는 기저 시스템이 안전한 만큼 안전하다
- 시스템 문제에 대응하려면 복제를 이용하자.

## 데이터 손상 확인
- validate 명령을 사용해 컬렉션이 손솽됐는지 확인한다.

```shell
db.movies.validate({full : true})
{
  "ns" : "sample_mflix_movies",
  "nInvalidDocuments" : NumberLong(0),
  "nrecords" : 45993,
  "nIndexes" : 5,
  "keysPerIndex" : {
    "_id_" : 45993,
    "$**_text" : 3671341,
    ...
  },
  "indexDetails" : {
    "..."
  }
  "valid" : true,
  "warnings" : [],
  "errors" : [],
  "extraIndexEntries" : [],
  "missingIndexEntries" : [],
  "ok" : 1
}
```
- 주요 항목은 valid 이며, true 가 아니라면 찾아낸 손상에 대해 자세한 내용을 제공한다
- validate 는 컬렉션에 대해서만 실행이 가능하며, indexDetails 필드를 통해 관련 인덱스도 확인하기 위해서는 {full: true} 옵션을 사용해야 한다


# 12장 애플리케이션에서 복제 셋 연결
- 연결 및 장애 조치를 수행하는 방법
- 쓰기 시 복제 대기하는 방법
- 올바른 멤버에 읽기 요청을 라우팅하는 방법

## 클라이언트-복제 셋 연결 동작
- 몽고 DB 클라이언트 (드라이버) 는 서버가 독립 실행형 몽고 인스턴스든 복제 셋이든 관계 없이 몽고 DB 서버와의 통신을 관리하도록 설계
  - 복제셋 인경우 => 드라이버는 프라이머리에 연결되고 모든 트래픽을 프라이머리에 라우팅하게 됨
- 복제 셋 에 대한 연결 => 단일 서버에 대한 연결과 비슷
- 드라이버에서 MongnClient 를 사용하고, 연결할 드라이브를 위한 **시드 목록** 을 제공하면 된다
  - 시드 목록 => 연결할 서버의 주소 목록
  - 시드 => 애플리케이션이 데이터를 읽고 쓸 복제셋의 멤버

```text
// 일반적인 몽고 DB 연결 문자열
"mongodb://server-1:20717,server-2:20717,server-3:20717"
```
- 모든 시드 멤버를 나열할 필요는 없음
- 드라이버는 시드에 연결되면, 다른 멤버들을 발견하게 된다
- 추가적인 복원력을 제공하려면 **DNS Seedlist** 연결방식을 사용해야 한다

`DNS SeedList`
- 몽고 3.6 부터 제공하는 커넥션 기능 방식
- DNS 의 SRV Record 와 TXT Record 기능을 사용하는 것으로, 여러대의 서버와 포트정보를 나열할 필요없이 하나의 도메인 주소를 사용하여 MongoDB 구조(단일레플리카셋/샤드클러스터)와 무관하게 DB 에 접근할 수 있음

```text
mongodb+srv://jdrumgoole:<password>#fsdfsdf-fsdfdsf/text
```
- https://www.joinc.co.kr/w/man/12/srv
- 사내 권고사항으로 잡혀 있음.
- SSL 설정이 default : true 로 잡혀 있음.

프라이머리가 다운되면 드라이버는 자동으로 새로운 프라이머리를 찾고 요청을 라우팅한다
- 프라이머리가 선출되는 시간동안 프라이머리가 없을 수 있음
- 이 기간 동안 요청을 처리하지 않는다
- 드라이버 설정을 통해 읽기 요청을 세컨더리에 하도록 구성가능

몽고 3.6 부터 서버 및 모든 드라이버는 재시도 가능한 쓰기 옵션을 지원한다
- 자동으로 최대 한 번 재시도하는 전략을 따르게 됨
- 명령 오류는 클라이언트에서 처리하기 위해 애플리케이션이 반환되고, 네트워크 오류는 적절한 시간 뒤 1회 재시도 한다

## 쓰기시 복제 대기
- 애플리케이션 요구 사항에 따라 쓰기 작업이 서버에서 확인되기 전, 대부분의 복제 셋에 복제되도록 요구할 수 있다
- 프라이머리가 중단되었다가 새롭게 선출된 프라이머리가 마지막 쓰기작업을 이전 프라이머리에 복제하지 않았을 경우
- 이전 프라이머리가 다시 프라이머리로 선출될 때 해당 쓰기가 롤백되게 된다
  - 복구 가능하지만, 수동 개입 필요
  - 롤백되는 쓰기 수가 적다면 문제되지 않지만 그 수가 많다면 이를 피해야 한다
  - 쓰기 충돌시 프라이머리에 수동 적용해야 하는 특수한 롤백 파일에 기록됨

`writeConcern`
- 과반수에 쓰기를 수행하면 위와 같은 상황을 방지할 수 있다
- 복제 셋에 어떤 일이 발생하든 쓰기를 지속하기 위해 각 쓰기 작업이 복제 셋 멤버 과반수에 전파되어야 한다
- writeConcern 은 몽고 2.6 부터 쓰기 작업과 통합되었다
- 쓰기 작업이 복제 셋 멤버 과반수에 복제될때 까지 응답을 주지 않음
- 위 조건이 만족된 이후에야 쓰기 성공 응답을 받는다
- 지정한 제한 시간내 작업을 수행하지 못한다면 다음과 같은 오류 메세지를 반환한다

```shell
WriteConcernError({
  "code" : 64,
  "errInfo" : {
    "wtimeout" : true
  },
  "errmsg" : "waiting for replication timed out"
})
```
- 과반수 쓰기 결과 확인 과 복제 셋 선출 프로토콜은 승인된 쓰기가 있는 **최신 세컨더리만 프라이머리로 선출** 한다
  - 가장 최근 쓰기 작업이 복제된 세컨더리만..
- 이런 방식은 롤백이 발생하지 않도록 보장해준다

### "w" 에 대한 다른 옵션
- majority 는 writeConcern 의 유일한 옵션이 아니다
  - majority : 복제 셋의 과반수를 자동으로 지정
- "w" 에 숫자를 전달함으로 써 몇 개의 서버에 복제할지 임의로 명시할 수 있다
- 숫자를 사용하는 방식의 단점은 복제 셋 구성 변경시 애플리케이션 코드 변경이 필요할 수 있다는 점이다

```shell
db.products.insertOne(
  {"_id" : 10, "item" : "envelopes"},
  {"writeConcern" : {"w" : 2, "wtimeout" : 100}}
)
```
- w : 1 로 설정하면 이 옵션을 사용하지 않았을때와 동일함

## 사용자 정의 복제 보증

### 데이터 센터당 하나의 서버 보장하기
- 데이터 센터간 네트워크 문제는 센터 내의 문제보다 일반적
- 여러 센터에 걸쳐 서버가 동등하게 영향받기 보다는 한 개의 센터 전체가 죽을 가능성이 높다
- 모든 데이터센터에 쓰기를 보장하는 것이 필요하다
- 이를 설정하기 위해 멤버를 데이터 센터별로 분류하는 작업이 필요하다

```shell
var config = rs.config()
config.member[0].tags = {"dc" : "us-east"}
config.member[1].tags = {"dc" : "us-west"}
config.member[2].tags = {"dc" : "us-east"}
```
- 각 멤버는 여러 태그를 가질 수 있다
- 다음 단계로, 복제 셋 구성에 "getLastErrorMode" 필드를 생성해 규칙을 추가해야 한다
  - 이런 네이밍은 몽고 2.6 이전에 애플리케이션이 쓰기 결과 확인을 지정하는데 getLastError 를 사용한 흔적..
- 각 규칙의 형식은 "name ": {"key":number} 이다
- name = 규칙의 이름
  - 클라이언트가 호출할때 이름을 사용함
  - 충분히 이해 가능한 이름을 사용할 것
- key = 태그에서의 키 필드
- number = 규칙을 충족하는데 필요한 그룹의 개수

```shell
config.settings = {}
config.settings.getLastErrorModes = [["eachDC" : {"dc" : 2}]]
rs.reconfig(config)
```
- us-east 에 하나, us-west 에 적어도 하나씩 존재하도록 규칙 설정

```shell
db.products.insertOne(
  {"_id" : 10, "item" : "envelopes"},
  {"writeConcern" : {"w" : "eachDC", "wtimeout" : 100}} // 위에서 설정한 규칙명을 사용
)
```

### 숨겨지지 않은 멤버의 과반수 보장하기

```shell
// 멤버 태깅
var config = rs.config()
config.members[0].tags = [{"normal" : "A"}]
config.members[1].tags = [{"normal" : "B"}]
config.members[2].tags = [{"normal" : "C"}]
config.members[3].tags = [{"normal" : "D"}]

// 과반수 규칙 생성
config.settings.getLastErrorModes = [{"visibleMajority" : {"normal" : 3}}]
rs.reconfig(config)

// 규칙 사용
db.produdcts.insertOne(
  {"_id" : 10, "item" : "envelopes"},
  {writeConcern : {"w" : "visibleMajority" : wtimeout : 1000}}
)
```

### 기타 보장 생성하기
- 사용자가 생성할 수 있는 규칙은 제한이 없음
- 사용자 정의 복제 규칙을 만드려면 다음 두 단계를 거쳐야 한다
1. 키/값 쌍을 할당해 멤버들을 태깅한다
2. 생성한 분류 체계에 기반해 규칙을 생성한다.
   - 규칙의 형태는 항상 {"name" : {"key": number}} 와 같아야 한다
   - 쓰기 성공전 number 개의 그룹에서 적어도 하나의 서버는 쓰기를 가져야 한다
- 규칙을 이해하고 구성하긴 복잡하지만, 매우 강력한 방법
- 복제 요구사항에 그다지 얽혀 있지 않다면 "w" : "majority" 만 사용해도 안전함

## 세컨더리로 읽기 전송
- 기본적으로 드라이버는 모든 요청을 프라이머리로 라우팅 한다
- 읽기 요청을 세컨더리에 보내면 몇몇 특정 상황에선 의미가 있지만 일반적으로 좋지 않다
- 세컨더리로 읽기 요청을 고려한다면 장단점을 신중히 생각해야 한다

### 일관성 고려 사항
- 읽기 일관성이 중요하다면 세컨더리로 부터 읽기를 수행하면 안된다
- 세컨더리는 보통 몇 밀리초 내에 복제되지만 이는 완전히 보장되지 않음
- 부하나 잘못된 구성 네트워크 오류 등 다양한 문제로 인해 지연될 수 있다
- 클라이언트는 세컨더리가 지연됬는지 알 방법이 없기 때문에 세컨더리에 쿼리하게 된다

### 부하 고려사항
- 부하를 분산하기 위해 읽기를 세컨더리로 전송한다
- 서버가 초당 만개 쿼리 처리가 가능하지만 3만개를 처리하려고 두 개의 세컨더리를 구성해 부하를 분산할 수 있다
- 이런 방법은 위험하다. 의도치 않게 시스템 과부하를 유발할 수 있다
- 세컨더리 중 하나가 손상된 경우 손상된 멤버를 재구축 해야 한다
- 서버가 과부하 되면 처리속도가 느려지고, 복제 셋의 수용 능력을 더욱 낮추게 되며, 다른 멤버에 더 많은 부화를 주게 되어 악순환이 된다
- 심각하면 모두 과부하에 걸릴 가능성이 있다
- 부하를 분산하는 더 좋은 방법은 **샤딩** 이다

### 세컨더리에서 읽기를 하는 이유
- 일부의 경우에는 세컨더리에서 읽기를 처리하는 것이 합리적이다
- 프라이머리가 다운되더라도 읽기는 수행해야 한다거나..
- 복제셋이 프라이머리를 잃은 경우 사용자는 임시 읽기전용 모드를 원하는데 이 읽기 선호도를 **primaryPreferred** 라고 한다
- 세컨더리 읽기는 지연율이 낮은 읽기가 중요하다
- **nearest** 읽기 선호도로 지정함으로 써 드라이버에서 복제 셋 멤버까지의 평균 핑 시간을 기반으로 지연율이 가장 낮은 멤버에 요청을 라우팅 한다
- 여러 데이터 센터에 걸쳐 지연율이 가장 낮은 멤버에 접근해야 한다면 이 방법이 유일하다
- 애플리케이션에서 지연율이 낮은 읽기/쓰기가 필요하다면 반드시 샤딩해야 한다
  - 복제 셋은 오직 하나의 위치에만 쓰기를 허용한다
- 애플리케이션을 만드는데 어떤 옵션이 도움되는지 고려해야 한다
- 어느 정도 읽기 요청이 프라이머리에서 발생한다면 **primary** 를, 다른 읽기는 최신 데이터가 아니어도 된다면 **primaryPReferred** 를 사용하고
- 일관성 보다는 낮은 지연율이 필요하다면 **nearest** 를 사용하자.

## 참고
- https://developer.mongodb.com/article/srv-connection-strings/
- https://docs.mongodb.com/manual/reference/connection-string/#dns-seedlist-connection-format
- https://www.joinc.co.kr/w/man/12/srv


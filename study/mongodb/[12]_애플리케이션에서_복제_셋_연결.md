# 12장 애플리케이션에서 복제 셋 연결
- 연결 및 장애 조치를 수행하는 방법
- 쓰기 시 복제 대기하는 방법
- 올바른 멤버에 읽기 요청을 라우팅하는 방법

## 클라이언트-복제 셋 연결 동작
- 몽고 DB 클라이언트 (드라이버) 는 서버가 독립 실행형 몽고 인스턴스든 복제 셋이든 관계 없이 몽고 DB 서버와의 통신을 관리하도록 설계
  - 복제셋 인경우 => 드라이버는 프라이머리에 연결되고 모든 트래픽을 프라이머리에 라우팅하게 됨
- 복제 셋 에 대한 연결 => 단일 서버에 대한 연결과 비슷
- 드라이버에서 MongnClient 를 사용하고, 연결할 드라이브를 위한 **시드 목록** 을 제공하면 된다
  - 시드 목록 => 연결할 서버의 주소 목록
  - 시드 => 애플리케이션이 데이터를 읽고 쓸 복제셋의 멤버

```text
// 일반적인 몽고 DB 연결 문자열
"mongodb://server-1:20717,server-2:20717,server-3:20717"
```
- 모든 시드 멤버를 나열할 필요는 없음
- 드라이버는 시드에 연결되면, 다른 멤버들을 발견하게 된다
- 추가적인 복원력을 제공하려면 **DNS Seedlist** 연결방식을 사용해야 한다

`DNS SeedList`
- 몽고 3.6 부터 제공하는 커넥션 기능 방식
- DNS 의 SRV Record 와 TXT Record 기능을 사용하는 것으로, 여러대의 서버와 포트정보를 나열할 필요없이 하나의 도메인 주소를 사용하여 MongoDB 구조(단일레플리카셋/샤드클러스터)와 무관하게 DB 에 접근할 수 있음

```text
mongodb+srv://jdrumgoole:<password>#fsdfsdf-fsdfdsf/text
```
- https://www.joinc.co.kr/w/man/12/srv
- 사내 권고사항으로 잡혀 있음.
- SSL 설정이 default : true 로 잡혀 있음.

프라이머리가 다운되면 드라이버는 자동으로 새로운 프라이머리를 찾고 요청을 라우팅한다
- 프라이머리가 선출되는 시간동안 프라이머리가 없을 수 있음
- 이 기간 동안 요청을 처리하지 않는다
- 드라이버 설정을 통해 읽기 요청을 세컨더리에 하도록 구성가능

몽고 3.6 부터 서버 및 모든 드라이버는 재시도 가능한 쓰기 옵션을 지원한다
- 자동으로 최대 한 번 재시도하는 전략을 따르게 됨
- 명령 오류는 클라이언트에서 처리하기 위해 애플리케이션이 반환되고, 네트워크 오류는 적절한 시간 뒤 1회 재시도 한다

## 쓰기시 복제 대기
- 애플리케이션 요구 사항에 따라 쓰기 작업이 서버에서 확인되기 전, 대부분의 복제 셋에 복제되도록 요구할 수 있다
- 프라이머리가 중단되었다가 새롭게 선출된 프라이머리가 마지막 쓰기작업을 이전 프라이머리에 복제하지 않았을 경우
- 이전 프라이머리가 다시 프라이머리로 선출될 때 해당 쓰기가 롤백되게 된다
  - 복구 가능하지만, 수동 개입 필요
  - 롤백되는 쓰기 수가 적다면 문제되지 않지만 그 수가 많다면 이를 피해야 한다
  - 쓰기 충돌시 프라이머리에 수동 적용해야 하는 특수한 롤백 파일에 기록됨

`writeConcern`
- 과반수에 쓰기를 수행하면 위와 같은 상황을 방지할 수 있다
- 복제 셋에 어떤 일이 발생하든 쓰기를 지속하기 위해 각 쓰기 작업이 복제 셋 멤버 과반수에 전파되어야 한다
- writeConcern 은 몽고 2.6 부터 쓰기 작업과 통합되었다
- 쓰기 작업이 복제 셋 멤버 과반수에 복제될때 까지 응답을 주지 않음
- 위 조건이 만족된 이후에야 쓰기 성공 응답을 받는다
- 지정한 제한 시간내 작업을 수행하지 못한다면 다음과 같은 오류 메세지를 반환한다

```shell
WriteConcernError({
  "code" : 64,
  "errInfo" : {
    "wtimeout" : true
  },
  "errmsg" : "waiting for replication timed out"
})
```
- 과반수 쓰기 결과 확인 과 복제 셋 선출 프로토콜은 승인된 쓰기가 있는 **최신 세컨더리만 프라이머리로 선출** 한다
  - 가장 최근 쓰기 작업이 복제된 세컨더리만..
- 이런 방식은 롤백이 발생하지 않도록 보장해준다

### "w" 에 대한 다른 옵션
- majority 는 writeConcern 의 유일한 옵션이 아니다
  - majority : 복제 셋의 과반수를 자동으로 지정
- "w" 에 숫자를 전달함으로 써 몇 개의 서버에 복제할지 임의로 명시할 수 있다
- 숫자를 사용하는 방식의 단점은 복제 셋 구성 변경시 애플리케이션 코드 변경이 필요할 수 있다는 점이다

```shell
db.products.insertOne(
  {"_id" : 10, "item" : "envelopes"},
  {"writeConcern" : {"w" : 2, "wtimeout" : 100}}
)
```
- w : 1 로 설정하면 이 옵션을 사용하지 않았을때와 동일함

## 사용자 정의 복제 보증

### 데이터 센터당 하나의 서버 보장하기
- 데이터 센터간 네트워크 문제는 센터 내의 문제보다 일반적
- 여러 센터에 걸쳐 서버가 동등하게 영향받기 보다는 한 개의 센터 전체가 죽을 가능성이 높다
- 모든 데이터센터에 쓰기를 보장하는 것이 필요하다
- 이를 설정하기 위해 멤버를 데이터 센터별로 분류하는 작업이 필요하다

```shell
var config = rs.config()
config.member[0].tags = {"dc" : "us-east"}
config.member[1].tags = {"dc" : "us-west"}
config.member[2].tags = {"dc" : "us-east"}
```
- 각 멤버는 여러 태그를 가질 수 있다
- 다음 단계로, 복제 셋 구성에 "getLastErrorMode" 필드를 생성해 규칙을 추가해야 한다
  - 이런 네이밍은 몽고 2.6 이전에 애플리케이션이 쓰기 결과 확인을 지정하는데 getLastError 를 사용한 흔적..
- 각 규칙의 형식은 "name ": {"key":number} 이다
- name = 규칙의 이름
  - 클라이언트가 호출할때 이름을 사용함
  - 충분히 이해 가능한 이름을 사용할 것
- key = 태그에서의 키 필드
- number = 규칙을 충족하는데 필요한 그룹의 개수

```shell
config.settings = {}
config.settings.getLastErrorModes = [["eachDC" : {"dc" : 2}]]
rs.reconfig(config)
```
- us-east 에 하나, us-west 에 적어도 하나씩 존재하도록 규칙 설정

```shell
db.products.insertOne(
  {"_id" : 10, "item" : "envelopes"},
  {"writeConcern" : {"w" : "eachDC", "wtimeout" : 100}} // 위에서 설정한 규칙명을 사용
)
```

### 숨겨지지 않은 멤버의 과반수 보장하기
- 



## 참고
- https://developer.mongodb.com/article/srv-connection-strings/
- https://docs.mongodb.com/manual/reference/connection-string/#dns-seedlist-connection-format
- https://www.joinc.co.kr/w/man/12/srv


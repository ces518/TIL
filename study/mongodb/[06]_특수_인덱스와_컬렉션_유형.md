# 6장 특수 인덱스와 컬렉션 유형
- 큐 같은 데이터를 위한 제한 컬렉션
- 캐시를 위한 TTL 인덱스
- 단순 문자열 검색을 위한 전문 인덱스
- 2D 구현 및 구면 기하학을 위한 공간 정보 인덱스
- 대용량 파일 저장을 위한 GridFS

## 공간 정보 인덱스
- 몽고 DB 가 가지는 공간 정보 인덱스
  - 2dsphere
    - WGS84 좌표계 기반으로 지표면을 모델링하는 구면 기하학으로 작동
      - WGS84 는 지표면을 주상절벽으로 모델링한다
      - 극 지방에 약간의 평탄화가 존재함
    - 지구의 형태를 고려하기 때문에 2d 인덱스보다 정확한 거리 계산기 가능하다
  - 2d
    - 2차원평면의 점에 사용하는 것이 좋음
- 2dsphere 는 GeoJSON 형식으로 점, 선, 다각형의 기하 구조를 지정할 수 있다

```json
// 점 = 위도와 경도 좌표를 갖는 요소로 표현된다
{
  "name" : "New York City",
  "loc" : {
    "type" : "Point",
    "coordinates" : [50 , 2]
  }
}

// 선은 점의 배열로 표현된다
{
  "name" : "Hudson River",
  "loc" : {
    "type" : "LineString",
    "coordinates" : [[0,1], [0,2], 1,2]
  }
}

// 다각형은 선과 같은 방식으로 표현되지만 type 이 다르다
{
  "name" : "New England",
  "loc" : {
    "type" : "Polygon",
    "coordinates" : [[[0,1], [0,2], [1,2], [0,1]]]
  }
}
```

```shell
// createIndex 명령으로 공간 정보 인덱스를 만들 수 있다
db.openStreetMap.createIndex({"loc" : "2dsphere"})
```
- 2dsphere 인덱스를 만들려면 인덱싱할 도형이 포함된 필드 (loc) 를 지정하는 도큐먼트를 createIndex 에 전달해야 한다

### 공간 정보 쿼리 유형
- 공간 정보 쿼리 = 교차, 포함, 근접 세 가지 유형이 있다
- 찾을 항목을 GeoJSON 형태로 저장한다
- $geoIntersects : 쿼리 위치와 교차하는 도큐먼트를 찾을 수 있다
- $geoWithin : 특정 지역에 완전히 포함된 항목을 쿼리할 수 있다
- $near : 주변 위치에 쿼리할 수 있다
  - 이는 유일하게 정렬을 포함하는 공간 정보 연산자 이다
  - 결과는 항상 가까운곳 부터 먼곳 순으로 반환된다

```shell
db.openStreetMap.find(
  {"loc" : {"$geoIntersects" : {"$geometry" : eastVillage}}}
);
  
db.openStreetMap.find({"loc" : {"$geoWithin" : {"$geometry" : eastVillage}}};

db.openStreetMap.find({"loc" : {"near" : {"$geometry" : eastVillage}}};
```

### 공간 정보 인덱스 사용
- 몽고 DB 공간 정보 인덱스를 활용하면 특정 지역과 관련된 모양과 점이 포함된 컬렉션에서 공간 쿼리를 효율적으로 실행할 수 있다
- 사용자가 뉴욕에서 레스토랑을 찾도록 돕는 애플리케이션을 설계한다고 하면, 다음을 충족해야 한다
  - 사용자가 현재 위치한 지역 찾기
  - 해당 지역 내 레스토랑 수 보여주기
  - 지정된 거리 내에 있는 레스토랑 찾기
- 구면 기하학 데이터 쿼리시 2dsphere 인덱스를 사용한다

`쿼리에서의 2D vs 구면 기하학`
- 공간 정보 쿼리는 쿼리와 사용중인 인덱스 유형에 따라 구면 또는 평면 구조를 사용한다
- 다음은 각 공간 정보 연산자가 사용하는 기하 구조 유형이다

| 쿼리 유형                                    | 기하 구조 유형 |
|------------------------------------------|----------|
| $near (GeoJSON point, 2sphere 인덱스)       | 구면       |
| $near (레거시 좌표 2d 인덱스)                    | 평면       |
| $geoNear (GeoJSON point, 2sphere 인덱스)    | 구면       |
| $geoNear (레거시 좌표 2d 인덱스)                 | 평면       |
| $nearSphere (GeoJSON point, 2sphere 인덱스) | 구면       |
| $nearSphere (레거시 좌표 2d 인덱스)              | 구면       |
| geoWithin : {$geometry : ...}            | 구면       |
| geoWithin : {$box : ...}                 | 평면       |
| geoWithin : {$polygon : ...}             | 평면       |
| geoWithin : {$center : ...}              | 평면       |
| geoWithin : {$centerSphere : ...}        | 구면       |
| $geoIntersects                           | 구면       |

- 2d 인덱스는 구 (sphere) 에서 평면 기하학과 거리 계산을 모두 지원한다
- 하지만 구면 기하학을 사용하는 쿼리는 2dsphere 인덱스를 사용할 때 성능과 정확성이 향상됨
- $geoNear : 집계 연산자 라는 점에 유의
- $near 쿼리 연산 외에 $geoNear / geoNear 로 주변위치 쿼리가 가능함
  - $near 연산자는 **샤딩 된 컬렉션에서는 동작하지 않는다.**
- 집계 연산자는 2dsphere / 2d 인덱스가 컬렉션에 최대 1개만 존재해야 함
- $near $geoWithin 같은 공간 정보 쿼리 연산자는 여러 인덱스를 허용한다

`왜곡`
- 구면 기하는 지도에 시각화하면 왜곡이 있음
  - 지구와 같은 3차원 구를 평면에 투사하는 특성 때문

### 복합 공간 정보 인덱스
- 공간 정보 인덱스는 다른 인덱스와 마찬가지로 다른 필드와 묶음으로 인해 더 복잡한 쿼리 최적화가 가능하다

```shell
db.openStreet.createIndex({"tags" : 1, "location" : "2dsphere"})
```

### 2d 인덱스
- 비구체 지도 에는 2d 인덱스를 사용한다

```shell
db.hyrule.createIndex({"tile" : "2d"})
```
- 2d 인덱스는 지형이 구체가 아닌 완전한 평면이라고 가정한다
- 극 주변은 왜곡이 매우 심하므로 구체에 2d 인덱스를 사용해서는 안된다
- GeoJSON 데이터 저장시에는 2d 인덱스를 사용하지 않아야 함
  - 2d 인덱스는 점만 인덱싱 할 수 있다
    - 점 배열 저장이 가능하지만 정확하게는 선이 아닌 점의 배열을 저장한다.
- $geoWithin 쿼리에서 큰 차이가 있다
  - 점들로 이루어진 선은 도형에 완전히 포함되지 않는다.

```shell
db.hyrule.createIndex({"light-years" : "2d"}, {"min" : -1000, "max" : 1000})
```
- 기본적으로 2d 인덱스는 값의 범위가 -180 ~ 180 사이라고 가정한다
- 범위 설정시 createIndex 로 범위를 지정해야한다
- $geoWithin, $nearSphere, $near 쿼리 셀렉터를 지원한다
- $geoWithin : 평평한 표면에 정의된 영역 쿼리시 사용. 직사각, 다각형, 원 구 안에 있는 모든 점 쿼리가 가능하다
  - $geometry 연산자 를 이용해 GeoJSON 객체를 지정한다
- 몽고 DB 는 레거시 지원을 위해 2d 인덱스에 대한 기초적인 구형 쿼리를 지우너한다
- 일반적으로 구형 쿼리는 2dsphere 인덱스를 사용해야함
- 하지만 구내 에 있는 레거시 좌표 쌍을 쿼리하려면 $centerSphere 연산자와 함께 $geoWithin 을 사용한다
- 주변에 있는 점 쿼리시에는 $near 를 사용한다.
  - 근접 쿼리는 특정 지점으로부터 가장 가까운 좌표 쌍을 포함하는 도큐먼트를 반환하고 결과를 거리순으로 정렬한다

## 전문 검색을 위한 인덱스
- 몽고 DB 의 text 인덱스는 전문 검색의 요구 사항을 지원한다
- text 인덱스를 몽고 DB 아틀라스 전문 검색 인덱스와 혼동해서는 안된다
- 아틀라스 전문 검색 인덱스는 아파치 루씬을 활용해 추가 검색 기능을 구현한다
- 제목, 설명 등 키워드 쿼리를 사용하려면 text 인덱스를 사용하자
- 5장에서는 정규표현식을 이용해 쿼리했지만 이는 쿼리 속도가 느리며 문법과 같은 언어 특성을 반영하기도 쉽지 않다
- text 인덱스는 빠른 검색, 언어에 적합한 토큰화, 정지 단어, 형태소 분석 등 일반적인 검색 엔진 요구 사항을 지원한다
- text 인덱스에서 필요한 키의 개수 = 인덱스되는 필드의 단어 개수에 비례
- 인덱스 생성시 애플리케이션 성능에 영향을 미치지 않도록 백그라운드에서 인덱스를 구축해야 한다

### 텍스트 인덱스 생성

```shell
db.articles.createIndex({"title" : "text", "body" : "text"});
```
- 일반적인 복합 인덱스는 키에 순서가 있지만, text 인덱스에서는 동등하게 고려된다
- 각 필드에 대해 가중치 설정도 가능하다.

```shell
db.articles.createIndex({"title" : "text", "body" : "text"}, {
  "weights" : {
    "title" : 3,
    "body" : 2}}
);
```
- 인덱스 생성이후, 삭제하지 않는이상 가중치 변경이 불가능하다.
- 도큐먼트에 포함된 필드를 모를 경우 $ ** 로 인덱스 생성시 모든 문자열 필드에 전문 인덱스 생성이 간으하다

```shell
db.articles.createIndex({"$**" : "text"})
```

### 텍스트 검색
- $text 쿼리 연산자를 사용하면 text 인덱스에 대해 텍스트 검색이 가능하다
- 공백과구두점을 구분 기호로 사용해 검색 문자열을 토큰화 하며, 검색 문자열에서 모든 토큰의 논리적 OR 를 수행한다.
- 다음과 같이 쿼리하면, impact crater lunar 라는 용어가 포함된 모든 기사를 찾는다

```shell
db.articles.find({"$text" : {"$search" : "impact crater lunar"}}).limit(10);
```
- text 인덱스를 효과적으로 상요하려면 티겟트 인덱스가 동작하는 방식을 이해해야 한다.
- 위 방식은 두가지 문제가 있다
  - 몽고가 논리적 OR 를 사용해 쿼리해 범위가 매우 광범위하다
  - 텍스트 검색이 기본적으로 결과를 관련성에 따라 정렬하지 않는다
- 구문을 사용해 쿼리 자체의 문제를 해결할 수 있다
- 텍스트를 큰 따옴표로 묶어 정확히 일치하는 구문 검색이 가능하다

```shell
db.articles.find({"$text" : {"$search" : "\"impact crater\" lunar"}});
```
- 위 쿼리는 "impact crater" AND lunar 로 처리한다
- 쿼리의 개별 용어 사이에서 논리적 AND 를 실행하려면 각 용어를 큰 따옴표로 묶어 구문으로 처리하자
- 텍스트 쿼리는 각 쿼리 결과에 메타데이터가 연결된다
  - $meta 를 사용해 명시적으로 투영하지 않는 한 결과에 포함되지 않음
  - 관련 스코어는 textScore 라는 메타 데이터 필드에 저장된다

```shell
db.articles.find({"$text" : {"$search" : "\"impact crater\" lunar"}, {"title" : 1, "score" : {"$meta" : "textScore"}}});
```
- 관련 점수순으로 정렬하려면 sort 호출을 추가로 해주어야 한다.

```shell
db.articles.find(
  {"$text" : {"$search" : "\"impact crater\" lunar"}, 
    {"title" : 1, "score" : {"$meta" : "textScore"}}
  }
).sort({"score" : {$"meta" : "textScore"}}).limit(10);
```

### 전문 검색 최적화
- 전문 검색을 최적화 하는 방법은 2가지
- 다른 기준으로 검색 결과를 좁힐 수 있다면 복합 인덱스를 생성할 때 다른 기준을 첫 번째로 두고 전문 필드를 그 다음으로 두어야 한다

```shell
db.blog.createIndex({"date" : 1, "post" : "text"});
```
- 예제에서는 전문 인덱스를 date 에 따라 몇 개의 작은 트리로 쪼개며, 이를 **파티셔닝** 이라고 한다.
- 전문 인덱스를 분할해 특정 날짜에 댛나 전문 검색을 훨씬 빨리 할 수 있다
- 또한 다른 기준을 뒤쪽에 두어 사용할 수도 있다

```shell
db.blog.createIndex({"post" : "text", "author" : 1});
```
- 접두사 방식과 접미 방식을 합칠 수도 있다.

```shell
db.blog.createIndex({"date" : 1, "post" : "text", "author" : 1});
```

### 다른 언어로 검색하기
- 도큐먼트가 입력되면 몽고 DB 는 인덱스 필드를 살펴보고 기본 구성 단위로 줄여가며 각 단어의 형태소를 분석한다
- 언어에 따라 형태소 분석 방법이 다르기 대문에 인덱스에 어떤 언어로 쓰였는지 명시해야 한다
- text 인덱스는 기본값으로 english 이며, default_language 옵션을 변경할 수 있다

```shell
db.users.createIndex({"profil" : "text"}, {"default_language" : "french"});
```

## 제한 컬렉션
- 몽고 DB 의 일반적인 컬렉션은 동적으로 생성되고 추가적인 데이터에 맞춰 크기가 자동으로 늘어난다
- 제한 컬렉션이라는 다른 형태의 컬렉션을 지원하는데, 이는 미리 생성되어 크기가 고정되어 있다
- 이미 가득찬 제한 컬렉션에 입력을 시도하면 어떻게 될까 ?
  - 제한 컬렉션이 환형 큐 처럼 동작한다
  - 빈 공간이 없으면 가장 오래된 도큐먼트가 지워지고 새로운 도큐먼트가 그 자리를 차지하게 된다
- 어떤 작업들은 제한 컬렉션에서 허용되지 않는다
  - 도큐먼트 삭제 불가
  - 도큐먼트 크기 커지도록 하는 갱신 불가
- 위 작업들을 제한함으로써 제한 컬렉션의 도큐먼트는 입력 순서대로 저장되며, 삭제된 도큐먼트로 인해 생긴 가용 저장공간 목록을 유지할 필요도 없다
- 대부분 몽고 DB 컬렉션의 접근 방식과 다르게 제한 컬렉션은 데이터가 디스크의 고정된 영역에 순서대로 기록된다
  - 때문에 회전 디스크에서 쓰기를 다소 빠르게 수행할 수 있다
- 몽고 DB TTL 인덱스는 와이어드타이거 스토리지 엔진에서 더 나은 성능을 발휘하므로 제한 컬렉션 보다 권장된다
- TTL 인덱스는 날짜 유형 필드 값과 인덱스의 TTL 값을 기반으로 일반 컬렉션에서 데이터가 만료되고 제거된다
- 제한 컬렉션은 유연성이 부족하지만 로깅에서 나름 유용하다


### 제한 컬렉션 생성
- 일반 컬렉션과 달리 제한 컬렉션은 사용 전 명시적으로 생성해야 한다

```shell
db>.createCollection("my_collection", {"crapped" : true, "size" : 100000, "max" : 100});
```
- 제한 컬렉션 내 10만 바이트 고정크기로 생성후, 도큐먼트 수에 제한을 지정할 수 있다
- 제한 컬렉션은 생성 이후 변경할 수 없다.
  - 속성을 변경하려면 삭제 후 재생성 해야 한다
  - 크기가 큰 컬렉션은 생성 전 신중이 검토해야 한다

```shell
db.runCommand({"convertToCapped" : "test" : "size" : 10000}); {"ok" : true}
```
- 제한 컬렉션을 생성하는 또 다른 방법으로 기본 일반 컬렉션을 제한 컬렉션으로 변환할 수 있다
  - convertToCapped
- 제한 컬렉션을 일반 컬렉션으로 변환하는 방법은 없다

### 꼬리를 무는 커서
- 꼬리를 무는 커서 (tailable cursor) 는 결과를 모두 꺼낸 후에도 종료되지 않는 커서이며 tail -f 명령에서 영감을 받아 만들었다
- tail -f 와 비슷하게 결과를 지속적으로 꺼내는 기능을 수행한다
- 일반 컬렉션에서는 입력 순서가 추적되지 않기 대문에 꼬리를 무는 커서는 제한 컬렉션에만 사용한다
- 스트림 변경은 꼬리를 무는 커서보다 훨씬 많은 제어와 구성을 제공하며 일반 컬렉션에서도 작동하기 때문에 대부분의 경우에 더 권장 된다
- 꼬리를 무는 커서는 도큐먼트가 '작업 큐' 에 입력되면 도큐먼트를 처리하는데 상요한다
- 꼬리를 무는 커서는 아무런 결과가 없으면 10분 후에 종료되므로 이후 다시 쿼리하는 로직을 추가해야 한다

## TTL 인덱스
- 오래된 순 삭제 시스템을 더 유연하게 하려면 TTL 인덱스를 이용해 각 도큐먼트에 유효 시간을 설정할 수 있다.
- 도큐먼트는 미리 설정한 시간에 도달하면 지워지며 이러한 인덱스는 세션 스토리지와 같은 문제를 캐싱하는데 유용하다

```shell
// 24시간 이후 타임아웃
db.sessions.createIndex({"lastUpdated" : 1}, {"expiredAfterSeconds" : 60 * 60 * 24})
```
- lastUpdated 필드에 TTL 인덱스를 생성한다. lastUpdated 필드가 존재하고, 날짜형 이라면 서버 시간이 도큐먼트 시간의 expiredAfterSeconds 를 지나면 도큐먼트가 삭제된다
- 몽고 DB 는 TTL 인덱스를 매 분마다 청소하기 때문에 초 단위로 신경쓸 필요는 없다
- collMod 명령어를 이용해 expiredAfterSeconds 를 변경할 수 있다

```shell
db.runCommand({"collMod" : "someapp.cache", "index" : {"keyPattern" : ... {"lastUpdated" : 1}, "expiredAfterSeconds" : 3600}})
```
- 하나의 컬렉션에 TTL 인덱스를 여러 개 가질 수 있다
- 복합 인덱스는 될 수 없지만, 정렬 및 쿼리 최적화가 목적이라면 일반 인덱스처럼 사용될 수 있다

## GridFS 로 파일 젖아하기
- GridFS 는 몽고 DB 에 이진 파일을 저장하는 메커니즘이다
- 파일 저장시 GridFS 를 고려하는 데는 몇 가지 이유가 있다.
  - GridFS 를 사용하면 아키텍처 스택을 단순화할 수 있다
  - 이미 몽고 DB 를 사용중 이라면 파일 스토리지를 위한 별도의 도구 대신 GridFS 를 사용하면 된다
  - GridFS 는 몽고 DB 를 위해 설정한 기존의 복제나 자동 샤딩을 이용할 수 있어, 파일 스토리지를 위한 장애 조치와 분산 확장이 더 쉽다
  - GridFS 는 사용자가 올린 파일을 저장할 때 특정 파일시스템이 갖는 문제를 피할 수 있다
    - ex) 동일 디렉터리에 대량의 파일을 저장해도 문제가 없다
- 몇가지 단점도 존재한다
  - 성능이 느림
  - 도큐먼트 수정시 도큐먼트 전체를 삭제하고 다시 저장하는 방법밖에 없다.
  - 파일을 여러 개의 도큐먼트로 저장하므로 한 파일의 모든 청크에 동시에 락을 걸 수 없다.

> GridFS 는 큰 변화가 없고 순차적인 방식으로 접근하려는 대용량 파일 저징시 일반적으로 최선의 메커니즘 이다

### 내부 살펴보기
- GridFS 는 파일 저장을 위한 간단한 명세이며 일반 몽고 DB 도큐먼트를 기반으로 만들어 졌다.
- 몽고 DB 서버는 GridFS 요청을 처리하면서 '특별한 작업' 을 거의 하지 않으며, 모든 작업은 클라이언트 쪽의 드라이버 도구가 처리한다.
- GridFS 의 기본 개념은 대용량 파일을 **청크** 로 나눈 후 각 청크를 도큐먼트로 저장할 수 있다는 것
- 몽고 DB 는 도큐먼트에 이진 데이터를 저장할 수 있으므로 청크에 대한 저장 부하를 최소화 할 수 있다
- 파일의 청크를 저장하는 작업 외에도, 여러 청크를 묶고 파일의 메타 데이터를 포함하는 단일 도큐먼트를 만든다

```shell
{
  "_id" : ObjectId("..."),
  "n" : 0,
  "data" : BinData("..."),
  "files_id" : ObjectId("...")
}
```
- GridFS 의 청크는 자체 컬렉션에 저장된다
  - 기본적으로 fs.chunks 컬렉션에 저장되지만 바꿀 수 있다
- 다른 도큐먼트와 마찬가지로 고유한 _id 를 가지며, 그 외에도 몇 개의 키가 더 있다
  - "files_id"
    - 청크에 대한 메타데이터를 포함하는 파일 도큐먼트의 _id
  - "n"
    - 다른 청크를 기준으로 하는 파일 내 청크의 위치
  - "data"
    - 파일 내 청크의 크기 (바이트 단위)

> 각 파일의 메타데이터는 기본적으로 별도의 컬렉션인 fs.files 에 저장된다. <br/>
> files 컬렉션 내의 각 도큐먼트는 GridFS 에서 하나의 파일을 나타낸다.
- "_id"
  - 파일의 고유 아이디, 각 청크에서 file_id 키 값으로 저장됨
- "length"
  - 파일 내용의 총 바이트 수
- "chunkSize"
  - 파일을 구성하는 각 청크의 크기이며 단위는 바이트
  - 기본적으로 256 킬로바이트
- "uploadDate"
  - GridFS 파일이 저장된 시간
- "md5"
  - 서버에서 생성된 파일 내용의 MD5 체크섬

> filemd5 명령을 사용해 md5 값을 생성한다


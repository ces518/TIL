# 6장 특수 인덱스와 컬렉션 유형
- 큐 같은 데이터를 위한 제한 컬렉션
- 캐시를 위한 TTL 인덱스
- 단순 문자열 검색을 위한 전문 인덱스
- 2D 구현 및 구면 기하학을 위한 공간 정보 인덱스
- 대용량 파일 저장을 위한 GridFS

## 공간 정보 인덱스
- 몽고 DB 가 가지는 공간 정보 인덱스
  - 2dsphere
    - WGS84 좌표계 기반으로 지표면을 모델링하는 구면 기하학으로 작동
      - WGS84 는 지표면을 주상절벽으로 모델링한다
      - 극 지방에 약간의 평탄화가 존재함
    - 지구의 형태를 고려하기 때문에 2d 인덱스보다 정확한 거리 계산기 가능하다
  - 2d
    - 2차원평면의 점에 사용하는 것이 좋음
- 2dsphere 는 GeoJSON 형식으로 점, 선, 다각형의 기하 구조를 지정할 수 있다

```json
// 점 = 위도와 경도 좌표를 갖는 요소로 표현된다
{
  "name" : "New York City",
  "loc" : {
    "type" : "Point",
    "coordinates" : [50 , 2]
  }
}

// 선은 점의 배열로 표현된다
{
  "name" : "Hudson River",
  "loc" : {
    "type" : "LineString",
    "coordinates" : [[0,1], [0,2], 1,2]
  }
}

// 다각형은 선과 같은 방식으로 표현되지만 type 이 다르다
{
  "name" : "New England",
  "loc" : {
    "type" : "Polygon",
    "coordinates" : [[[0,1], [0,2], [1,2], [0,1]]]
  }
}
```

```shell
// createIndex 명령으로 공간 정보 인덱스를 만들 수 있다
db.openStreetMap.createIndex({"loc" : "2dsphere"})
```
- 2dsphere 인덱스를 만들려면 인덱싱할 도형이 포함된 필드 (loc) 를 지정하는 도큐먼트를 createIndex 에 전달해야 한다

### 공간 정보 쿼리 유형
- 공간 정보 쿼리 = 교차, 포함, 근접 세 가지 유형이 있다
- 찾을 항목을 GeoJSON 형태로 저장한다
- $geoIntersects : 쿼리 위치와 교차하는 도큐먼트를 찾을 수 있다
- $geoWithin : 특정 지역에 완전히 포함된 항목을 쿼리할 수 있다
- $near : 주변 위치에 쿼리할 수 있다
  - 이는 유일하게 정렬을 포함하는 공간 정보 연산자 이다
  - 결과는 항상 가까운곳 부터 먼곳 순으로 반환된다

```shell
db.openStreetMap.find(
  {"loc" : {"$geoIntersects" : {"$geometry" : eastVillage}}}
);
  
db.openStreetMap.find({"loc" : {"$geoWithin" : {"$geometry" : eastVillage}}};

db.openStreetMap.find({"loc" : {"near" : {"$geometry" : eastVillage}}};
```

### 공간 정보 인덱스 사용
- 몽고 DB 공간 정보 인덱스를 활용하면 특정 지역과 관련된 모양과 점이 포함된 컬렉션에서 공간 쿼리를 효율적으로 실행할 수 있다
- 사용자가 뉴욕에서 레스토랑을 찾도록 돕는 애플리케이션을 설계한다고 하면, 다음을 충족해야 한다
  - 사용자가 현재 위치한 지역 찾기
  - 해당 지역 내 레스토랑 수 보여주기
  - 지정된 거리 내에 있는 레스토랑 찾기
- 구면 기하학 데이터 쿼리시 2dsphere 인덱스를 사용한다

`쿼리에서의 2D vs 구면 기하학`
- 공간 정보 쿼리는 쿼리와 사용중인 인덱스 유형에 따라 구면 또는 평면 구조를 사용한다
- 다음은 각 공간 정보 연산자가 사용하는 기하 구조 유형이다

| 쿼리 유형                                    | 기하 구조 유형 |
|------------------------------------------|----------|
| $near (GeoJSON point, 2sphere 인덱스)       | 구면       |
| $near (레거시 좌표 2d 인덱스)                    | 평면       |
| $geoNear (GeoJSON point, 2sphere 인덱스)    | 구면       |
| $geoNear (레거시 좌표 2d 인덱스)                 | 평면       |
| $nearSphere (GeoJSON point, 2sphere 인덱스) | 구면       |
| $nearSphere (레거시 좌표 2d 인덱스)              | 구면       |
| geoWithin : {$geometry : ...}            | 구면       |
| geoWithin : {$box : ...}                 | 평면       |
| geoWithin : {$polygon : ...}             | 평면       |
| geoWithin : {$center : ...}              | 평면       |
| geoWithin : {$centerSphere : ...}        | 구면       |
| $geoIntersects                           | 구면       |

- 2d 인덱스는 구 (sphere) 에서 평면 기하학과 거리 계산을 모두 지원한다
- 하지만 구면 기하학을 사용하는 쿼리는 2dsphere 인덱스를 사용할 때 성능과 정확성이 향상됨
- $geoNear : 집계 연산자 라는 점에 유의
- $near 쿼리 연산 외에 $geoNear / geoNear 로 주변위치 쿼리가 가능함
  - $near 연산자는 **샤딩 된 컬렉션에서는 동작하지 않는다.**
- 집계 연산자는 2dsphere / 2d 인덱스가 컬렉션에 최대 1개만 존재해야 함
- $near $geoWithin 같은 공간 정보 쿼리 연산자는 여러 인덱스를 허용한다

`왜곡`
- 구면 기하는 지도에 시각화하면 왜곡이 있음
  - 지구와 같은 3차원 구를 평면에 투사하는 특성 때문

### 복합 공간 정보 인덱스
- 공간 정보 인덱스는 다른 인덱스와 마찬가지로 다른 필드와 묶음으로 인해 더 복잡한 쿼리 최적화가 가능하다

```shell
db.openStreet.createIndex({"tags" : 1, "location" : "2dsphere"})
```

### 2d 인덱스
- 비구체 지도 에는 2d 인덱스를 사용한다

```shell
db.hyrule.createIndex({"tile" : "2d"})
```
- 2d 인덱스는 지형이 구체가 아닌 완전한 평면이라고 가정한다
- 극 주변은 왜곡이 매우 심하므로 구체에 2d 인덱스를 사용해서는 안된다
- GeoJSON 데이터 저장시에는 2d 인덱스를 사용하지 않아야 함
  - 2d 인덱스는 점만 인덱싱 할 수 있다
    - 점 배열 저장이 가능하지만 정확하게는 선이 아닌 점의 배열을 저장한다.
- $geoWithin 쿼리에서 큰 차이가 있다
  - 점들로 이루어진 선은 도형에 완전히 포함되지 않는다.

```shell
db.hyrule.createIndex({"light-years" : "2d"}, {"min" : -1000, "max" : 1000})
```
- 기본적으로 2d 인덱스는 값의 범위가 -180 ~ 180 사이라고 가정한다
- 범위 설정시 createIndex 로 범위를 지정해야한다
- $geoWithin, $nearSphere, $near 쿼리 셀렉터를 지원한다
- $geoWithin : 평평한 표면에 정의된 영역 쿼리시 사용. 직사각, 다각형, 원 구 안에 있는 모든 점 쿼리가 가능하다
  - $geometry 연산자 를 이용해 GeoJSON 객체를 지정한다
- 몽고 DB 는 레거시 지원을 위해 2d 인덱스에 대한 기초적인 구형 쿼리를 지우너한다
- 일반적으로 구형 쿼리는 2dsphere 인덱스를 사용해야함
- 하지만 구내 에 있는 레거시 좌표 쌍을 쿼리하려면 $centerSphere 연산자와 함께 $geoWithin 을 사용한다
- 주변에 있는 점 쿼리시에는 $near 를 사용한다.
  - 근접 쿼리는 특정 지점으로부터 가장 가까운 좌표 쌍을 포함하는 도큐먼트를 반환하고 결과를 거리순으로 정렬한다

## 전문 검색을 위한 인덱스
- 몽고 DB 의 text 인덱스는 전문 검색의 요구 사항을 지원한다
- text 인덱스를 몽고 DB 아틀라스 전문 검색 인덱스와 혼동해서는 안된다
- 아틀라스 전문 검색 인덱스는 아파치 루씬을 활용해 추가 검색 기능을 구현한다
- 제목, 설명 등 키워드 쿼리를 사용하려면 text 인덱스를 사용하자
- 5장에서는 정규표현식을 이용해 쿼리했지만 이는 쿼리 속도가 느리며 문법과 같은 언어 특성을 반영하기도 쉽지 않다
- text 인덱스는 빠른 검색, 언어에 적합한 토큰화, 정지 단어, 형태소 분석 등 일반적인 검색 엔진 요구 사항을 지원한다
- text 인덱스에서 필요한 키의 개수 = 인덱스되는 필드의 단어 개수에 비례
- 인덱스 생성시 애플리케이션 성능에 영향을 미치지 않도록 백그라운드에서 인덱스를 구축해야 한다

### 텍스트 인덱스 생성

```shell
db.articles.createIndex({"title" : "text", "body" : "text"});
```
- 일반적인 복합 인덱스는 키에 순서가 있지만, text 인덱스에서는 동등하게 고려된다
- 각 필드에 대해 가중치 설정도 가능하다.

```shell
db.articles.createIndex({"title" : "text", "body" : "text"}, {
  "weights" : {
    "title" : 3,
    "body" : 2}}
);
```
- 인덱스 생성이후, 삭제하지 않는이상 가중치 변경이 불가능하다.
- 도큐먼트에 포함된 필드를 모를 경우 $ ** 로 인덱스 생성시 모든 문자열 필드에 전문 인덱스 생성이 간으하다

```shell
db.articles.createIndex({"$**" : "text"})
```

### 텍스트 검색
- $text 쿼리 연산자를 사용하면 text 인덱스에 대해 텍스트 검색이 가능하다
- 공백과구두점을 구분 기호로 사용해 검색 문자열을 토큰화 하며, 검색 문자열에서 모든 토큰의 논리적 OR 를 수행한다.
- 다음과 같이 쿼리하면, impact crater lunar 라는 용어가 포함된 모든 기사를 찾는다

```shell
db.articles.find({"$text" : {"$search" : "impact crater lunar"}}).limit(10);
```
- text 인덱스를 효과적으로 상요하려면 티겟트 인덱스가 동작하는 방식을 이해해야 한다.
- 위 방식은 두가지 문제가 있다
  - 몽고가 논리적 OR 를 사용해 쿼리해 범위가 매우 광범위하다
  - 텍스트 검색이 기본적으로 결과를 관련성에 따라 정렬하지 않는다
- 구문을 사용해 쿼리 자체의 문제를 해결할 수 있다
- 텍스트를 큰 따옴표로 묶어 정확히 일치하는 구문 검색이 가능하다

```shell
db.articles.find({"$text" : {"$search" : "\"impact crater\" lunar"}});
```
- 위 쿼리는 "impact crater" AND lunar 로 처리한다
- 쿼리의 개별 용어 사이에서 논리적 AND 를 실행하려면 각 용어를 큰 따옴표로 묶어 구문으로 처리하자
- 텍스트 쿼리는 각 쿼리 결과에 메타데이터가 연결된다
  - $meta 를 사용해 명시적으로 투영하지 않는 한 결과에 포함되지 않음
  - 관련 스코어는 textScore 라는 메타 데이터 필드에 저장된다

```shell
db.articles.find({"$text" : {"$search" : "\"impact crater\" lunar"}, {"title" : 1, "score" : {"$meta" : "textScore"}}});
```
- 관련 점수순으로 정렬하려면 sort 호출을 추가로 해주어야 한다.

```shell
db.articles.find(
  {"$text" : {"$search" : "\"impact crater\" lunar"}, 
    {"title" : 1, "score" : {"$meta" : "textScore"}}
  }
).sort({"score" : {$"meta" : "textScore"}}).limit(10);
```

### 전문 검색 최적화
- 전문 검색을 최적화 하는 방법은 2가지
- 다른 기준으로 검색 결과를 좁힐 수 있다면 복합 인덱스를 생성할 때 다른 기준을 첫 번째로 두고 전문 필드를 그 다음으로 두어야 한다

```shell
db.blog.createIndex({"date" : 1, "post" : "text"});
```
- 예제에서는 전문 인덱스를 date 에 따라 몇 개의 작은 트리로 쪼개며, 이를 **파티셔닝** 이라고 한다.
- 전문 인덱스를 분할해 특정 날짜에 댛나 전문 검색을 훨씬 빨리 할 수 있다
- 또한 다른 기준을 뒤쪽에 두어 사용할 수도 있다

```shell
db.blog.createIndex({"post" : "text", "author" : 1});
```
- 접두사 방식과 접미 방식을 합칠 수도 있다.

```shell
db.blog.createIndex({"date" : 1, "post" : "text", "author" : 1});
```

### 다른 언어로 검색하기
- 도큐먼트가 입력되면 몽고 DB 는 인덱스 필드를 살펴보고 기본 구성 단위로 줄여가며 각 단어의 형태소를 분석한다
- 언어에 따라 형태소 분석 방법이 다르기 대문에 인덱스에 어떤 언어로 쓰였는지 명시해야 한다
- text 인덱스는 기본값으로 english 이며, default_language 옵션을 변경할 수 있다

```shell
db.users.createIndex({"profil" : "text"}, {"default_language" : "french"});
```

## 제한 컬렉션
- 몽고 DB 의 일반적인 컬렉션은 동적으로 생성되고 추가적인 데이터에 맞춰 크기가 자동으로 늘어난다
- 제한 컬렉션이라는 다른 형태의 컬렉션을 지원하는데, 이는 미리 생ㅅ어되어 크기가 고정되어 있다
- 
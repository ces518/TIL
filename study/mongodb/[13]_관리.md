# 13장 관리
- 개별 멤버에 유지 보수 수행하기
- 다양한 환경에서 복제 셋 구성하기
- 사용자 oplog 정보를 얻고 크기 조정하기
- 좀 더 색다른 복제 셋 구성하기
- 마스터/슬레이브 구조에서 복제 셋으로 전환하기

## 독립 실행형 모드에서 멤버 시작
- 독립 실행형 모드에서 멤버를 시작하려면 명령행 인수를 확인해야 한다

```shell
db.serverCmdLineOpts()
{
  "argv" : ["mongod", "-f", "/var/lib/mongod.conf"],
  "parsed" : {
    "replSet" : "mySet",
    "port" : "27017",
    "dbpath" : "/var/lib/db"
  },
  "ok" : 1
}
```
- 위와 같은 서버에서 유지 보수를 수행하려면 replSet 옵션 없이 재시작 해야한다
  - 일반적인 독립 실행형 mongod 처럼 읽기/쓰기가 가능하다
- 복제 셋의 다른 멤버들과 통신하지 않도록 달느 포트로 수신하게 하며 dbpath 는 그대로 유지한다

```shell
db.shutdownServer()
mongod --port 30000 --dbpath /var/lib/db
```
- 서버에서 유지보수 수행을 마친 후 원래 옵션으로 재시작 가능하다
- 서버는 유지보수 모드 동안 놓친 연산들을 복제해 복제 셋의 다른 멤버와 자동으로 동기화 하게 된다

## 복제 셋 구성
- 복제 셋 구성은 항상 local.system.replset 컬렉션 도큐먼트에 보관된다
- 이 도큐먼트는 복제 셋의 모든 멤버에서 동일하다
- update 를 이용해 도큐먼트를 변경해서는 안되며 항상 rs 보조자 혹은 replSetReconfig 명령을 사용해야 한다

### 복제 셋 생성
- 멤버로 만들 mongod 들을 시작하고 그 중 하나에 rs.initiate() 를 사용해 구성 정보를 전달함으로써 복제 셋을 생성한다

```shell
var config = {
  "_id" : <setName>,
  "members" : [
    {"_id" : 0, "host" : <host1>},
    {"_id" : 1, "host" : <host2>}
  ]
}
rs.initiate(config)
```
- 복제 셋의 한 멤버에서만 rs.initiate 호출이 가능하다

> 항상 config 객체를 rs.initiate() 에 전달해야 한다. 만약 그렇지 못한 경우 자동으로 단일 멤버 복제셋을 위한 config 를 생성하게 된다

### 복제 셋 멤버 교체하기
- 복제 셋에 새로운 멤버를 추가할 때는 데이터 디렉터리에 아무것도 존재하지 않거나 다른 멤버 데이터의 복제본이 있어야 한다

```shell
// 새로운 멤버 추가
rs.add("spock:27017")

// 복잡한 멤버 구성 
rs.add({"host" : "spock:27017", "priority" : 0, "hidden" : true})

// 멤버 제거
rs.remove("spock:27017")
```
- 재구성을 통해 멤버의 설정을 변경할 수 있는데, 다음과 같은 제약사항이 존재한다
  - 멤버의 _id 는 변경할 수 없다
  - 재구성 정보를 전달하려는 멤버의 우선순위를 0으로 할 수 없다
  - 아비터에서 아비터가 아닌 것으로 변경할 수 없으며, 반대도 마찬가지다
  - 멤버의 buildIndexes 를 false 에서 true 로 변경할 수 없다

```shell
// 멤버 host 변경하기
var config = rs.config()
config.members[0].host = "spock:27017"
rs.reconfig(config)
```

### 큰 복제 셋 만들기
- 복제 셋에서 멤버는 50개, 투표 멤버는 7개로 제한된다
  - 이는 다른 멤버에 하트비트를 보내는데 필요한 트래픽을 줄이고 선출에 걸리는 시간을 제한하기 위함
- 멤버가 7개 이상인 복제셋 생성시, 모든 추가적인 멤버는 투표권이 0개여야 한다
  - 이는 해당 멤버들이 선출과정에서 투표권을 행사하는 것을 방지한다

```shell
rs.add({"_id" : 7, "host" : "server-7:27017", "votes" : 0})
```

### 재구성 강제하기
- 복제 셋의 과반수를 영구적으로 잃으면, 프라이머리가 없는 상태에서 설정을 재구성할 필요가 있다
- 일반적으로 재구성을 프라이머리에 요청하게 되는데, 이때 세컨더리에 재구성 명령을 보냄으로써 복제 셋 재구성을 강제할 수 있다
- 셸에서 세컨더리에 연결하고, "force" 옵션을 통해 재구성 명령을 전달한다

```shell
rs.reconfig(config, {"force" : true})
```
- 강제 재구성은 일반 재구성과 같은 규칙을 따르며, 사용자는 유효하고 잘 구성된 구성 정보를 올발느 옵션으로 보내야 한다
- "force" 옵션은 유효하지 않은 구성 정보를 허용하지 않고, 세컨더리가 재구성 정보를 받아들이도록 허용한다
- 강제 재구성은 복제 셋 "version" 을 크게 올린다. (수천 단위를 건너뛰는데 이는 정상)
  - 이는 재구성 정보가 네트워크 파티션 양쪽에 있을 때 버전 번호가 충돌하지 않도록 하기 위함
- 세컨더리는 재구성 정보를 받으면 자신의 구성 정보 개신후 새로운 구성정보를 다른 멤버에 전달함
  - 일부 멤버가 호스트명을 변경하면 예전 호스트 명을 그대로 갖는 멤버를 강제 재구성해야 함
- 모든 멤버가 새로운 호스트명을 가지면 복제 셋의 각 멤버를 다운시키고, 새로운 멤버를 독립 실행형 모드로 시작한 뒤, local.system.replset 도큐먼트를 수동으로 변경하고 멤버를 재시작 한다

## 멤버 상태 조작

### 프라이머리에서 세컨더리로 변경

```shell
re.stepDown()
```
- stepDown 함수로 프라이머리르 세컨더리로 강등시킬 수 있다
- 프라이머리를 60초 동안 세컨더리로 만들고, 그 기간동안 다른 프라이머리가 선출되지 않으면 세컨더리로 변경했던 프라이머리는 재선출을 시도할 수 있다

### 선출 방지하기
- 프라이머리에서 유지 보수 작업을 수행해야하고, 그 사이 자격이 있는 다른 멤버가 프라이머리가 되지 않도록 하려면, 각 멤버의 freeze 명령을 실행함으로써 세컨더리 상태에 머물게 한다

```shell
rs.freeze(10000)
```
- 시간이 경과하기 전 유지보수를 완료해 다른 멤버의 freeze 상태를 해제하려면, 각 멤버에 timeout 을 0초로 지정해 다시 실행한다
- freeze 상태가 아닌 멤버는 원한다면 선출을 실시할 수 있다

## 복제 모니터링
- 모든 멤버가 정상적으로 기동했는지, 멤버가 어떤 상태인지, 복제가 얼마나 최신 상태인지 모니터링 한다
- 몇 가지 명령으로 복제 셋 정보를 볼 수 있다
- 아틀라스, 클라우드 매니저, 옵스 매니저를 포함한 관리 도구는 복제 모니터링을 하는 메커니즘과 주요 복제 지표에 대한 대시보드를 제공한다
- 복제와 관련된 문제는 일시적인 경우가 많다
- 로그를 확인하면 이런 문제를 쉽게 볼 수 있다

### 상태 정보 가져오기
- 복제 셋의 모든 멤버 정보를 얻는데 가장 유용한 명령 "replSetGetStatus"
- 셸에는 이 명령에 사용가능한 보조자가 있다

```shell
rs.status()
```

### 복제 그래프 시각화하기
- 세컨더리에서 rs.status() 를 실행하면 "syncingTo" 라는 최상위 필드 확인이 가능하다
- 이는 멤버가 복제를 수행하는 호스트를 제공한다
- 복제 셋의 각 멤버에서 replGetStatus 명령을 실행하면 복제 그래프를 알아낼 수 있다

```shell
server1.adminCommand({replSetGetStatus: 1})['syncingTo']
server2.adminCommand({replSetGetStatus: 1})['syncingTo']
server3.adminCommand({replSetGetStatus: 1})['syncingTo']
```
- 몽고 DB 는 핑 시간을 기준으로 동기화할 대상을 결정한다
- 멤버는 다른 멤버에 하트비트를 보낼 때 요청이 처리되기까지 걸리는 시간을 잰다
- 몽고 DB 는 이러한 평균 실행 시간을 보관하고, 동기화할 멤버 선택시 가장 가깝고 복제에서 자신보다 앞선 멤버를 찾는다
- 만약 세컨더리가 있는 데이터 센터에 새로운 멤버를 투입하면 프라이머리가 있는 데이터 센터의 멤버보다 세컨더리가 있는 데이터 센터의 다른 멤버와 동기화할 가능성이 높다
- 자동 복제 사슬에는 단점이 있따
  - 복제 홉이 많을수록 모든 서버에 쓰기를 복제하는데 시간이 좀 더 오래 걸림
  - 사슬 내에서 각 세컨더리는 앞에 있는 세컨더리보다 조금 뒤져쳐 있어야 한다
  - replSetSyncFrom 명령을 이용해 멤버의 복제 소스를 수정할으로써 문제를 해결할 수 있다

```shell
secondary.adminCommand({"replSetSyncFrom" : "server0:27017"})
```
- 복제 소스를 바꾸려는 세컨더리에 연결해 이를 실행한다
- 명령에는 동기화를 원하는 서버를 전달한다

### 복제 루프
- 복제 루프 => 모든 멤버가 다른 멤버로부터 복제를 수행하는 상태
  - A => B / B => C / C => A 로 부터 동기화하는 상태를 의미
- 모든 복제 루프 멤버는 프라이머리가 될 수 없다
- 멤버들은 복제를 위한 새로운 명령을 받을 수 없고 뒤처지게 딘다
- 멤버가 동기화할 멤버를 자동으로 고를 때는 복제 루프가 발생하지 않는다
- replSetSyncFrom 명령으로 복제 루프를 강제로 수행할 수 있다
- 수동으로 동기화 대상을 바꾸기 전 rs.status() 로 확인하고 루프를 만들지 않도록 주의해야 한다

#### 복제 사슬 비활성화하기
- 복제 사슬 => 세컨더리가 다른 세컨더리와 동기화할 때 발생한다
- 멤버는 자동으로 다른 멤버와 동기화하도록 결정할 수 있다

```shell
var config = rs.config()
config.settings = config.settings || {}
config.settings.chainingAllowed = false
rs.reconfig(config)
```
- chainingAllowed = false 로 설정하면 모든 멤버는 프라이머리와 동기화 한다
- 프라이머리가 이용 불가능하다면 세컨더리와 동기화 한다

### 지연 계산하기
- 복제를 추적하는 지표로, 세컨더리가 얼마나 프라이머리르 잘 따라잡는지가 중요하다
- 지연 => 세컨더리가 얼마나 뒤쳐져 있는지를 나타냄
  - 프라이머리가 마지막으로 수행한 연산과 세컨더리가 마지막으로 적용한 연산의 타임 스탬프의 차이를 의미한다
- rs.config => 멤버의 복제 상태 확인
- rs.printReplicationInfo() / rs.printSlaveReplicationInfo() 로 빠른 요약을 얻을 수 있다

### Oplog 크기 변경하기
- 프라이머리의 oplog 는 유지 보수 시간으로 여겨진다
- 프라이머리의 oplog 길이가 한 시간 정도라면 잘못된 부분을 고칠 수 있는 시간이 한시간 정도라는 의미이다
- 약간의 여유가 있으려면 며칠 ~ 1주 정도 데이터를 보유가능한 oplog 가 바람직하다
- oplog 가 가득차기전 까지는 얼마나 지속될지 쉽게 알 수 없다
- 와이어드타이거 엔진을 사용한다면 서버가 실행되는 동안 oplog 크기 조정이 가능하다

`oplog 크기 늘리기`
1. 복제 셋 멤버에 연결
2. 인증 활성화 이후 local 데이터베이스를 수정할 권한이 있는 사용자를 사용해야 한다
3. oplog 현재 크기 확인
   - db.oplog.rs.status(1024 * 1024).maxSize
4. 복제 셋 멤버의 oplog 크기 변경
   - db.adminCommand({replSetResizeOplog : 1, size : 16000})
5. 마지막으로 oplog 크기를 줄였다면 compact 를 실행해 할당된 시크르 공간을 회수해야 할 수도 있다
   - 하지만 해당 멤버가 프라이머리라면 실행해선 안됨
- 일반적으로 oplog 의 크기는 줄이면 안된다
- oplog 크기가 수개월이더라도 일반적으로 디스크공간을 충분하며 램이나 CPU 같은 리소스를 소모하지않는다

### 인덱스 구축
- 프라이머리에 인덱스를 구축하면, 프라이머리는 정상적으로 인덱스를 구축하며, 세컨더리는 build index 연산을 복제해 인덱스를 구축한다
- 인덱스 구축은 멤버를 이용불가능 상태로 만들수도 있는 리소스집약적인 ㅇ녓나이다
- 만약 모든 세컨더리가 동시에 인덱스를 구축한다면 복제 셋의 거의 모든 멤버는 완료때 까지 오프라인 상태가 된다
- 애플리케이션에 대한 영향을 최소화하려면 인덱스는 한 번에 한 멤버씩 추구한느 것이 좋다
- 고유 인덱스 구축시에는 인덱스를 프라이머리에 먼저 구축해야 한다
  - 그렇지 못한다면 중복삽입이 발생하고 세컨더리에서 복제 오류가 발생한다
  - 일너 오류 발생시 세컨더리는 스스로를 종료한다. 독립 실행형으로 재시작해 고유 인덱스 제거 후 다시 시작해야 한다

### 한정된 예산에서 복제하기
- 고성능 서버를 두 개 이상 구하기 힘들다면 낮은 성능을 가진 서버를 재해 복구용으로 고려해 보자
- 이런 서버를 설정하기 위한 옵션이다
  - priority : 0
    - 프라이머리가 절대 될 수 없음
  - hidden : true
    - 세컨더리에 읽기 요청을 절대 보내지 않음
  - buildIndexes :false
  - votes : 0

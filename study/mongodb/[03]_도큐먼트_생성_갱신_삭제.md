# 3장 도큐먼트 생성, 갱신 삭제

## 3.1 도큐먼트 삽입
- 몽고 DB 에 데이터를 추가하는 기본적인 방법
- 컬렉션의 **insertOne** 함수를 사용한다
- 도큐먼트에 "_id" 키가 추가되고 도큐먼트가 몽고 DB 에 저장 된다 

```shell
> db.movies.insertOne({ "title" : "Stand by Me" })
```

### insertMany
- 여러 도큐먼트를 삽입할 때 사용한다
- 각 도큐먼트에 대해 데이터베이스로 왕복하지 않고 도큐먼트를 대량 삽입 (bulk insert) 하므로 효율적이다
- 데이터 피드나 MySQL 등에서 raw data 를 임포트 하는 경우 일괄 삽입대신 사용가능한 mongoimport 와 같은 도구가 있다.
- 현재 버전 기준 48메가 바이트보다 큰 메세지를 허용하지 않는다
- 한 번에 일괄 삽입시 제한이 있으며, 이 보다 큰 경우 여러 개로 분할 한다.

```shell
> db.movies.insertMany(
[ 
  {
    "title" : "E.T."
  },
  {
    "title" : "Blade Runner"
  }
]
)
```
- 대량 삽입 중 도큐먼트에서 특정 유형의 오류 발생시 정렬 연산이냐, 비정렬 연산이냐 선택함에 따라 발생하는 상황이 달라진다
- insertMany 의 두번 째 인자로 옵션 도큐먼트를 지정한다
- 제공 순서대로 삽입한다면 {ordered : true} 로 전달한다.
- false 로 지정한다면 몽고 DB 가 성능 개선을 위해 삽입을 재 배열 할 수 있다
- 지정되지 않았다면 true 가 기본
- 정렬된 삽입은 배열에서 해당 도큐먼트 이후의 도큐먼트들을 삽입이 되지 않는다
- 비정렬된 삽입은 오류 발생 여부와 관계 없이 모든 도큐먼트 삽입을 시도한다

> insertMany 외에 대량 쓰기를 위한 Bulk Write API 를 제공한다

### 삽입 유효성 검사
- 도큐먼트의 기본 구조를 검사후 _id 필드가 존재하지 않으면 새로 추가하고, 모든 도큐먼트는 16 메가보다 작아야 한다
- BinaryJson (BSON) 단위로 셸에서 확인하려면 object.bisonsize(doc) 를 실행한다
- 최소한의 검사를 하는 이유 ?
  - 유효하지 않은 데이터가 입력되기 쉽다
  
### 삽입
- 몽고 3.0 이전에는 주된 방법이 insert 였다
- 3.0 릴리즈와 동시에 새로운 CRUD API 를 제공한다
- 3.2의 경우 mongo 셸도 이를 지원하는데, insertOne, insertMany 외 여러 방법을 포함한다

## 도큐먼트 삭제
- 데이터 삭제를 위해 deleteOne, deleteMany 를 제공한다
- 두 함수 모두 필터 도큐먼트를 첫 번째 매개변수로 사용한다
  - 도큐먼트 제거를 위한 일련의 기준

```shell
> db.movies.deleteOne( { "_id" : 4 })
```
- deleteOne 은 필터와 일치하는 첫 번째 도큐먼트를 제거한다
- 어떤 도큐먼트가 먼저 발견되는가 ?
  - 삽입 순서, 어떤 갱신이 이뤄졌는지, 어떤 인덱스를 사용하는지 등 몇 가지 요인에 따라 달라질 수 있음
- 몽고 3.0 이전에서는 remove 를 주로 사용했다
- 3.0 릴리즈와 동시에 deleteOne, deleteMany 등을 지원한다
- remove 는 호환성을 위해 계속 지원하지만 애플리케이션 개발시 deleteOne, deleteMany 를 사용하자

### drop
- deleteMany 를 사용해 컬렉션의 모든 도큐먼트를 제거 할 수 있다
- 하지만 전체 컬렉션을 제거한다면 drop 을 사용하는 것이 더 빠르다

```shell
> db.movies.drop()
```

> 데이터는 한 번 제거하면 영구 삭제된다. 백업 데이터를 복원하는 수 밖에 없다

## 도큐먼트 갱신
- 도큐먼트 저장 이후 updateOne, updateMany, replaceOne 과 같은 갱신 함수를 사용해 도큐먼트를 변경한다
- updateOne, updateMany 는 필터 도큐먼트를 첫 매개변수로, 변경 사항을 설명하는 수정자 도큐먼트를 두 번째 매개변수로 전달한다
- replaceOne 은 첫 인자는 동일하지만 두 번째 인자는 필터와 일치하는 도큐먼트를 **교체할 도큐먼트** 이다
- 갱신 작업은 **원자적** 으로 이뤄진다
- 요청이 두 개 발생한다면 서버에 먼저 도착한 요청이 적용된 이후 다음 요청이 적용된다

### 도큐먼트 치환
- replaceOne 은 도큐먼트를 완전히 새로운것으로 치호나한다
- 대대적인 스키마 마이그레이션에 유용하다
- 흔히 하는 실수로 조건 절에 2개 이상 도큐먼트가 일치하게 한후 중복된 _id 값을 갖는 도큐먼트를 생성하는 경우가 많다
  - 이는 오류를 반환하고 아무일도 일어나지 않는다
- 이런 일을 피하기 위해 고유한 값을 갱신 대상으로 삼는 것이 좋다
  - _id

### 갱신 연산자
- 도큐먼트의 특정 부분만 갱신하는 경우가 많다
- 부분 갱신에는 원자적 **갱신 연산자** 를 사용한다
  - 키를 변경, 추가, 제거하고 배열과 내장 도큐먼트를 조작하는 복잡한 갱신 연상르 지정하는데 사용하는 특수키

```shell
> db.analytics.updateOne( {"url" : "www.example.com"}, { "$inc" : {"pageViews": 1}})
```

### $set 제한자 사용
- $set 은 필드 값을 설정한다
  - 필드가 존재하지 않으면 새 필드가 생성된다
- 스키마 갱신 또는 사용자 정의 키 추가시 유용하다

```shell
> db.users.updateOne({ "_id" : ObjectId("fsdjfdkl123123")}, { "$set" : {"favorite Book" : "War And Peace"}})
```
- 이는 키의 데이터 형도 변경할 수 있다
- $unset 으로 키와 값을 모두 제거할 수 있다

```shell
> db.users.updateOne({ "_id" : ObjectId("fsdjfdkl123123")}, { "$unset" : {"favorite Book" : 1}})
```

> 키를 추가, 변경, 삭제 시에는 항상 $ 제한자를 사용해야 한다

### 증가와 감소
- $inc 연산자는 이미 존재하는 키의 값을 변경하거나 새 키를 생성하는데 사용한다
- 분석, 분위기, 투표 등과 같이 자주 변하는 수치 값 갱신시 매우 유용하다
- $inc 는 $set 과 비스하지만 숫자를 증감하기 위해 설계되었다
- int, long, double, decimal 타입 값에만 사용할 수 있다

### 배열 연산자
- 배열을 다루는데 갱신 연산자를 사용할 수 있다
- 리스트에 대한 인덱스 뿐 아닌 이중으로 쓸 수 있다

`요소 추가`
- $push 는 배열이 이미 존재하면 배열 끝에 요소를 추가하고 존재하지 않는다면 새로운 배열을 생성한다

```shell
> db.blog.posts.updateOne({"title" : "A Blog Post"}, {"$push" : { "comments": ....}})
```
- $push 를 포함한 일부 연산자에 제한자를 제공한다
- $push + $each 제한자를 사용하면 작업 한번으로 값을 여러 개 추가할 수 있다

```shell
> db.stock.ticker.updateOne({"_id" : "GOOG"}, {"$push" : {"hourly" : {"$each" : [562.776, 562.790, 559.123]}}})
```
- 배열을 특정 길이로 늘이려면 $slice 를 $push 와 결합해 사용해야 한다
  - 배열이 특정 크기 이상으로 늘어나지 않게 하고 효과적인 top N 목록을 만들 수 있다

```shell
> db.movies.updateOne({"genre" : "horror"}, {"$push" : {"top10": { "$each" : ["Nightmare on Elm Street", "Saw"], "$slice" : -10}}})
```
- 이는 배열에 추가가능한 요소 개수를 10개로 제한한다
- 추가 이후 배열의 요소 개수가 10보다 작은 모든 요소가 유지되고, 10보다 크면 마지막 10개 요소만 유지된다
- $slice 는 도큐먼트 내에 큐 생성시 상요할 수 있다

### 배열을 집합으로 사용
- 특정 값이 배열에 존재하지 않을 때 해당 값을 추가하면서, 배열을 집합처럼 쿼리하려면 쿼리 도큐먼트에 $ne 를 사용한다

```shell
> db.papers.updateOne({"authors cited": {"$ne" : "Richie"}}, {$push: {"authors citied" : "richie"}})
```
- $addToSet 을 사용할 수도 있다
  - $ne 가 동작하지 않거나 $addToSet 을 사용하면 무슨 일이 일어났는지 더 잘 알 수 있을때 유용하다
  - 고유한 값을 추가하려면 $addToSet 을 사용
- 고유한 값을 여러 개 추가하라면 $addToSet + $each 를 결합해 사용한다
- $ne + $push 로는 할 수 없는 작업이다

```shell
> db.users.updateOne({"_id" : ObjectId("daskdskj1234")}, {"$addToSet" : {"emails" : {"$each" : [...]}}})
```

### 요소 제거하기
- 배열에서 요소를 제거하는 방법을 여러 가지가 있다
- 큐나 스택처럼 사용한다면 양끝에서 요소를 제거하는 $pop 을 사용한다 {"$pop" : {"key": 1}} 은 배열의 마지막 부터 요소를 제거하며, -1 은 처음 부터 요소를 제거한다
- $pull 은 주어진 조건에 맞는 배열 요소를 제거한다
  - 모든 요소를 제거
  
```shell
> db.lists.insertOne({"todo" : ["dishes", ["laundry", "dry cleaning"]})
> db.lists.updateOne({}, {"$pull" : {"todo": "laundry"}})
```
- 배열 연산자는, 배열을 값으로 갖는 키에만 사용한다.
- 정수형에 데이터를 넣거나 문자열 형에서 데이터를 빼내는 작업은 할 수 없다.
- 스칼라 값을 변경하려면 $set or $inc 를 사용해야 한다

### 배열의 위치 기반 변경
- 배열 내 여러 값을 다루는 방법은 두 가지가 있다
- 위치를 이용하거나 위치 연산자 ($) 를 사용한다
- 배열 인덱스는 기준이 0 이며, 배열 요소는 인덱스를 도큐먼트의 키 처럼 사용한다

```shell
> db.blog.updateOne({"comments.author" : "John"}, {"$set": {"comments.$.author" : "Jim"}})
```
- 도큐먼트를 쿼리해서 검사해보지 않고는 배열의 몇 번째 요소를 변경할지 알 수 없다
- 이를 해결하기 위해 요소의 위치를 알아내 갱신하는 위치 연산자 ($) 를 제공한다
- 위치 연산자는 첫 번째로 일치하는 요소만 갱신한다

### 배열 필터를 이용한 갱신
- 몽고 3.6 에서는 개별 배열 요소를 갱신하는 배열 필터 (arrayFilters) 를 도입해 특정 조건에 맞는 배열 요소를 갱신할 수 있다

```shell
> db.blog.updateOne(
  {"post" : post_id},
  { $set: { "comments.$[elem].hidden" : true}},
  {
    "arrayFilters" : [{"elem.votes": {$lte: -5}}]
  }
)
```

### 갱신 입력
- 갱신 입력 (upsert) 은 특수한 형태를 갖는 갱신이다
- 갱신 조건에 맞는 도큐먼트가 존재하지 않을 때는 쿼리 도큐먼트와 갱신 도큐먼트를 합쳐 새로운 도큐먼트를 생성한다
- 조건에 맞는 도큐먼트가 발견되면 일반적인 갱신을 수행한다

### 저장 셸 보조자
- save 는 도큐먼트가 존재하지 않으면 도큐먼트를 삽입하고, 존재하면 도큐먼트를 갱싱하는 셸 함수이다
- 매개변수가 하나이며, 도큐먼트를 넘겨받는다.
- 도큐먼트가 _id 를 가지고 있다면 갱신 입력을, 포함하지 않는다면 삽입을 실행한다

### 다중 도큐먼트 갱신
- 조건에 맞는 도큐먼트를 모두 수정하려면 updateMany 를 사용한다
- updateOne 과 같은 의미론을 따르며, 동일한 매개변수를 취한다
- 스키마를 변경하거나 특정 사용자에 새로운 정보를 추가할 떄 쓰기 좋다

### 갱신한 도큐먼트 반환
- 일부 사례에서는 수정된 도큐먼트를 반환하는 것이 중요하다
- 몽고 DB 의 이전 버전에서는 findAndModify 를 사용했다
- 큐를 조작하거나 원자성을 필요로 하는 작ㅇ버에 유용하다.
- 하지만 이는 삭제, 대체, 갱신 이라는 세 가지 작업의 기능을 결합한 복잡한 함수이므로 사용자 오류가 발생하기 쉽다
- 3.2 버전에서는 findOneAndDelete, findOneAndReplace, findOneAndUpdate 를 도입했다
- 주요 차이점은 사용자가 수정된 도큐먼트 값을 원자적으로 얻을 수 있다.
- 4.2 버전은 갱신을 위한 집계 파이프라인을 수용하도록 이를 확장했다














# 10장 복제 셋 설정
- 복제 셋 정의
- 복제 셋을 설정하는 방법
- 복제 셋 멤버 구성 옵션

## 복제 소개
- 복제는 데이터의 동일 복사본을 여러 서버상에 보관하는 방법
- 실제 서비스 배포시 권장된다
- 몽고 DB 사용시 **복제 셋** 을 생성함으로 써 복제 설정이 가능하다
- 복제셋 => 프라이머리 서버 1대 와 세컨더리 서버 여러대로 이뤄진다

## 복제 셋 설정 - 1장
- 복제 셋 매커니즘 이해를 위해 단일 장비 3-노드 복제셋 설정 방법을 살펴봄
- 몽고 DB 의 고가용성 및 재해 복구를 처리하는 방법을 이해할 수 있다

```shell
mongod --replSet mdbDefGuid --dbpath ~/data/rs1 --port 27017 \
--oplogSize 200

mongod --replSet mdbDefGuid --dbpath ~/data/rs2 --port 27018 \
--oplogSize 200

mongod --replSet mdbDefGuid --dbpath ~/data/rs3 --port 27019 \
--oplogSize 200
```
- 위 명령으로 3개의 별도 mongod 프로세스가 실행되어야 함

## 네트워크 고려 사항
- 복제 셋의 모든 멤버는 같은 셋 내의 다른 멤버와 연결할 수 있어야 함
- 몽고 3.6 출시되면서 mongod 는 기본적으로 로컬호스트 에만 바인딩 된다
- 복제 셋 각 멤버가 다른 멤버와 통신하려면 다른 멤버가 연결할 수 있는 IP 에도 바인딩 해야 함

```shell
mongod --bind ip localhost,192.51.100.1 --replSet mdbDefGuide \
--dbpath ~/data/rs1 --port 27017 --oplogSize 200
```

## 보안 고려 사항
- localhost 외 다른 IP 에 바인딩하기 전 복제셋 구성시 권한 제어를 활성화 하고 인증 메커니즘을 짖어해야 한다
- 디스크 데이터를 암호화하고, 복제 셋 멤버간 통신 및 셋과 클라이언트 간 통신을 암호화하면 좋다

## 복제 셋 설정 - 2장
- 지금까지 작업으로는 각 mongod 프로세스가 다른 mongod 의 존재를 모른다
- 각 멤버를 나열하는 구성을 만들어 mongod 프로세스 중 하나로 보내면 멤버들은 서로의 존재를 알게 됨

```shell
mongo --port 27017

rsconf = {
  _id : "mdbDefGuide",
  members : [
    {_id : 0, host : "localhost:27017"},
    {_id : 1, host : "localhost:27018"},
    {_id : 2, host : "localhost:27019"}
  ]
}
rs.initiate(rsconf)
```
- mongodb 셸에서 구성 도큐먼트를 만들고 rs.initiate() 보조자에 전달해 복제셋을 시작한다
- 그 이후 3개 멤버가 있는 복제 셋 이 시작되며 구성을 나머지 mongod 에게 전파해 복제셋이 형성된다
- 복제 셋 구성 도큐먼트에는 중요한 부분이 있음
  - _id : 명령 행에 전달한 복제 셋의 이름
  - 이름이 정확히 일치하는지 확인하자
    - 셋 멤버의 배열
    - 각 멤버에는 2개의 필드 _id/host 가 있으며 _id 는 고유해야 한다
- 복제 시작이후 완전히 기능하는 복제 셋이 있어야 함
- 복제 셋을 **프라이머리를 선출** 해야 한다
- 복제 셋 상태 => rs.status() 로 확인 가능

`rs 보조자 함수`
- rs 는 복제 보조자 함수를 포함하는 전역 변수이다
- 거의 항상 데이터베이스 명령을 감싸는 래퍼 임
- 보조자 대신 명령 양식을 사용하는 것이 더 쉬울 때도 있으며 보조자와 기본 명령 둘다 익히는 것이 좋다

## 복제 관찰
- 복제 셋이 27017 을 프라이머리로 선출했다면, 복제 셋 시작 시 사용된 mongo 셸이 현재 프라이머리에 ㅇ녀결돼 있다

```shell
mdbDefGuide:PRIMARY> 
```
- 위와 같이 프롬프트가 변경되어야 한다
- `isMatser` 명령을 통해 어느 멤버가 프라이머리가 되었는지 확인할 수 있다
- 세컨더리는 프라이머리보다 뒤쳐지며 데이터가 최신이 아닐 수 있다
- 세컨더리는 애플리케잇녀이 실효 (stale) 데이터를 읽지 않도록 기본적으로 읽기 요청을 거부한다
- 세컨더리를 쿼리하려고 하면 프라이머리가 아니라는 오류가 표시된다
- 세컨더리에 대한 쿼리르 허용하려면 다음과 같은 플래그 설정이 필요하다

```shell
secondaryConn.setSlaveOk()
```
- slaveOk 는 데이터베이스가 아닌 연결 (secondaryConn) 에 설정됨
- 세컨더리에 쓰기 시도시 쓰기를 거부한다
- 세컨더리는 클라이언트가 아닌 복제를 통해 가져오는 쓰기만 수행한다
- 자동 장애 조치 => 프라이머리가 중단되면 세컨더리 중 하나가 자동으로 프라이머리로 선출된다
- 프라이머리 선출은 프라이머리의 중단을 가장 먼저 발견한 세컨더리가 선출된다

`핵심 개념`
- 클라이언트는 독립 실행형 서버에 보낼 수 있는 모든 작업을 프라이머리에 보낼 수 있음
  - 읽기 쓰기 명령 인덱스 구축 등
- 클라이언트는 세컨더리에 쓰기할 수 없다
- 기본적으로 클라이언트는 세컨더리에서 읽을 수 없다
  - 세컨더리 읽음 설정시 가능하다

## 복제 셋 구성 변경
- 복제 셋 구성은 언제든지 변경 가능하며, 멤버 추가/삭제변경이 가능하다

```shell
// 멤버 추가
rs.add("localhost:27020")
// 멤버 삭제
rs.remove("localhost:27017")
```
- rs.config 호출시 구성 확인이 가능하며, 구성 변경시 마다 version 값이 증가하게 된다

## 복제 셋 설계 방법
- 복제 셋 설계에 앞서 과반수 개념을 알아야 한다
- 프라이머리 선출시 멤버의 과반수 이상이 필요하고, 프라이머리는 과반수 이상이여야지만 프라이머리 자격을 유지할 수 있다
- 쓰기는 과반수 이상에 복제되면 안전하다

`복제 셋 멤버수에 따른 과반수의 예`

| 복제 셋 내 멤버의 수 | 복제 셋의 과반수 | 
| --- | --- |
| 1 | 1 |
| 2 | 2 |
| 3 | 2 |
| 4 | 3 |
| 5 | 3 |
| 6 | 4 |
| 7 | 4 |

과반수는 복제 셋 구성에 따라 산정되므로 얼마나 많은 멤버가 다운되거나 사용할 수 없는 상태인지는 중요하지 않다
- 복제셋 멤버가 다섯이고 그중 세개가 다운되었다고 가정하면 두 멤버는 살아 있다
- 두 멤버는 복제 셋의 과반수에 미치지 않으므로 프라이머리 선출이 불가능하다
- 둘 중 하나가 프라이머리라면, 두 멤버가 과반수에 미치지않는다는 것을 알고 프라이머리 자격을 내려놓게 된다
- 남은두 멤버로 왜 프라이머리 선출이 불가능한지 의문 ?
  - 다른 세 멤버가 완전히 다운되지 않았을 수 있음
  - 멤버가 아니라 네트워크가 단절됫을 수 있음
  - 다른 세 멤버는 과반수에 미치므로 프라이머리를 선출한다
  - 네트워크 파티션이 발생한 경우 양쪽에서 프라이머리를 선출하기 원하지 않는다
  - 복제 셋이 두개의 프라이머리를 갖게 됨
  - 프라이머리 선출시 과반수 이상을 요구하는 방식 => 스플릿 브레인 방지
- 프라이머리는 하나만 갖도록 셋을 구성하는 것이 중요하다
- 만약 멤버 1,2,3 이 하나의 데이터센터에 있고 나머지 4,5 가 다른 센터에 있다면 복제셋 과반수는 항상 첫 번째 데이터센터일 가능성이 높다
- 다음과 같은 일반적인 구성이 권장된다
  - 하나의 데이터센터에 복제 셋의 과반수가 있는 구성. 프라이머리 데이터센터가 있고 그 안에 복제셋 프라이머리를 위치시킬 때 적합한 설계
  - 프라이머리 데이터센터가 정사이라면 괜찮지만 데이터센터가 불능이라면 세컨더리에서는 새로운 프라이머리 선출이 불간으하다
  - 각 센터내 서버수가 동일하고, 또 다른 위치에 동점 상황을 판가름할 서버가 있는 경우. 일반적으로 양쪽 데이터 센터 내 서버에서 복제셋의 과반수를 확인할 수 있따
  - 두 데이터센터의 선호가 "동일" 할 때 적합하다
- 프라이머리가 하나 이상인 경우 복잡성을 수반하게 된다
- 쓰기 충돌 처리를 해야할 수도 있음
- 다중 쓰기를 지원하는 시스템에서 이를 처리하는 방법은 두가지이다
  - "수동 조정 방식"
  - "임의로 승자를 선택하는 방식"
- 두 방식 모두 개발자가 코드화하기 좋은 방식이 아니다
- 이미 쓴 데이터가 앞으로 변하지 않는다고 확신할 수 없기 때문이다
- 몽고 DB 는 오직 단일 프라이머리만 지원한다.

### 어떻게 선출하는가 
- 세컨더리가 프라이머리가 되지 못하면 다른 멤버에게 이를 알리고 프라이머리로 선출할 거을 요청한다
- 이를 받은 멤버는 다음과 같은 항목을 기반으로 검사를 수행한다
  - 요청받은 멤버가 프라이머리에 도달할 수 있는가 ?
  - 선출되고자 하는 멤버의 복제 데이터가 최신인가 ?
  - 대신 선출돼야 하는 우선순위가 더 높은 멤버는 없는가 ?
- 몽고 DB 는 버전 3.2 에서 복제 프로토콜 버전 1을 도입했다
  - RAFT 합의 프로토콜 기반
  - 아비터, 우선순위, 비투표 멤버, 쓰기 결과 확인 등 몽고 DB 특유 복제 개념을 포함한다
- 장애 조치 시간 단축 등 새로운 기능의 기반이 되며, 잘못된 프라이머리 상황을 감지하는데 걸리는 시간을 크게 줄인다
- 용어 ID 를 사용함으로 써 이중 투표를 방지한다
- 복제 셋 멤버는 2초마다 서로 하트비트 **핑** 을 보낸다
- 10초 내 멤버가 하트비트가 반환하지 않으면, 다른 멤버가 그 불량 멤버를 **접근할 수 없음** 으로 표시한다
- 선출 알고리즘은 우선순위가 가장 높은 세컨더리를 선출하도록 노력한다
- 멤버 우선순위 => 선출 시기와 결과에 영향을 미침
- 우선순위가 더 높은 세컨더리가 더 낮은 세컨더리보다 상대적으로 더 빨리 선출되며 이길 가능성도 더 높다
- 우선순위가 높은 세컨더리보다 낮은 세컨더리가 선출될수도 있음 .. 복제 멤버들은 우선순위가 가장 높은 멤버가 선출될때 까지 계속해서 선출을 호출한다
- 프라이머리로 선출되려면 복제데이터가 최신어야 한다

## 멤버 구성 옵션

### 우선 순위
- 우선순위 => 특정 멤버가 가지는 프라이머리 선출 우선순위
- 0 ~ 100 사이 값으로 지정 가능하며 기본값은 1
- 0으로 지정하면 절대 프라이머리가 될 수 없다
- 이를 **수동적 멤버** 라고 한다

### 숨겨진 멤버
- 클라이언트는 숨겨진 멤버에 요청을 라우팅하지 않으며, 숨겨진 멤버는 복제 소스로서 발마직하지 ㅇ낳다
- 많은 이들이 덜 강력한 서버 또는 백업 서버를 숨긴다

```shell
var config = rs.config()
config.members[2].hidden = true
config.members[2].priority = 0
rs.reconfig(config)
```
- 숨기기 위해서는 hidden : true 필드를 구성에 추가해야 한다
- 멤버가 숨겨지려면 우선순위가 0이어야 한다 (프라이머리는 숨길 수 없음)

### 아비터 선출
- 멤버가 2개인 복제 셋은 대부분의 요구 사항에서 명확한 단점이 있다
- 소규모로 배포하는 사람들은 데이터 복사본을 세 개나 보관하기를 거린다
- 이런 배포에 대해 몽고 DB 는 프라이머리 선출에 참여하는 용도로만 쓰이는 아비터 라는 특수한 멤버를 지원한다
- 이는 데이터를 가지지 않으며 클라이언트에 의해 사용되지 않는다
- 오로지 멤버2 복제 셋에서 과반수를 구성하는데 사용되며, 일반적으로는 아비터가 없는 배포가 바람직하다
- 아비터는 mongod 서버의 작도오가는 아무런 연관이 없으며 사양이 낮은 서버에서 경량화 프로세스로 실행할 수 있다
- `--replSet name` 옵션과 빈 데이터 디렉터리를 이용해 일반적으로 mongod 시작방식으로 아비터를 실행할 수 있음

```shell
// rs.addArb() 보조자로 아비터를 복제 셋에 추가할 수 있따
rs.addArb("server-5:27017")
// arbiterOnly 옵션 지정이 가능하다
rs.add({"_id" : 4, "host" : "server-5:27017", "arbiterOnly" : true})
```
- 아비터는 복제셋 추가이후 영원히 아비터 이다
- 아비터는 큰 클러스터상에서 동점 상황을 없앨 수 있다는 장점이 있다
- 하지만 아비터 사용시 주의할 점이 있다

`아비터는 최대 하나까지만 사용하라`
- 노드 개수가 홀수라면 아비터는 필요하지 않다
- "만약의 경우" 를 대비해 여분의 아비터를 추가해야한다고 오해한다
- 여분의 멤버가 있다면 선출 시간 또한 길어질 수 있으며, 아비터를 추가해서 노드 개수가 짝수가 되면 아비터는 동점 상황을 막는게 아닌 오히려 야기할 수 있다

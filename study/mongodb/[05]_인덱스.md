# 5장 인덱스

## 5.1 인덱싱 소개
- 데이터베이스 인덱스는 책의 인덱스와 유사하다
- 특정 내용을 가리키는 정렬된 리스트를 확인하기 때문에 더 빠르게 쿼리할 수 있다
- 인덱스를 사용하지 않는 쿼리 > **컬렉션 스캔 (collection scan)** 이라 한다
  - 서버가 쿼리 결과를 찾기위해 전체 컬렉션을 뒤져야 함
- explain 함수를 이용해 쿼리가 실행될 때 몽고 DB 가 무엇을 하는지 확인할 수 있다
- explain 명령을 감싸는 커서 보자자 메소드 와 사용하면 좋다
  - 다양한 CRUD 작업의 실행 정보를 제공함
- executionStats 모드는 인덱스를 이용한 쿼리의 효과를 이해하는데 도움이 된다

```shell
> db.test.find({ class: "A"}).explain("executionStats")
...
"executionStats" : {
  "executionSuccess" : true,
  "nReturned" : 10,
  "executionTimeMillis" : 0,
  "totalKeysExamined" : 0,
  "totalDocsExamined" : 20,
  "executionStages" : {
    "stage" : "COLLSCAN",
    "filter" : {
      "class" : {
        "$eq" : "A"
      }
    },
    "nReturned" : 10,
    "executionTimeMillisEstimate" : 0,
    "works" : 22,
    "advanced" : 10,
    "needTime" : 11,
    "needYield" : 0,
    "saveState" : 0,
    "restoreState" : 0,
    "isEOF" : 1,
    "direction" : "forward",
    "docsExamined" : 20
  }
}
```
- totalDocsExamined : 참조된 document 수
- executionStages : 쿼리 수행 상세 정보
- executionStages 에는 여러 단계에 나눠 진행되는 쿼리의 상세 정보가 나와있다
- `stage` 필드를 통해 어떤 작업을 했는지 알 수 있다
  - COLLSCAN : 전체 스캔
  - IXSCAN : 인덱스 스캔
- 위 플랜을 살펴보면 전체 20개의 docs 중 class:'A' 를 찾기 위해 totalDocsExamined:'20' 20개 모두를 탐색했다는 것을 알 수 있다
- `nReturned` 필드는 반환받은 결과의 개수를 나타낸다
- 몽고 DB 가 쿼리에 효율적으로 응답하게 하려면 애플리케이션의 모든 쿼리 패턴에 인덱스를 사용해야 한다
  - 쿼리 패턴 : 단순히 애플리케이션이 데이터베이스에 요구하는 다양한 유형의 질문을 의미
- 많은 애플리케이션에서 단일 인덱스가 여러 쿼리 패턴을 지원한다

### 인덱스 생성
- 인덱스를 생성하려면 createIndex 메소드를 사용한다

```shell
db.users.createIndex({"class" : 1})
{
  "createdCollectionAutomatically" : false,
  "numIndexesBefore" : 1,
  "numIndexesAfter" : 2,
  "ok" : 1
}
```
- 컬렉션의 크기가 크지않는 한 인덱스를 생성하는데는 몇초면 충분하다
- db.currentOp() or mongod 로그를 확인해 인덱스 구축의 진행률을 체크할 수 있다
- 인덱스 생성 이후 다시 쿼리 플랜을 살펴보자

```shell
> db.test.find({ class: "A"}).explain("executionStats")
...
"executionStats" : {
  "executionSuccess" : true,
  "nReturned" : 10,
  "executionTimeMillis" : 0,
  "totalKeysExamined" : 10,
  "totalDocsExamined" : 10,
  "executionStages" : {
    "stage" : "FETCH",
    "nReturned" : 10,
    "docsExamined" : 10,
    "inputStage" : {
      "stage" : "IXSCAN",
      "nReturned" : 10,
      "indexName" : "class_1"
    }
  }
}
```
- 더 많은 정보들이 추가되었지만 차이점만 살펴보자
- stage: "IXSCAN" 으로 인덱스 스캔을 했다
- "indexName" : "class_1" = 방금 생성된 "class_1" 이라는 인덱스 명을 사용했다. 
- 전체 doc 참조 개수는 "totalDocsExamined" : 10 으로 필요한 doc 를 참조했음을 확인할 수 있다
- 보다싶이 인덱스는 쿼리시간에 놀랑누 차이를 만든다.
- 단점 = 인덱싱된 필드는 변경하는 작업은 더 오래 걸린다.
  - 데이터 변경시 마다 도큐먼트 뿐 아닌 모든 인덱스를 갱신해야 하기 때문이다

### 복합 인덱스
- 인덱스는 가능한 효율적으로 쿼리하려는 목적으로 사용한다
- 상당수의 쿼리 패턴은 두 개 이상의 키를 기반으로 인덱스를 작성해야 한다
- 인덱스는 모든 값을 정렬된 순서로 보관하기 때문에 인덱스 키로 도큐먼트를 정렬하는 작업이 훨씬 빨라지게 한다
  - 인덱스가 앞부분에 있을때문 유효함

```shell
db.users.find().sort({"age" : 1, "username" : 1}) // username 인덱스는 이와 같은 정렬쿼리에는 도움이 되지 않는다
db.users.createIndex({"age": 1, "username" : 1}) // 정렬 최적화를 위해 age, username 를 생성
```
- 위와 같은 인덱스를 복합 인덱스라 한다
- 쿼리에서 정렬 방향이 여러 개 이거나 검색 조건에 여러 키가 있는때 유용하다
- 복합 인덱스는 2개 이상의 필드로 구성된 인덱스이다

```shell
{ "username" : "user0", "age" : 1}
{ "username" : "user1", "age" : 2}
{ "username" : "user2", "age" : 3}
{ "username" : "user3", "age" : 4}
{ "username" : "user4", "age" : 5}
{ "username" : "user5", "age" : 6}
{ "username" : "user6", "age" : 7}
{ "username" : "user7", "age" : 8}
// ...
```
- 위와 같은 컬렉션이 있다고 가정하고, {"age" : 1, "username" : 1} 로 인덱스를 만들면 다음과 같은 형태로 표현된다

```shell
[0, "user10020"] -> 8623423414
[0, "user1002"] -> 8593912039123
[0, "user100388"] -> 85325823908
```
- 각 인덱스 항목은 나이와 사용자 명을 포함하고 레코드 식별자를 가리킨다.
- 레코드 식별자는 내부에서 스토리지 엔진에 의해 사용되며 도큐먼트 데이터를 찾는다
- 몽고 DB 가 실행되는 쿼리 종류에 따라 인덱스 사용방법이 다르다

`db.users.find({"age": 21}).sort({"usenname" : -1})`
- 단일 값을 찾는 동등 쿼리이다
- 결과값으로 여러 도큐먼트가 있을 수 있다
- 인덱스 두 번째 필드로 인해 결과는 이미 적절한 순서로 정렬된다
- "age" : 21 과 일치하는 마지막 항목부터 순서대로 인덱스를 탐색한다
- 이런 쿼리는 매우 효율적이다

`db.users.find({"age" : {"$gte" : 21, "$lte" : 30}})`
- 범위 쿼리이며 여러 값이 일치하는 도큐먼트를 찾는다
- 인덱스의 첫 번째 키인 age 를 사용해 일치하는 도큐먼트를 반환 받는다

`db.users.find({"age" : {"$gte" : 21, "$lte" : 30}}).sort({"username" : 1})`
- 다중값 쿼리 지만 이번에는 정렬을 포함한다
- 검색 조건에 맞는 인덱스를 사용한다
- 하지만 사용자 명을 정렬된 순서로 반환하지 않으며, 쿼리는 사용자명에 따라 정렬된 결과를 원한다
- 이는 결과 반환 전 메모리에서 정렬해야 함을 의미한다
- 일반적으로 이전 쿼리보다 비효율 적이다
- 결과가 32메가 이상이라면 데이터가 너무 많아 정렬 거부 에러를 내보낸다

### 몽고 DB 가 인덱스를 선택하는 방법
- 쿼리가 들어오면 몽고 DB 는 **쿼리 모양 (query shape)** 을 확인한다
- 이는 검색할 필드와 정렬 여부 등 추가 정보와 관련 있다
- 이 정보를 기반으로 쿼리를 충족하는데 사용할 인덱스 후보 집합을 식별한다
- 인덱스 5개중 3개가 쿼리 후보로 식별됬다면, 각 인덱스 후보에 하나씩 총 3개의 쿼리 플랜을 만든다
- 그후 각각 다른 인덱스를 사용하는 3개의 병렬 스레드에서 쿼리를 실행한다
  - 가장 빠른 결과를 반환하는 인덱스를 확인하기 위함
- 가장 먼저 목표 상태에 도달하는 쿼리 플랜이 선정 된다

![query plan](./images/mongodb_query_plan.png)
- 쿼리 스레드가 레이스에서 이기려면 모든 쿼리 결과를 가장 먼저 반환 or 결과에 대한 시범 횟수를 정렬 순서로 가장 먼저 반환해야 한다
  - 인메모리 정렬을 비하면 비용이 많이 들기때문에 정렬 순서는 중요한 부분이다
- 서버는 쿼리 플랜의 캐시를 유지하며, 컬렉션 or 인덱스가 변경되면 캐시에서 제거되고 다시 가능한 쿼리 플랜을 실험해 적합한 플랜을 찾는다
- 인덱스 추가/삭제시 캐시엣 되며, 명시적으로 지우거나 mongod 프로세스를 재시작할때 도 삭제된다

### 복합 인덱스 사용
- 복합 인덱스는 단일 키 인덱스보다 복잡하지만 매우 강력하다
- 인덱스를 올바르게 설계하려면 실제 워크로드에서 인덱스를 테스트하고 조정해야하지만, 몇 가지 모범 사례를 적용할 수 있다.
- 모든 상황은 아니지만 대부분의 상황에 적용되므로 복합 인덱스 구성시 가장 먼저 고려하자.
  - 동등 필터에 대한 키를 맨 앞에 표시
  - 정렬에 사용되는 키는 다중값 필드 앞에 표시
  - 다중값 필터에 대한 키는 마지막에 표시

### 키 방향 선택하기
- 두 개 이상의 검색조건으로 정렬할 때는 인덱스 키의 방향이 서로 달라야 한다
- users 컬렉션 예시로 나이가 적은 사용자 부터 많은 사용자순, 사용자 명은 Z-A 로 정렬한다고 하면 
- 복합 정렬을 {"age" : 1, "username" : -1 } 같이 인덱스를 생성해 최적화 해야한다
- 애플리케이션이 {"age" : 1, "username" : 1} 을 이용해 정렬을 최적화 해야한다면 해당 방향으로 두 번째 인덱스를 생성한다
- 역방향 인덱스는 서로 동듬함을 알아 두자
  - {"age" : 1, "username" : -1 } == {"age" : -1, "username" : 1 }
- 인덱스의 방향은 다중 조건에 따라 정렬할 때만 문제가 되며, 단일 키로 정렬하면 인덱스를 쉽게 역순으로 읽을 수 있다
  - {"age": 1} 인덱스로 {"age" : -1} 정렬을 최적화 할 수 있다
- 다중 키로 정렬시에만 문제가 된다.

### 커버드 쿼리 사용하기
- 쿼리가 단지 인덱스에 포함된 필드를 찾는 중이라면, 도큐먼트를 가져올 필요가 없다
- 인덱스가 쿼리가 요구하는 값을 모두 포함하는 경우 **쿼리가 커버드 된다** 고 한다.
- 실무에서는 도큐먼트로 돌아가지 말고 항상 커버드 쿼리를 사용하자
- 이 방법으로 작업 셋을 훨씬 작게 만들 수 있다
- 커버드 쿼리에 explain 을 실행하면 결과에 FETCH 단계의 하위 단계가 아닌 IXSCAN 단계가 있고
- executionStats 에서 totalDocsExamined 의 값이 0이 된다

### 암시적 인덱스
- 복합 인덱슨느 "이중 임무" 를 수행할 수 있으며 쿼리마다 다른 인덱스철머 동작할 수 있다
- {"age" 1, "username" : 1} 인덱스를 가지면 "age" 필드는 {"age" : 1} 만 인덱스를 가질 때와 동일한 방법으로 정렬 된다
- 인덱스가 N 개의 키를 가진다면 키의 앞부분은 공짜 인덱스가 된다
  - {"a": 1, "b": 1, "c" : 1, "d": 1 ...} 인덱스가 있다면..
  - {"a" : 1}
  - {"a" : 1, "b" : 1}
  - {"a" : 1, "b" : 1, "c" : 1} 등으로 인덱스를 가진다
- 인덱스의 접두사를 이용하는 쿼리에만 적용할 수 있음을 기억해야 한다.
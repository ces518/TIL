# 4장 쿼리
- $ 조건절을 이용해 범위 쿼리, 셋의 포함 관계, 부등 관계 쿼리 등을 수행한다
- 쿼리는 필요시 도큐먼트 배치를 반환하는 데이터베이스 커서를 반환한다
- 커서를 이용해 결과를 일부 스킵하거나 반환하는 수를 제한, 결과를 정렬하는 등 다양한 메타 연산을 수행한다

## 4.1 find 소개
- 몽고 DB 의 find 함수는 쿼리에 사용한다
- find 함수의 첫 매개 변수에 따라 어떤 도큐먼트를 가져올 지 결정된다
  - 빈 쿼리 도큐먼트는 컬렉션 내 모든 것과 일치
  - 매개변수에 쿼리 도큐먼트가 없다면 빈 쿼리 도큐먼트로 인식

```shell
> db.c.find()
> db.users.find({"age" : 27}) // age = 27 인 모든 도큐먼트
> db.users.find({"username" : "joe"}) // username = joe 인 도큐먼트
> db.users.find({"username" : "joe", "age" : 27}) = username = joe and age = 27 인 도큐먼트
```

### 반환 받을 필드 지정
- 도큐먼트의 모든 필드 (키/값) 이 필요하지 않을 수 있음
- 두번 째 매개변수에 원하는 필드를 지정하면 된다
- 이는 네트워크 데이터 전송량 / 클라이언트에서 도큐먼트를 디코딩하는데 시간과 메모리를 줄여준다.

```shell
> db.users.find({}, {"username" : 1, "email" : 1}) // username, email 필드만 조회하기
> db.users.find({}, {"fatal_weakness": 0}) // fatal_weakness 필드를 제외하고 조회하기
```
- _id 필드는 지정하지 않아도 "항상" 반환된다
- 두 번째 매개변수를 사용해 특정 필드를 제외한 결과를 얻을 수도 있다

### 제약사항
- 데이터베이스에서 쿼리 도큐먼트 값은 반드시 상수 여야만 한다
- 도큐먼트 내에 다른 키 값을 참조할 수 없다

## 쿼리 조건
- 완전 일치 (exact match) 외에도 범위, OR 절, 부정 조건 (negation) 등 더 복잡한 조건으로 검색할 수 있다.

### 쿼리 조건절
- <, <=, >, >= 에 해당하는 비교 연산자는 각각 $lt, $lte, $gt, $gte 다.

```shell
> db.users.find({"age" : {"$gte" : 18, "lte" : 30}}) // 30 >= age >= 18 인 사용자 찾기 
> db.users.find({"username" : {"$ne" : "joe"}}) // username != joe 인 사용자 찾기
```

### OR 쿼리
- 몽고 DB 에서 OR 쿼리 는 두 가지 방법이 있다.
  - $in = 하나의 키를 여러 값과 비교
  - $or = 더 일반적이며, 여러 키를 주어진 값과 비교
- 하나의 키에 일치시킬 값이 여러 개라면 $in 에 조건 배열을 사용한다

```shell
> db.raffle.find({"ticket_no" : {"$in" : [725, 542, 390]}})
```
- 조건의 배열에 값이 하나만 주어지면 바로 일치하는 것을 찾는다.
- $nin 은 $in 과 반대이다
- $in 은 하나의 키에 대해 OR 쿼리를 한다

```shell
> db.raffle.find({"$or" : [{"ticket_no" : 725}, {"winner": true}]})
```
- $or 는 다른 조건절도 포함할 수 있다
- 일반적인 AND 쿼리에서는 최소한의 인수로 최적의 결과 (범위를 좁힌 결과) 를 추려야 한다. 
- OR 쿼리는 반대이다. 첫 번째 인수가 일치하는 도큐먼트가 많을수록 효율적이다
- $or 연산자가 항상 동작하는 동안에는 가능한 한 $in 을 사용하자

### $not
- $not 은 메타 조건절이며, 어떤 조건에도 적용할 수 있다

```shell
> db.users.find({"id_num" : {"$not" : {"$mod" : [5, 1]}}})
```

## 형 특정 쿼리
- 도큐먼트 내에서 다양한 데이터형을 사용할 수 있다
- 일부 데이터형은 쿼리 시에 형에 특정하게 작동한다

### null
- null 은 스스로와 일치하는 것을 찾는다
- null 은 존재하지 않음과도 일치한다.
- 키가 null 인 값을 쿼리하면, 해당 키를 갖지 않는 도큐먼트도 반환하게 된다
- 값이 null 인 키만 찾고 싶다면 null 인 값을 쿼리하고, $exists 조건절을 이용해 null 존재 여부를 확인해야 한다

```shell
> db.c.find({"z" : {"$eq" : null, "$exists" : true}})
```

### 정규 표현식
- $regex 는 쿼리에서 패턴 일치 문자열을 이용한 정규식 기능을 제공한다

```shell
> db.users.find({"name" : {"$regex" : /joe/i}})
```
- 몽고 DB 는 정규 표현식 일치에 펄 호환 정규 표현식 (PCRE) 라이브러리를 사용하며 여기서 사용가능한 모든 문법을 사용할 수 있다
- 쿼리하기 전, 자바스크립트 셸로 해당 정규표현식이 의도한대로 동작하는지 확인하는 것이 좋다
- 접두사 정규표현식 쿼리 에는 인덱스를 활용할 수 있다.

### 배열에 쿼리하기
- 배열 요소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계 됬다

```shell
> db.food.insertOne({"fruit": ["apple", "banana", "peach"]})
> db.food.find({"fruit" : "banana"})
```

### $all 연산자
- 2개 이상의 배열 요소가 일치하는 배열을 찾으려면 $all 을 사용한다.
- 배열 내 여러 요소와 일치하는지 확인하게 해준다

```shell
> db.food.find({"fruit" : {"$all" : ["apple", "banana"]}})
```
- 배열 요소가 하나 인 경우에는 $all 연산자를 사용하지 않은 것과 결과가 같다

### $size 연산자
- $size 는 특정 크기의 배열을 쿼리하는 유용한 조건절이다

```shell
> db.food.find({"fruit" : {"$size" : 3}})
```
- 이는 자주 사용되는 쿼리로, 크기의 범위로 쿼리할 수 있다
- $size 는 다른 조건절과 결합해 사용할 수 없지만, 도큐먼트에 size 필드를 추가하면 이를 처리할 수 있다.

### $slice 연산자
- find 의 두 번째 매개변수에는 반환받을 특정 키를 지정한다.
- $slice 연산자를 사용해 배열 요소의 부분집합을 반환받을 수 있다

```shell
db.blog.posts.findOne(criteria, {"comments" : {"$slice" : 10}}) // 먼저 달린 댓글 10개 반환 받기
db.blog.posts.findOne(criteria, {"comments" : {"$slice" : [23, 10]}}) // offset 과 요소 개수를 지정해 반환 받기
```

### 일치하는 배열 요소 반환
- 배열 요소의 인덱스를 알고 있다면 $slice 연산자는 유용하다
- 특정 기준과 일치하는 배열 요소를 찾으려면 $ 연산자를 이용할 수 있다

```shell
> db.posts.find({"comments.name" : "bob"}, {"comments.$" : 1}) // 댓글 작성자가 bob 인 요소 반환
```
- 각 도큐먼트에서 첫 번째로 일치하는 댓글만 반환하게 된다
- bob 이 여러 댓글을 남기면 comments 의 첫 번째 댓글만 반환된다

### 배열 및 범위 쿼리의 상호작용
- 일반적으로 배열을 포함하는 도큐먼트에 범위 쿼리를 할 떄 min/max 함수를 사용하면 좋다.
- 배열에 대한 $gt/$lt 의 인덱스 한계 (index bound) 는 비효율적이다
- 어떤 값이든 허용하므로 범위 내 값뿐 아니라 모든 인덱스 항목을 검색한다

### 내장 도큐먼트에 쿼리하기
- 내장 도큐먼트 쿼리는 도큐먼트 전체를 대상으로 하는 방식, 도큐먼트 내 키/값 쌍을 대상으로 하는 방식으로 나뉜다
- 전체 도큐먼트를 대상으로 하는 쿼리는 일반적인 쿼리와 동일하게 작동한다.
- 서브 도큐먼트 전체에 쿼리하려면, 서브 도큐먼트와 정확히 일치해야 한다
- 내장 도큐먼트에 쿼리할 때 가능하면, 특정 키로 쿼리하는 것이 좋다
- 도큐먼트 전체를 대상으로 일치하는 쿼리가 아니기 때문에 스키마가 변경되어도 쿼리가 정상적으로 동작한다

```shell
> db.people.find({"name.first" : "Joe", "name.last" : "Schmoe"})
```
- 쿼리 도큐먼트는 점을 포함할 수 있고, 이는 내장 도큐먼트에 항목에 접근할 수 있다는 의미이다.
- 점 표기법은 입력하는 도큐먼트에 . 문자를 사용할수 없는 이유이기도 하다.

## $where 쿼리
- $where 절을 사용해 임의의 자바스크립트를 쿼리의 일부분으로 실행하면 거의 모든 쿼리를 표현할 수 있다
- $where 절은 도큐먼트 내 두 키의 값을 비교하는 쿼리에 가장 자주 쓰인다

```shell
> db.foo.insertOne({"apple": 1, "banana", 6, "peach": 3})
> db.foo.insertOne({"apple": 8, "spinach", 4, "watermelon": 4})
> db.food.find({"$where" : function() {
  // ...
}})
```
- $where 쿼리는 일반 쿼리보다 훨씬 느리니 반드시 필요한 경우가 아니면 사용하지 말자.
- $where 절 실행 시 각 도큐먼트는 BSON 에서 자바스크립트 객체로 변환되기 때문에 오래 걸린다.
- $where 절에는 인덱스를 사용할 수 없기 때문에 별다른 방법으로 쿼리할 수 없을 때 사용해야 한다
- 다른 쿼리 필터와 함께 사용하면 성능 저하를 줄일 수 있다
- 가능ㅎ나 $where 절이 아닌 조건은 인덱스로 거르고, $where 절은 결과를 세부적으로 조정할 때 사용하자
- $expr 을 사용하면 자바스크립트 실행을 하지 않아 더 빨리 쿼리할 수 있으므로 $expr 을 사용하자

## 4.5 커서
- 데이터베이스는 커서를 사용해 find 의 결과를 반환한다
- 일반적으로 클라이언트 측의 커서 구현체는 최종 결과를 강력하게 제어하게 해 준다
  - 결과 개수 제한, 결과 스킵 등..
- 셸에서 커서를 생성하려면 컬렉션에 도큐먼트를 집어넣고 쿼리한 후 결과를 지역 변수에 할당한다.

```shell
> for(i = 0; i < 100; i++) {
  db.collection.insertOne({x : i});
}
> var cursor = db.collection.find();
```
- 결과를 한 번에 하나씩 볼 수 있다는 장점이 있다.
- 이 방법은 컬렉션 내에 무엇이 있는지 보는데 사용하며, 셸에서 실제 프로그래밍을 하는 데는 적합하지 않다
- 결과를 얻으려면 커서의 next() 를 사용하고, 다른 결과가 있는지 확인해야 한다.

```shell
> while(cursor.hasNext()) {
  obj = cursor.next();
  //...
}
```
- 셸은 next / hasNext 메소드 호출시 서버 왕복 횟수를 줄이기 위해 한 번에 처음 100개 또는 4메카 바이트의 크기 결과를 가져온다.
- 첫 번째 결과 셋을 살펴본 후 셸이 데이터베이스에 다시 접근해 더 많은 결과를 요청한다.

### 제한, 건너뛰기, 정렬
- 가장 일반적인 옵션으로 받환 결과 개수를 제한 / 건너뛸 수 있다.

```shell
> db.c.find().limit(3) // 결과를 3으로 제한
> db.c.find().skip() // 결과 3개를 스킵
> db.c.find.sort({"username": 1, "age": -1}) // username 오름차순, age 내림차순 정렬
```

### 비교 순서
- 몽고 DB 에는 데이터형을 비교하는 위계 구조가 있다
- 데이터형이 섞여있는 키는 미리 정의된 순서에 따라 정렬한다
1. 최솟값
2. null
3. 숫자
4. 문자열
5. 객체/도큐먼트
6. 배열
7. 이진 데이터
8. 객체 ID
9. 불리언
10. 날짜
11. 타임스탬프
12. 정규 표현식
13. 최댓값

### 많은 수의 건너뛰기 피하기
- 도큐먼트 수가 적다면 skip 을 사용해도 무리가 없다
- 하지만 skip 은 생략된 결과물을 모두 찾아 폐기하므로 결과가 많으면 느려진다
- 대부분의 데이터베이스는 skip 을 위해 인덱스 안에 메타데이터를 저장하지만, 몽고 DB 는 아직 기능을 지원하지 않는다
- 때문에 많은 수의 skip 은 피해야 한다

### skip 을 사용하지 않고 페이지 나누기
- limit 을 사용해 첫 페이지를 반호나하고, 다음 페이지부터 오프셋을 주면 가장 쉽게 페이징을 할 수 있다
- 쿼리에 따라 skip 을 사용하지 않을 수 있다

```shell
var page1 = db.foo.find().sort({"date" : -1}).limit(100)
var latest = null;

while (page1.hasNext()) {
  latest = page1.next();
  display(latest);
}
```

### 랜덤으로 도큐먼트 찾기
- 컬렉션에서 랜덤으로 도큐먼트를 가져오는 방법은 자주 문제가 된다
- 단순하고 느린 방법 = 도큐먼트 개수를 세고 find 를 실행한 후 0 과 컬렉션 크기 사이의 수를 랜덤으로 뽑아 그 개수만큼 건너뛴다

```shell
var total = db.foo.count()
var random = Math.floor(Math.random()*total)
db.foo.find().skip(random).limit(1) 
```
- 이는 매우 비효율적이다
- 전체 도큐먼트를 세어야 하는 등..
- 보다 효율적인 방법은 도큐먼트 저장시 랜덤 키를 별도로 추가해 이를 쿼리 조건으로 사용한다

### 종료되지 않는 커서
- 커서는 두 가지 측면이 있다
  - 클라이언트가 보는 커서와 클라이언트 커서가 나타내는 데이터베이스 커서
- 서버측에서 커서는 메모리와 리소스를 점유한다
- 커서가 가져올 결과가 없거나 클라이언트가 종료요청을 하면 데이터베이스는 점유하고 있던 리소스를 해제한다
- 서버 커서를 종료하는 조건
  - 커서는 일치하는 조건에 일치하는 결과를 모두 찾은 후 스스로 정리
  - 커서가 클라이언트측에서 유효 영역을 벗어나면 드라이버는 데이터베이스에 메세지를 보내 커서 종료신호를 보낸다
  - 사용자가 결과를 다 보지않았고 커서도 유효하지만 10분동안 활동이 없다면 데이터베이스 커서는 자동으로 죽는다
  - 때문에 열린 커서가 수천개가 될 일은 없다
- 커서를 오랫동안 남기고 싶다면 사용할 수 있는 immortal 함수를 제공한다

# 11장 복제 셋 구성 요소
- 복제 셋 멤버가 새로운 데이터를 복제하는 방법
- 새로운 멤버를 영입하는 방법
- 선출이 작동하는 방법
- 발생할 수 있는 서버 및 네트워크 오류 시나리오

## 동기화
- 몽고 DB 의 복제 => 프라이머리가 수행한 쓰기를 모두 포함하는 oplog 를 보관함으로써 복제를 수행한다
  - oplog 는 프라이머리의 로컬 데이터베이스에 있는 제한 컬렉션
  - 세컨더리는 이 컬렉션에 복제를 위한 연산을 쿼리한다
- 세컨더리는 프라이머리로 부터 복제한 작업을 기록하는 oplog 를 보관하고, 어떤 멤버든지 다른 멤버에 대한 동기화 소스로 사용되도록 한다
  - 동기화하려는 멤버로부터 연산을 가져와 데이터셋에 적용한 뒤 oplog 에 씀
  - 연산 적용에 실패하면 세컨더리는 종료됨
- 세컨더리가 다운되면, 재시작시 oplog 에 있는 마지막 연산과 동기화 한다
- oplog 의 각 작업은 **멱등** 이다
- 일반적으로 oplog 는 기본크기면 충분하다
  - oplog 의 크기 => 고정되어 있어 담을 수 있는 연산의 수가 정해져 있음
  - oplog 는 쓰기 연산이 시스템에 적용될 때와 비슷하게 공간을 차지함
  - 하지만 삭제나 다중 갱신처럼 여러 도큐먼트에 영향을 미치는 경우에는 여러 개의 oplog 항목으로 분해된다
- 다음은 oplog 크기가 기본 크기보다 커야 할 수도 있는 워크로드의 종류이다

`한 번에 여러 도큐먼트 갱신`
- oplog 는 멱등성을 유지하기 위해 다중갱신을 개별 작업으로 변환해야 한다
- 이때 oplog 는 공간을 많이 차지할 수 있으며, 데이터 크기나 디스크 사용은 이에 상응해 증가하지 않는다

`삽입한 데이터와 동일한 양의 데이터 삭제`
- 삽입한 데이터와 거의 같은 양의 데이터를 삭제하면, oplog 크기는 상당히 클 수 있음

`상당한 수의 내부 갱신`
- 워크로드 상단 부분이 도큐먼트 크기를 증가시키지 않는 갱신이라면, 데이터베이스가 기록하는 작업의 수는 많지만 디스크상 데이터 양은 변하지 않음

### 몽고 DB 의 데이터 동기화
- 몽고 DB 의 데이터 동기화는 두 가지 형태이다
  1. 전체 데이터셋으로 새 멤버를 채우는 초기 동기화
  2. 전체 데이터셋에 지속적인 변경 사항을 적용하는 복제

### 초기 동기화
- 초기 동기화 => 복제 셋의 한 멤버에서 다른 멤버로 모든 데이터를 복사
  - 복제 셋 멤버는 동기화 시작시 다른 멤버와 동기화를 시작하기에 유효한 상태인지를 먼저 확인함
  - 프로세스는 여러 단계에 걸쳐 진행되며 mongod 로그에서 확인 가능
- 몽고 DB 는 local 데이터베이스를 제외한 모든 데이터베이스를 복제한다
- 데이터베이스 내 컬렉션을 모두 스캔하고, 모든 데이터를 대상 멤버에 있는 자체 컬렉션 복사본에 삽입한다
- 대상 멤버의 기존 데이터는 복제 작업을 시작하기 전 삭제됨

> mongod 는 데이터를 모두 삭제하는 작업을 먼저 수행하기 떄문에, 해당 데이터 디렉터리에 있는 데이터가 필요없거나 백업 이후 수행해야만 함

- 몽고 3.4 버전 이후에서는 각 컬렉션에서 도큐먼트를 복사할 때 모든 컬렉션 인덱스를 구축한다
  - 이전 버전에서는 _id 인덱스만 구축함
- 데이터 복사중 추가된 oplog 를 가져오기 때문에 데이터 복사 단계에서 충분한 디스크공간이 있는지 확인해야 한다
- 모든 데이터베이스 복제 이후 oplog 를 사용해 복제 셋의 현재 상태를 반영하도록 데이터 셋을 갱신하고, 모든 변경 사항을 적용한다
- 초기 동기화는 운영자 관점에서는 쉬운 작업이다
- 하지만 23장에서 살펴볼 잭업으로 부터 복원하는 방식이 더 바람직 하다
- 백업으로부터 복원한다면 mongod 를 통해 모든 데이터를 복사할 때보다 빠를 때가 많다
- 복제는 동기화 소스의 작업 셋을 망칠 수 있다
- 초기 동기화를 수행하면 해당 멤버는 자주 사용되는 데이터를 추출해 메모리로 페이징하게 되며 이는 멤버가 급격하게 느려지게 만든다
- 이 문제를 해결하려면 덜 바쁜 시간에 초기 동기화를 시도하거나 백업으로 부터 복원하는 방법을 사용해야 한다
- 멤버가 동기화 소스의 oplog 보다 뒤쳐진다면 초기 동기화를 진행할 수 없다

### 복제
- 몽고 DB 가 수행하는 두 번째 동기화 유행
- 세컨더리 멤버는 초기 동기화 이후 지속적으로 데이터를 복제한다
- 동기화 소스에서 oplog 를 복사한 후 이런 작업을 비동기 프로세스에 적용한다
- 세컨더리는 핑 시간 및 다른 멤버의 복제 상태 변경에 따라, 필요에 따라 동기화 소스를 자동으로 변경할 수 있다
- 특정 노드가 어떤 멤버를 동기화할 수 잇는지 제어하는데는 몇 가지 규칙이 있ㅇ다
  - 투표수가 1인 복제 셋 멤버는 투표수가 0인 멤버와 동기화 불가
  - 세컨더리 멤버는 지연된 멤버나 숨겨진 멤버와 동기화 불가

### 실효 처리
- 세컨더리는 동기화 소스상 수행된 실제 연산들보다 훨씬 밀린다면 곧 실효 상태가 된다
- 실효 세컨더리가 소스의 모든 연산을 따라 잡는것은 불가능 하다
- 동기화를 계속 진행할 경우 일부 작업을 건너 뛰게 됨
- 이는 세컨더리가 다운타임 or 쓰기가 처리량을 뛰어넘음 or 읽기 작업에 밀린 경우 발생하게 됨
- 실효상태가 되면 복제 셋의 각 멤버로부터 차례로 복제를 시도해 독자적으로 이행가능한 긴 oplog 를 가진 멤버를 확인한다
- 이를 발견 못한다면 해당 멤버에서 복제가 중단되고 완전히 재동기화 되어야 한다
- 이런 상황을 피하려면, 프라이머리가 많은 양의 연산 이력을 보관하도록 큰 oplog 를 가져야 함
- 더 많은 디스크 공간을 사용하지만 충분히 감수할만 하다
- 일반적으로 2~3일 분량의 정상적인 연산에 대해 복제 기간을 제공할 수 있어야 한다

## 하트비트
- 하트비트 요청 => 모두의 상태를 점검하는 짧은 메세지
- 다른 멤버의 상태 정보를 알기 위해 복제셋의 모든 멤버에게 2초마다 하트비트 요청을 보낸다
- 하트비트의 가장 중요한 기능은 복제 셋의 과반수 도달 가능 여부를 프라이머리에 알리는 기능
- 프라이머리가 더는 서버의 과반수에 도달할 수 없다면, 스스로를 강등해 세컨더리가 된다

### 멤버 상태
- 멤버들은 하트비트를 통해 상태를 서로 주고받는다
- 멤버들이 가질수 있는 일반적인 상태는 다음과 같다

`STARTUP`
- 멤버를 처음 시작할 때의 상태
- 몽고 DB 가 멤버의 복제 셋 구성 정보 로드를 시도할 때 이상태가 됨
- 구성 정보가 로드되면 STARTUP2 로 변경된다

`STARTUP2`
- 초기 동기화 과정 전잔에 걸쳐 지속된다
- 일반적으로 단 몇 초 동안만 지속된다
- 복제와 선출을 다루기 위해 몇몇 스레드로 분리되며 다음 상태인 RECOVERING 으로 변환된다

`RECOVERING`
- 멤버가 현재 올바르기 동작하지만 읽기는 수행할 수 없음을 의미한다
- 조금 과부화된 상태로 다양한 상황에서 나타난다

`ARBITER`
- 일반적인 연산 중에는 특수한 상태인 ARBITER 를 유지해야 한다

`DOWN`
- 멤버가 살아 있지만 도달할 수 없는 상태
- 다운됬다는 멤버는 사실 살아 있지만 단지 네트워크 문제 때문에 도달할 수 없을 수도 있다

`UNKNOWN`
- 멤버가 다른 멤버에 도달한 적이 없었다면 상태를 전혀 할 수 없다
- 이는 일반적으로 알 수 없는 멤버가 다운되거나, 두 멤버간에 네트워크 문제가 있음을 나타낸다

`REMOVED`
- 멤버가 복제 셋으로부터 제거된 상태
- 다시 복제셋에 추가되면 정상적인 상태로 변경된다

`ROLLBACK`
- 멤버가 데이터를 롤백할 때 사용된다
- 롤백 과정 마지막에서 서버는 RECOVERING 상태로 전환되고 세컨더리가 된다

## 선출
- 멤버가 프라이머리가 되지 못하면 프라이머리 선출을 모색한다
- 선출되고자 하는 멤버는 도달할 수 있는 모든 멤버에 알림을 보낸다
- 이를 받은 멤버는 해당 멤버가 프라이머리가 될 수 있는지 알아본다
- 반대한 이유가 없다면 이에 투표하며, 복제 셋의 과반수로 부터 득표하면 멤버는 프라이머리 상태로 전환된다
- 득표하지 못할 경우 세컨더리로 남으며, 나중에 다시 프라이머리가 되려고 시도한다
- 프라이머리는 멤버의 과반수에 도달할 수 없거나 다운되거나 세컨더리로 강등되거나, 복제 셋이 재구성될 때까지는 자격을 계속 유지한다
- 네트워크가 양호하다면 이는 빠르게 진행된다
- 최대 2초동안 프라이머리 다운을 알리고 선출을 즉시 시작한다

## 롤백
- 두 개의 데이터 센터가 있고, 하나는 프라이머리와 세컨더리를 / 다른 하나는 세 개의 세컨더리를 가진다고 가정하자
- 두 센터 간에 너트워크 파티션이 존재한다고 가정
- 첫 센터에 있는 연산은 126 까지, 두 번째 센터는 다른 센터로부터 복제되지 않았음
- 다른 세터의 서버들은 여전히 복제셋의 과반수에 도달할 수 있어서 새로운 프라이머리가 선출되고 쓰기작업이 수행될 수 있다
- 네트워크 파티션이 복구된 이후 첫 번째 센터의 서버들은 다른서버들로부터 동기화하려고 126 연산을 찾지만 이를 찾지 못한다
- 이런 경우 **롤백** 이라는 과정이 시작된다
- 롤백 => 복구 전에 복제되지 않은 연ㅅ나을 원래 상태로 되돌리는데 사용된다
- 126 이 있는 서버는 공통 지점을 찾고자 다른 센터의 oplog 들을 살핀다
- 공통되는  가장 최신 연산인 125 를 발견하고, 126-128 연산이 충돌이 발생했음을 알아챈다
- 이 시점에 126이 있는 서버는 그 연산으로 부터 영향받은 도큐먼트의 버전을 rollback 디렉터리에 있는 .bson 파일에 쓴다
  - 연산 126에 의해 갱신된 도큐먼트를 컬렉션명.bson 에 쓴다
  - 그 후 현재 프라이머리에서 해당 도큐먼트의 버전을 복제한다

### 롤백에 실패할 경우
- 몽고 4.0 이전에는 롤백이 숳애되기에 너쿠 큰지 여부를 결정할 수 있었음
- 4.0 부터는 롤백 가능한 데이터 양에 제한이 없다
- 4.0 이전에서는 데이터가 300메가를 초과하거나 롤백에 30분이상 걸린다면 실패할 수 있다
- 이때 롤백에 갇힌 노드를 재동기화 해야 한다
- 이런 현상은 세컨더리가 뒤처지고 프라이머리가 다운될 떄 가장 흔히 발생한다
- 세컨더리중 하나가 프라이머리가 되면 이전 프라이머리로부터 많은 연산을 놓치게 된다
- 멤버가 롤백에 갇히지 않게 하려면 세컨더리를 가능한 최신 상태로 유지하는 것이 좋다
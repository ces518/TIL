# 9장 애플리케이션 설계
- 스키마 설계 고려 사항
- 데이터 내장 방식과 참조 방식 중 결정하기
- 최적화를 위한 팁
- 일관성 고려 사항
- 스키마 마이그레이션 방법
- 스키마 관리 방법
- 몽고 DB 가 적합하지 않은 경우

## 스키마 설계 고려 사항
- 데이터 표현 핵심 요소 => 도큐먼트에서 표현되는 방식인 스키마 설계
- 가장 좋은 설계 접근 방식 => 애플리케이션에서 원하는 방식으로 데이터 표현하기
- RDBMS 와 달리 스키마 모델링 전 쿼리 및 데이터 접근 패턴을 이해해야함
- 스키마 설계시 고려해야할 요소들을 살펴보자

`제약 사항`
- 데이터베이스와 하드웨어 제약 사항을 이해해야함
- 몽고 DB 특정 측면도 고려
- 도큐먼트의 최대 크기는 16메가
- 디스크에서 전체 도큐먼트를 읽고 쓴다
- 갱신은 전체 도큐먼트를 다시쓰며, 원자성 갱신은 도큐먼트 단위로 실행됨

`쿼리 및 쓰기의 접근 패턴`
- 애플리케이션 및 더 넓은 시스템의 워크로드 식별 및 정량화가 필요함
- 워크로드 => 애플리케이션 읽기 쓰기를 모두 포함
- 쿼리 실행 시기 및 빈도를 알면 일반적인 쿼리르 식별할 수 있음
- 이는 스키마 설계시 필욯나 쿼리임
- 쿼리 식별 이후 쿼리 수를 최소화 하고 함께 쿼리되는 데이터가 동일 도큐먼트에 저장되도록 설계해야 한다
- 쿼리에 사용되지 않는다면 다른 컬렉션에 저장한다
  - 자주 사용하지 않는 경우도 동일

`관계 유형`
- 애플리케이션 요구사항과 도큐먼트 간 관계 측면에서 어떤 데이터가 관련돼 있는지 고려
- 그 이후 데이터나 도큐먼트를 내장하고 참조할 방법을 결정한다
- 추가로 쿼리하지 않고 도큐먼트를 참조한느 방법을 파악하고, 관계 변경시 갱신되는 도큐먼트 수를 알아야 함
- 데이터가 쿼리하기 쉬운 구조인지도 고려

`카디널리티`
- 관계의 카디널리티를 고려해야 한다
- 몽고 DB 스키마에서 모델링에 최선인 형식을 사용하도록 관계의 카디널리티를 설정하는 것이 매우 중요
- 개별적으로 접근되는지, 상위 개체의 컨텍스트에서만 접근되는지 고려하고 데이터 필드에 대핸 읽기/갱신 비율도 고려해야 한다
- 이는 도큐먼트 데이터의 비정규화 여부와 내장 혹은 참조할지 결정하는데 도움이 된다

### 스키마 설계 패턴

`다형성 패턴`
- 컬렋녀 내 모든 도큐먼트가 유사하지만 동일하지 않는 구조를 가질때 적합
- 공통 쿼리를 지원하는 도큐먼트에서 공통 필드를 식별하는 것이 포함된다
- 도큐먼트나 서브도큐먼트의 특정 필드를 추적하면 이런 차이를 관리하기 위해 클래스/서브 클래스 간 차이점을 식별할 수 있다

`속성 패턴`
- 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우, 정렬하려는 필드가 도큐먼트의 서브셋에만 존재하는 경우 또는 두 조건이 모두 해당하는 경우이다
- 데이터를 키/값 쌍 배열로 재구성하고 배열 요소에 인덱스를 만들어야 한다
- 키/값 쌍에 한정자 (qualifier) 를 부가 필드로 추가할 수 있음
- 이는 도큐먼트 당 유사한 필드를 대상으로 지정하기 때문에 필요 인덱스가 적어지고 쿼리 작성이 간단해짐

`버킷 패턴`
- 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합하다
- 몽고 DB 에서 이 데이터를 특정 시간 범위의 데이터를 각각 보유하는 도큐먼트 셋으로 '버킷화' 하면 시간/데이터 포인트의 포인트당 도큐먼트를 만들 때보다 훨씬 효율적이다
- 도큐먼트 자체에는 이 버킷이 다루는 기간을 나타내는 시작 및 종료 시간이 있다

`이상치 패턴`
- 드물게 도큐먼트의 쿼리가 애플리케이션의 정상적인 패턴을 벗어날 때 사용한다
- 인기도가 중요한 상황을 위해 설계된 고급 스키마 패턴이며, 도서 판매, 영화 리뷰 등이 있는 소셜 네트워크에서 볼 수 있다
- 플래그를 사용해 도큐먼트가 이상점임을 나타내며 추가 오버플로를 하나 이상의 도큐먼트에 저장한다
- 플래그는 애플리케이션 코드에서 오버플로 도큐먼트를 검색하기 위한 추가 쿼리를 만드는데 사용된다

`계산된 패턴`
- 데이터를 자주 계산해야 할 때나 데이터 접근 패턴이 읽기 집약적 일 때 사용한다
- 주요 도큐먼트가 주기적으로 갱신되는 백그라운드에서 계산을 수행하도록 권장한다
- 개별 쿼리에 대해 필드나 도큐먼트를 지속적으로 생성하지 ㅇ낳고도 계산된 필드 및 도큐먼트의 유효한 근사치를 제공한다
- 읽기가 계산을 트리거하고 읽기-쓰기 비율이 높은 경우에 특히 동일한 계산의 반복을 방지함으로써 CPU 부담을 크게 줄일 수 있음

`서브셋 패턴`
- 장비의 램 용량을 초과하는 작업 셋이 있을 때 사용한다
- 애플리케이션에서 사용하지 않는 정보를 많이 포함하는 대용량 도큐먼트 때문에 발생할 수 있다
- 서브셋 패턴은 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별 컬렉션으로 분할하도록 한다
- 일반적으로 전자상거래 애플리케잇녀 이다
- 컬렉션에 가장 최근리뷰 10개를 저장하고, 나머지는 두 번째 컬렉션으로 이동한다
  - 두번째 컬렉션은 최근 10개 이외의 리뷰가 필요할때 쿼리함

`확장된 참조 패턴`
- 각각 고유한 컬렉션이 있는 여러 논리 엔티티 가 있고, 특정 기능을 위해 엔티티들을 모을 때 사용한다
- 개별 컬렉션에서 단일 주문에 대한 정보를 모두 수집하면 성능상 이슈가 잇을 수 있음
- 이때 자주 접근 하는 필드를 식별하고 주문 도큐먼트로 복제하면 문제 해결이 가능하다
- 확장된 참조 패턴은 데이터를 중복시키는 대신 정보를 조합하는 데 필요한 쿼리 수를 줄인다

`근사 패턴`
- 리소스가 많이 드는 계산이 필요하지만 높은 정확도가 반드시 필요하지는 않는 상황에 유용하다
- 이미지나 게시글의 추천 수 카운터 또는 페이지 조회 수 카운터를 예로 들 수 있다
- 근사 패턴을 적용해 추천이나 조회수가 100회때마다 카운터를 갱신하면 쓰기 횟수를 크게 줄일 수 있다

`트리 패턴`
- 쿼리가 많고 구조적으로 주로 계층적인 데이터가 있을 때 적용한다
- 일반적으로 함께 쿼리되는 데이터를 한데 저장하는 방식을 따른다

`사전 할당 패턴`
- MMAP 스토리지 엔진과 함께 사용됐지만 여전히 사용된다
- 이 패턴은 빈 구조를 사전 할당한다
- 예약 정보를 매일 관리하는 시스템에서 예약 가능 여부와 현재 예약 상태를 추적하는데 적용된다

`도큐먼트 버전 관리 패턴`
- 도큐먼트의 이전 버전을 유지하는 메커니즘을 제공한다
- 메인 컬렉션의 도큐먼트 버전을 추적하려면 각 도큐먼트에 부가 필드를 추가해야 하며 도큐먼트의 모든 수정사항을 포함하는 추가 컬렉션이 필요하다
- 여기는 몇 가지 가정이 있음
  - 각 도큐먼트의 개정을 횟수가 제한된다
  - 버전 관리가 필요한 도큐먼트가 많지 않음
  - 쿼리는 각 도큐먼트의 현재 버전에서 먼저 수행된다
- 위 가정들이 유효하지 않으면 패턴을 수정하거나 다른 스키마 설계 패턴을 고려해야 한다

## 정규화 vs 비정규화
- 정규화 => 컬렉션 간의 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업
- 각 데이터 조각은 여러 도큐먼트가 참조 가능하지만 하나의 컬렉션에 들어 있다
- 데이터 변경시 한 도큐먼트만 갱신하면 된다
- 몽고 DB 집계 프레임워크는 joined 컬렉션에 도큐먼트를 추가해 left outer join 을 수행하는 $lookup 단계와의 조인을 제공한다
- 비 정규화 => 모든 데이터를 하나의 도큐먼트에 내장하는것으로 정규화의 반대

> 일반적으로 정규화는 쓰기를 빠르게, 비정규화는 읽기를 빠르게 만든다. 애플리케이션에 적합한 방식을 선택해야 한다

`혼합된 확장 참조 패턴`
- 내장과 참조가 혼합된 방식
- 자주 사용되는 정보로 서브도큐먼트의 배열을 생성하고, 추가적인 정보는 실제 도큐먼트를 참조하도록 하는 방식

```shell
{
  "_id" : ObjectID("FASFASSD"),
  "name" : "John doe",
  "classes" : [
    {
      "_id" : ObjectID("FASFASD"),
      "class" : "Hello"
    }
  ]
}
```
- 시간이 흐르면서 오규사항 변경에 따라 내장 정보 양이 계속 바뀔 수 있으므로 좋은 방식
- 정보가 읽히는 빈도에 비해 얼마나 자주 변경되는지도 중요하게 고래향 함
- 정보가 정기적으로 갱신된다면 정규화 하는 것이 좋으며, 드물다면 최적화해도 이득이 거의 없음
- 갱신 연산자 측면에서 $set 은 멱등이지만 $inc 는 그렇지 않다
- 내장 필드의 내용이나 개수가 제한없이 늘어나야 한다면 그 정보는 내장되지 ㅇ낳고 참조되어야 한다
- 댓글 트리/ 활동 목록 등은 내장되지 않고 자체적인 도큐먼트로 저장돼야 한다
- 포함된 필드는 도큐먼트의 데이터에 포함되어야 한다
- 쿼리시 결과에서 거의 항상 제외된다면 다른 컬렉션에 속해도 된다.

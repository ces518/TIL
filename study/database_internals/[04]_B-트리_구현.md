# 지옥 스터디 - 04 B-트리 구현

## 페이지 헤더
- 탐색, 유지보수, 최적화에 필요한 페이지에 대한 정보를 저장함
- 일반적으로 페이지 내용을 나타내는 메타데이터를 저장함
  - 플래그
  - 레이아웃
  - 셀 개수
  - 빈 공간을 가리키는 하한 및 상한 오프셋

> PostgreSQL 은 페이지 크기와 레이아웃 버전을 헤더에 저장하고ㅡ MySQL InnoDB 는 힙 레코드 개수와 레벨, 기타 구조 관련 값을 헤더에 저장한다.

## 매직 넘버
- 파일 헤더 또는 페이지 헤더에 주로 저장하는 또 다른 값
- 일반적으로 상수 값을 포함하는 멀티바이트 블록이다.
- 페이지 종류, 버전과 같은 정보를 포함
- 검증, 상태 체크 에도 사용됨

> 임의의 오프셋의 바이트 열이 매직 넘버와 일치할 확률은 매우 낮다. <br/>
> 일치한다면 높은 확률로 해당 오프셋은 유효한 값이다.

## 형제 링크
- 좌우 형제 페이지를 가리키도록 **순방향 링크**, **역방향 링크** 를 저장하는 트리 구현법도 있다.
  - 부모 노드로 올라가지 않고, 이웃 노드를 바로 참조할 수 있음
  - 분할/병합시 이웃 오프셋까지 갱신해야 하므로 약간 더 복잡함
- 형제 링크가 없는 트리에서 형제 노드를 찾으려면 반드시 부모 노드를 거쳐야한다.
  - 형제 노드를 찾기 위해 루트노드 까지 찾아가는 일이 발생할 수도 있음
- 헤더에 형제 링크를 저장한다면 같은 레벨의 이전/다음 노드에 빠른 접근이 가능해진다

![형제 링크](./images/database_internals_siblings.png)

- 형제 링크 저장 방식의 단점은 노드 분할/병합 시 링크를 업데이트 해야한다.
- 대상 노드 뿐 아닌 형제링크 까지 해야하므로 추가적인 잠금이 필요할 수 있다.

## 가장 오른쪽 포인터
- B 트리의 구분키의 주 역할
  - 트리를 서브트리로 분할하고 탐색할 수 있도록 하는 것
  - 자식 페이지가 가리키는 포인터가 키 보다 반드시 하나 더 있다.

![Rightmost Pointer](./images/database_internals_rightmost_pointer.png)

- 대부분의 구분 키 구조는 위 그림과 같다.
- 각 구분키에는 자식 포인터가 있고, 마지막 포인터는 어떤 키와도 연관되어 있지 않으므로 따로 저장한다.
  - SQLite 는 마지막 포인터를 헤더에 저장한다.

![Rightmost Pointer02](./images/database_internals_rightmost_pointer_02.png)
- 가장 오른쪽 자식 노드가 분할된 이후 부모에 새로운 셀이추가되면 부모의 마지막 포인터도 다시 설정해야한다.
- 위 그림을 보면 노드 분할 이후 부모노드에 추가된 새로운 셀이 승급된 키를 가지면서 분할된 노드를 가리킨다.
- 부모의 마지막 포인터는 새로운 노드를 가리키도록 업데이트하는데, SQLite 가 이와 유사한 방식으로 구현되어 있다.

## 하이 키
- 하이키
  - 현재 노드의 서브트리에 저장된 가장 큰 키
- 각 트리 노드의 가장 오른쪽 포인터와 노드의 하이 키를 함께 저장하는 방법도 있다.
- 이런 방식의 트리를 B link - 트리 라고 하며 PostgreSQL 에서 사용한다.
- B link - 트리는 각 노드에 K n+ 1 키를 하나 씩 더 추가 저장한다.
  - 이 키는 포인터 Pn 이 가리키는 서브트리에서 가장 큰 키이다.
  - 이 값이 해당 서브트리에 저장할 수 있는 최대 값이다.

![High Key](./images/database_internals_highkey.png)

- 위 구조에서는 키와 포인터의 개수가 짝이 맞다.
- 모든 셀은 대응 되는 포인트를 갖는다.
- 따라서 에지 케이스가 줄어들고 가장 오른쪽 포인터의 처리가 단순해진다.

## 오버플로우 페이지
- B 트리 알고리즘에서 모든 노드는 일정 개수의 키를 유지해야 한다.
  - 각 노드에 저장된 값의 크기가 다를수 있기에 노드 저장시 사용하는 페이지가 고정 크기라면 남은 공간이 없을 수 있음
  - 페이지 크기 변경은 기존 데이터를 복사해야 하므로 비효율 적이다.
- 여러 페이지를 연결하면 이를 복사하지 않고 가변 크기 노드를 구현할 수 있다.
- 기본 크기가 4K 인 페이지에 삽입된 값이 4K 이상이라면 추가할당이 아닌 4K 단위로 노드를 확장하고 할당된 새로운 페이지를 원본 페이지에 연결한다.
- 여기서 새로 할당된 페이지를 **오버 플로우 페이지 (Overflow Page)** 라고 한다.
- 대부분의 B-트리는 고정 크기 바이트만 노드에 저장하고 나머지는 ㄴ오버 플로우페이지에 저장한다.
  - 고정 크기 : 노드 크기를 팬 아웃으로 나눈 값
  - 페이지에 최소 max_payload_byte 만큼 공간이 항상 남아 있으므로 페이지에 공간이 부족한 상황은 발생하지 않는다.
- 삽입된 데이터가 max_payload_size 보다 크다면 해당 노드에 오버 플로우 페이지 가 있는지 확인해야 한다.
  - 없다면 새로운 오버플로우 페이지를 할당한다.

![Overflow Pages](./images/database_internals_overflow_pages.png)

- 오버 플로우 페이지는 특별 관리가 필요하다.
  - 기본 페이지와 동일하게 단편화 발생 가능
  - 새로운 데이터를 쓰기위해 공간 회수 또는 불필요한 페이지 삭제필요
  - 첫 오버 플로우 페이지 할당시 해당 페이지 ID 를 기본 페이지 헤더에 저장
  - 오버 플로우 페이지가 여러개 라면 각 헤더에 다음 페이지 ID 를 저장 및 연결
  - 특정 데이터를 찾기 위해 여러 오버플로우 페이지를 학인해야 할 수도 있음
- 키의 카디널리티는 일반적으로 높고 대부분 기본 페이지에 저장된 키가 비교대상이기에 키를 나눠 저장해도 된다.
# 지옥 스터디 - 16 InnoDB 클러스터
- MySQL 은 서버 자체적으로 페일오버 처리를 하는 기능을 제공하지 않는다.
  - 장애 발생시 일련의 작업들을 수행해야함.
- 어떤 서비스든 장애가 발생한 경우 장애 시간을 최소화 하는것이 제일 중요함.
  - 때문에 수동 처리보단 자동화 하는 것을 고려해야함.
- 대표적으로 MMM/MHA, Orchestrator 와 같은 HA 솔루션을 사용한다.
- MySQL 5.7.17 버전에서 빌트인 형태의 HA 솔루션인 **InnoDB 클러스터** 가 도입되면서 사용자가 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게 됨.

## InnoDB 클러스터 아키텍쳐
- InnoDB 클러스터는 MySQL 내의 특정 기능이아닌, MySQL 고가용성 실현을 위해 만들어진 여러 구성요소들의 집합체.

`InnoDB 클러스터 구성요소`
- 그룹 복제 (Group Replication)
  - 소스 서버의 데이터를 동기화하는 기본적인 복제 뿐이 아닌, 복제에 참여하는 MySQL 서버들에 대한 **자동화된 멤버십 관리** 역할을 담당
- MySQL 라우터 (MySQL Router)
  - 애플리케이션과 MySQL 서버 사이에 동작하는 미들웨어
  - 애플리케이션이 실행한 쿼리를 적절한 MySQL 서버로 전달하는 **프록시 (Proxy)** 역할을 함.
- MySQL 셸 (MySQL Shell)
  - 기존 MySQL 클라이언트 보다 확장된 기능을 가진 클라언트 프로그램.
  - 기본 SQL 실행뿐 아닌 자바스크립트/파이썬 기반 스크립트 작성 기능과 클러스터 구성 등 Admin API 를 제공함.

`일반적인 InnoDB 클러스터 구성`

![InnoDB Cluster](./images/mysql_innodb_cluster.png)
- 데이터가 저장되는 MySQL 서버들은 **그룹 복제** 형태로 복제가 구성되고, **프라이머리 (Primary)** 또는 **세컨더리 (Secondary)** 중 하나의 역할로 동작하게 된다.
  - 프라이머리 : R/W 가능. 기본 복제에서의 소스 서버
  - 세컨더리 : R 가능. 기존 복제에서의 레플리카 서버

> 프라이머리는 하나만 존재할 수도 있고, 여러 대가 존재할 수 있으며, 그룹복제에서 InnoDB 스토리지엔진만 사용하기 때문에 InnoDB 클러스터라고 명명되었음.

- 그룹 복제 구성시 **고가용성을 위해 MySQL 서버를 최소 3대 이상** 으로 구성한다.
  - 일명 매직넘버 3... 인프라 구성시 보편적으로 사용되는 숫자 
- InnoDB 클러스터는 **MySQL 라우터** 를 통해 쿼리를 실행한다.
- InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보를 가지고, 클라이언트로 부터 실행된 쿼리를 적절한 MySQL 서버로 전달함.
  - 클라이언트의 커넥션 정보는 MySQL 라우터 서버만 설정하면 됨.
- **MySQL 셸** 은 사용자가 쉽게 클러스터 생성 및 관리가 가능하도록 API 를 제공한다.
  - 클러스터와 관련된 작업은 직접 서버에 연결해야 하지만, 단순 쿼리 실행의 경우 라우터를 통해 처리할 수도 있음.

`InnoDB 클러스터의 장애 처리`
- MySQL 서버에 장애가 발생하면, 그룹복제가 먼저 이를 감지해 자동으로 해당 서버를 복제 그룹에서 제외시킨다.
- MySQL 라우터는 복제 토폴로지 변경을 인지하고, 메타데이터를 갱신해 정상동작하는 MySQL 서버로만 전달될 수 있도록 처리한다.

> 기존에 수동으로 장애복구 처리를 하던것들이 모두 자동화 되어 있음.

## 그룹 복제 (Group Replication)

![MySQL Group Replication](./images/mysql_group_replication.png)

- MySQL 5.7.17 버전에서 도입된 새로운 복제 방식.
- 기존 MySQL 복제 프레임워크 기반으로 구현되어 있다.
  - 내부적으로 Row 포맷 바이너리 로그와 릴레이로그, GTID 를 사용함.
  - 구조적으로 유사한 부분도 있지만, 복제 구성 형태와 트랜잭션 처리 방식에서는 완전히 다른 방식임.

![MySQL Group Replication Data Sync](./images/mysql_group_replication_data_sync.png)

`기존 복제 방식`
- 일반적으로 소스-레플리카 서버로 구성되어 **단방향** 으로만 복제가 이루어 진다.
- 복제 처리 방식을 데이터 동기화 측면에서 보았을때, **비동기 방식 (Asynchronous)** 과 **반동기 (Semi-Synchronous)** 방식으로 나눌 수 있음.
- 기본적으로 소스 서버에서 트랜잭션 커밋 처리가 레플리카 서버와 무관한 **비동기 방식** 으로 처리됨.
- 트랜잭션 커밋시 레플리카 서버로도 해당 트랜잭션이 잘 전달되었고, 잘 적용되었는지 확인하지 않는다.
- 반동기 방식은 레플리카 서버로 해당 트랜잭션이 잘 전달되었는지 만 확인하고, 최종적으로 커밋 처리를 한다.

`그룹 복제 방식`
- 복제에 참여하는 MySQL 서버들이 하나의 복제그룹으로 묶인 클러스터 형태를 띔.
- 그룹내 서버들은 **양방향 복제 처리** 가 가능하다.
- 때문에 프라이머리/세컨더리 라고 표현한다.
- 그룹 복제는 **반동기 복제 방식** 이지만 기존 반동기 방식과 동일한 방식으로 처리되는 것은 아님.
- 반동기 방식과 유사하게 그룹내에 다른 멤버들의 응답을 확인하는 단계가 존재한다.
- 한 서버에서 트랜잭션이 커밋될 준비가 되면, 트랜잭션 정보를 그룹의 다른 멤버들에게 전송해 **과반수 이상의 멤버** 로 부터 응답을 받으면 해당 트랜잭션을 **인증 (Certify)** 하고, 최종적으로 커밋을 완료한다.
  - 인증 : 인증 대상 트랜잭션이 이미 인증단계를 통과한 선행 트랜잭션과의 충돌 여부를 검사하는 과정..
- 과반수 이상의 멤버로 부터 응답을 받지 못하면 해당 트랜잭션은 그룹에 적용되지 않는다.
  - 트랜잭션 커밋 처리시 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 **합의 (Consensus)** 라고 한다.
  - 데이터를 **변경** 하는 트랜잭션에 대해서만 합의 과정이 필요함.
- 해당 트랜잭션이 실제로 적용했는지 까지 확인하지는 않는다. 
- 그룹내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션 적용 여부가 결정되는것이 큰 차이점이다.

`그룹복제의 대표적인 기능`
- 그룹 멤버 관리
- 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
- 자동 페일 오버
- 자동 분산 복구

### 그룹 복제 아키텍쳐

![MySQL Group Replication Architechure](./images/mysql_group_replication_architecture.png)

- 그룹 복제는 **별도 플러그인** 으로 구현되어 있음.
- 각 MySQL 서버들은 복제 플러그인을 통해 서로 통신하며 동기화 처리를 한다.
- 그룹 복제 설정시 `group_replication_applier` 라는 복제 채널이 생성됨.
- 이를 통해 그룹에서 실행된 모든 트랜잭션을 전달받아 적용한다.
- 새로운 서버가 참여해 최신 데이터 싱크 작업이 필요한 경우 `group_replication_recovery` 라는 복제 채널을 생성해 이를 처리한다.

`그룹 복제 플러그인의 구조`

![MySQL Group Replication Plugins](./images/mysql_group_replication_plugins.png)
- 최상위 계층에는 MySQL 서버와 상호작용하기 위한 **인터페이스 플러그인 API** 가 있음.
  - 이를 통해 그룹 복제 플로그인과 통신하게 됨.
  - 서버 시작/복구 트랜잭션 커밋등 이벤트 등 처리..
- 그 아래에 그룹 복제의 실질적인 기능들이 구현된 **복제 플러그인 계층** 이 있음.
  - 내부에 여러 모듈로 세분화 되어 있고, 각 요청들이 적절한 모듈로 전달됨.
  - 로컬 및 그룹복제의 다른 MySQL 서버에서 실행된 원격 트랜잭션들이 처리 됨.
  - 트랜잭션들에 대한 충돌감지/그룹 내 전파 등이 수행된다.
  - 그룹 복제 분산 복구 작업도 여기서 처리됨.
- 마지막으로 **그룹 통신 시스템 API** 와 **그룹 통신 엔진** 이 있음.
  - 그룹 통신 엔진은 eXtendedCOMmunication 또는 XCom 이라고 한다.
  - 그룹 복제에 참여중인 서버들 간의 통신을 담당하는 핵심 구성 요소.
  - 일반적으로 33061 포트로 통신을 수행하며, 각 트랜잭션들이 복제 멤버들에게 동일한 순서로 전달되도록 **순서 보장** 을 해준다.
  - 토폴로지 변경과 멤버 장애 등을 감지함.
  - 트랜잭션 적용을 위한 멤버간의 **합의 처리** 도 담당하는데, 일반적으로 많이 사용되는 알고리즘으로 Paxos 와 Raft 가 있음.

`Paxos`
- 분산 시스템에서 데이터 변경이 발생하는 서버가 여러 대 존재하는 경우 주로 사용됨
- Google Chubby 에서 사용중.

`Raft`
- 데이터 변경이 한 대에서만 발생하는 경우 주로 사용됨.
- RAMCloud 에서 사용중.

> 그룹 복제에서 중요한 부분은 그룹 복제를 구성하는 MySQL 서버의 수 이다. <br/>
> 최소한 세 대 의 서버가 그룹에 존재해야 한다. (장애 발생시 문제없이 운용 하기 위함)

- 그룹 복제 구성시 허용 가능한 장애 서버수에 따른 전체 서버 수를 다음과 같이 계산해 그룹 복제로 구성해야 한다.

```shell
n = 2f + 1 (n: 전체 서버수, f: 허용하고자 하는 장애 서버 수)
```

### 그룹 복제 모드
- 그룹 복제에서는 쓰기를 처리할 수 있는 프라이머리 서버 수에 따라 싱글/멀티 프라이모드 두 가지 동작 모드가 있다.
  - `group_replication_single_primary_mode` 시스템 변수로 설정 가능.
  - 기본값은 ON
- 그룹 복제에 참여하는 MySQL 서버들은 모두 동일한 모드 값으로 설정되어 있어야 한다.
- MySQL 8.0.13 버전 이상인 경우 글부 복제 동작중인 상황에서도 변경이 가능함.
  - group_replication_switch_to_single_primary_mode()
  - group_replication_switch_to_multi_primary_mode()
- 8.0.13 미만인 경우 그룹 복제를 중단한 뒤 값을 변경해야함.

`싱글 프라이머리 모드`
- 싱글 프라이머리 모드는, 쓰기 처리가 가능한 프라이머리 서버가 한 대만 존재하는 형태
- 싱글 모드로 그룹 복제를 처음 구축하는 경우 구축을 진행한 서버가 프라이머리로 지정됨.
- 프라이머리가 아닌 서버들은 그룹에 참여하는 시점에 자동으로 `super_read_only` 가 ON 으로 설절되어 읽기 전용 모드로 동작함

![MySQL Single Primary Mode](./images/mysql_single_primary_mode.png)

- 싱글 프라이머리로 동작중인 경우 다음 두가지 상황에서 프라이머리가 변경될 수 있음
  - 현재 프라이머리 서버가 그룹을 탈퇴하는 경우
  - group_replication_set_as_primary() UDF 를 사용해 그룹의 특정 멤버를 프라이머리로 지정한 경우
- UDF 를 사용하지 않은 경우 다음 기준을 따라 새로운 프라이머리를 선정하게 된다.

`프라이머리 선정 우선순위`
1. MySQL 서버 버전
   - 가장 우선시 되는 요소
   - 그룹 내에서 가장 낮은 MySQL 버전인 서버가 프라이머리가 된다.
   - 8.0.17 버전인 경우 **패치 버전** 을 기준으로, 그 미만인 경우 **메이저 버전** 을 기준으로 선정됨.
2. 각 멤버의 가중치 값
   - 가장 낮은 MySQL 버전인 서버가 둘 이상인 경우 `group_replication_member_weight` 에 지정된 가중치를 기준으로 선정한다.
   - 0 ~ 100 사이 값을 지정할 수 있고, 기본갑은 50.
3. UUID 값의 사전식 순서
   - 가중치를 기준으로 선정된 서버가 둘 이상인 경우 각 멤버들의 UUID 값중 가장 낮은 값을 선정한다.

`멀티 프라이머리 모드`
- 그룹 멤버들이 전부 프라이머리로 동작하는 형태

![MySQL Multi Primary Mode](./images/mysql_multi_primary_mode.png)
- 모든 멤버에서 쓰기가 발생할 수 있고, 각 멤버에게 전파 후 다시 처리되기 때문에 멤버간의 MySQL 버전 호환성이 중요하다.
  - 가능하다면 모두 같은 버전이면 좋음.
- MySQL 에는 그룹 복제 참여시 버전 호환성을 확인하는 기능이 구현되어 있음.
- 그룹 복제에 참여하는 멤버는 기존 멤버들과 호환성 검사를 수행하고, 호환 가능 기준에 따라 그룹 참여 가능여부/읽기 전용 모드 유지 여부를 결정한다.

`MySQL 호환 기준`
- 새로운 멤버가 **그룹에 존재하는 가장 낮은 MySQL 버전보다 낮은 MySQL 버전을 사용중인 경우** 참여할 수 없음.
- 새로운 멤버가 **그룹에 존재하는 가장 낮은 MySQL 버전과 동일한 버전을 사용중인 경우** 참여 가능.
- 멀티 프라이머리 모드 그룹에서는 **새로운 멤버가 그룹에 존재하는 가장 낮은 MySQL 버전 보다 높은 버전을 사용중이라면 참여는 가능하나, 읽기 전용 모드를 유지하게 됨.

### 그룹 멤버 관리 (Group Membership)
- 현재 어떤 서버들이 그룹에 참여하고 있는지 그룹 멤버들에 대한 목록과 상태 정보를 내부적으로 관리하고 있다.
- `performance_schema.replication_group_members` 테이블을 통해 확인 가능.
  - 그룹 멤버의 호스트명, 포트, UUID, MySQL 버전, Role 을 알수 있음.
  - MEMBER_STATE 컬럼을 통해 상태도 확인 가능
    - MEMBER_STATE.ONLINE : 정상 동작
    - MEMBER_STATE.RECOVERING : 복구 작업 진행중
    - MEMBER_STATE.OFFLINE : 복제 플러그인이 로딩되어 있으니, 복제엔 참여하지 않음.
    - MEMBER_STATE.ERROR : 복제에 참여중이나 복제가 정상적으로 동작하고 있지 않음.
    - MEMBER_STATE.UNREACHABLE : 통신 불가.

> 그룹 복제가 관리하는 멤버목록/상태 정보를 뷰 라고 한다. <br/>
> 뷰는 특정 시점의 그룹 멤버 목록 이라고 할 수 있음. 뷰 ID 라는 고유 식별자를 가지며 멤버가 변경될 때마다 새로운 아이디가 생성된다.

```shell
View ID = [Prefix value]:[Sequence value]
```
- 콜론 (:) 을 기준으로 접두사 부분은 그룹 복제 초기화시 생성되며, 그 시점의 타임스탬프를 기반으로 값이 만들어짐.
- 두번 째 부분은 단조 증가하는 정숫 값

![MySQL Group Replication View ID](./images/mysql_group_replication_view_id.png)

- 뷰 아이디가 변경되면 바이너리 로그에도 `View Change` 이벤트로 뷰 변경 내역이 기록된다.
- 모든 변경내역이 기록되는것은 아니며, 새로운 멤버가 추가되어 뷰가 변경되는 경우에만 기록된다.

### 그룹 복제에서의 트랜잭션 처리
- 그룹 복제에서 트랜잭션은 다음 두 단계를 거친 후 최종적으로 적용됨.
  - 합의 (Consensus)
  - 인증 (Certification)

`합의 (Consensus)`
- 그룹내 **일관된 트랜잭션 적용** 을 위해 트랜잭션 적용을 제안하고, 승낙을 받는 과정.
- 트랜잭션에서 변경한 데이터에 대한 `WriteSet` 과 커밋 당시의 `gtid_executed` 스냅숏 정보, 트랜잭션 이벤트 로그 데이터 등을 다른 멤버에게 전파한다.
  - `Paxos` 기반 프로토콜을 사용함.
- **과반수 이상에 해당하는 멤버들로 부터 응답** 을 받으면 다음 프로세스를 진행한다.

> 합의 단계를 거친후 글로벌하게 정렬되어, 각 멤버들에게 모두 동일한 순서로 인증 단계를 거친다.

`인증 (Certification)`
- 인증 단계에서는 전달받은 트랜잭션 `WriteSet` 데이터와 로컬에서 내부적으로 관리중인 `WriteSet` 히스토리 데이터를 바탕으로 해당 트랜잭션이 인증 단계를 거친 선행 트랜잭션과 충돌하는지 여부를 확인함.
- 트랜잭션 충돌은 멀티 프라이머리 모드에서만 발생할 수 있다.
- 충돌이 감지된 트랜잭션은 처리되지 못하고 롤백처리 됨.

> 인증 단계를 거친 후 바이너리 로그에 트랜잭션을 기룩한 뒤 최종적으로 커밋을 완료하며 이 시점에 커밋요청에 대한 응답을 클라이언트에게 전달한다.

![MySQL Group Replication Transaction](./images/mysql_group_replication_transaction.png)

`트랜잭션 일관성 수준`
- 그룹 복제에서 각 멤버들은 동일한 트랜잭션을 적용하지만, **실제 적용 시점 까지 완전히 일치하지는 않음.**
- 쓰기 수행 이후 다른 멤버에서 해당 데이터를 읽으면 변경사항이 반영되지 않았을 수 있다.
  - 프라이머리 장애시 페일오버가 발생하는 경우에도 발생할 수 있음.
- MySQL 8.0.14 이전 버전까지는 그룹 복제에서 이런 상황이 발생하는 것을 방지할 방법이 없었음.
- 8.0.14 버전부터 트랜잭션 일관성 수준을 설정할 수 있는 기능이 도입되었다.
- `group_replication_consistency` 시스템 변수를 통해 그룹 복제에서의 트랜잭션 일관성 수준을 설정할 수 있음.
- 이는 읽기 전용과 읽기/쓰기 트랜잭션에 서로 다른 영향을 미친다.
- 경우에 따라 다른 멤버에서 실행중엔 트랜잭션에 영향을 줄수도 있음.

`EVENTUAL 일관성 수준`
- EVENTUAL 일관성 수준은 `group_replication_consistency` 의 기본 값
- 최종적 일관성을 갖게됨을 의미한다.
- 읽기 전용 및 읽기/쓰기 트랜잭션이 별도 제약 없이 바로 실행 가능.

![MySQL Eventual](./images/mysql_eventual.png)

`BEFORE_ON_PRIMARY_FAILOVER 일관성 수준`
- 싱글 프라이머리 모드로 지정된 그룹 복제에서 **프라이머리 페일오버가 발생** 한 경우 트랜잭션에 영향을 미친다.
- 페일오버가 발생하고, 새롭게 선출된 프라이머리가 이전 프라이머리의 트랜잭션을 적용중인 경우 새로운 프라이머리로 유입된 트랜잭션은 적용되지 못하고, 앞선 트랜잭션이 모두 적용될 때까지 대기하게 된다.

![MySQL Before On Primary FailOver](./images/mysql_before_on_primary_failover.png)

- 페일오버 시점에 새롭게 유입된 트랜잭션들의 대기시간은 **신규 프라이머리와 이전프라이머리의 트랜잭션 갭** 에 따라 달라짐.
- 무한정 대기하는 것은 아니며, `wait_timeout` 시스템 변수에 설정된 값만큼 대기하고, 초과 하는 경우 에러를 반환한다.
- 기본값은 8시간 (28,800 초)
- 이 일관성 수준에는 다음 부분들이 보장됨.
  - 신규 프라이머리로 유입된 트랜잭션 들은 최신 데이터를 바탕으로 동작하게 된다.
  - 신규 프라이머리로 유입된 트랜잭션 들은 충돌로 롤백될수 있는데 이런 롤백이 발생하지 않는다.
- MySQL 서버 모니터링 등을 위한 일부 쿼리는 바로 실행이 가능하다.

`BEFORE 일관성 수준`
- BEFORE 일관성 수준에서 읽기, 읽기/쓰기 트랜잭션은 모든 선행 트랜잭션이 완료될 때까지 대기 후 처리된다.
- BEFORE 일관성 수준에서는 항상 최신 데이터를 읽으며 트랜잭션 처리 시간은 선행 트랜잭션 처리 시간에 영향을 받게 된다.

![MySQL Before](./images/mysql_before.png)
- DB 에서 읽기 요청은 적고, 쓰기 요청이 많은 경우 사용하는 것이 좋다.

`AFTER 일관성 수준`
- AFTER 일관성 수준은 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한다.
- 다른 모든 멤버들에서도 해당 트랜잭션을 커밋할 준비가 됬을때 까지 대기한 후 최종적으로 처리됨.
- AFTER 일관성 수준은 다른 멤버에서 동시점에 실행되는 트랜잭션에 영향을 미치게 된다.
- 그룹의 어떤 멤버에서든 일관된 최신 데이터를 얻을 수 있다.
- DB 에서 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 수행하고자 할 때 사용하는 것이 좋다.

![MySQL After](./images/mysql_after.png)

`BEFORE AND AFTER 일관성 수준`
- BEFORE AND AFTER 일관성 수준은 BEFORE/AFTER 가 결합된 형태
- 읽기/쓰기 트랜잭션은 모든 선행 트랜잭션이 적용되기 까지 기다린 후 실행되며, 다른 모든 멤버들에서도 커밋 준비되어 응답을 보내면 그때 최종적으로 커밋된다.

![MySQL BEFORE AND AFTER](./images/mysql_before_and_after.png)
- 커밋이후 모든 후속 트랜잭션들은 그룹의 어떤 멤버에서든지 해당 트랜잭션의 변경사항을 포함하는 최신 데이터를 읽게 됨.

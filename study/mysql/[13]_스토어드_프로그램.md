# 지옥 스터디 - 13 스토어드 프로그램
- MySQL 에서는 **절차적인 처리** 를 위해 스토어드 프로그램을 지원한다.
  - 이를 스토어드 루틴이라고도 함
- 스토어드 프로시저와, 스토어드 함수, 트리거와 이벤트 등을 모두 아우르는 명칭.
- 스토어드 프로그램의 권한이나 보안 및 예외 핸들링 등 주의사항에 유의해서 사용해야함.

## 스토어드 프로그램의 장단점
- 스토어드 프로그램은 절차적인 처리를 제공해주지만, **애플리케이션을 대체** 할만한지 충분히 고려해야 한다.

### 스토어드 프로그램의 장점
1. 데이터베이스 보안 향상
    - MySQL 스토어드 프로그램은 자체적인 보안 설정 기능을 가지고 있고, **스토어드 프로그램 단위로 실행 권한을 부여** 할 수 있음.
    - 특정 테이블의 R/W, 특정 칼럼에만 권한을 부여하는 등 세밀한 권한제어가 가능하다.
    - 입력 값의 유효성을 체크한 후 동적 SQL을 생성하기 때문에 SQL 인젝션 같은 기본적인 보안사고를 피할 수 있음.
2. 기능의 추상화
    - 개발언어나 도구와 관계없이 추상화된 기능을 사용할 수 있음.
3. 네트워크 소요시간 절감
    - SQL 처리가 빠르게 처리된다면, 네트워크 비용이 문제가 될 수도 있다.
    - 하나에서 100번 200번씩 실행하게 될 경우 네트워크 비용은 횟수이 비례해 증가한다.
    - 스토어드 프로그램을 사용하면 네트워크 비용을 줄이고 성능을 개선할 수 있다.
4. 절차적 기능 구현
    - DBMS 서버에서 절차적인 기능을 실행할 수 있는 제어 기능을 제공 한다.
    - 불필요한 애플리케이션 코드도 많이 줄일 수 있다.
5. 개발 업무의 구분
    - 애플리케이션 개발자와 DBA 의 업무 구분이 가능해진다.

### 스토어드 프로그램의 단점
1. 낮은 처리성능
   - 스토어드 프로그램은 MySQL 엔진에서 해석되고 실행된다.
   - 하지만 MySQL 은 절차적인 처리를 하는것이 주 목적이 아니기 때문에 성능이 상대적으로 떨어짐.
   - 다른 DBMS 와 달리 **매 실행시마다 스토어드 프로그램 코드가 파싱** 되어야 한다.
2. 애플맄이션 코드의 조각화
   - 각 기능을 담당하는 코드가 애플리케이션과 스토어드 프로그램으로 **분산되어 설치나 배포가 복잡해지고 유지보수성이 떨어진다.**

## 스토어드 프로그램의 문법
- 스토어드 프로그램은 **헤더** 와 **본문** 으로 구성되어 있다.
  - 헤더는 정의 부 라고하며, 스토어드 프로그램의 이름, 입출력 값을 명시하는 부분
    - 보안이나 동작방식 관련 옵션을 명시할 수 있음.
  - 본문은 스토어드 프로그램의 바디 라고 한다.
    - 호출되었을때 실행하는 내용을 작성하는 부분.

### 스토어드 프로시저
- 스토어드 프로시저는, **여러쿼리를 하나의 그룹으로 묶어 독립적으로 실행** 하기 위함이 목적
  - 배치 프로그램에서 첫 쿼리 결과를 이용해 두번째 쿼리를 실행하는 경우가 대표적임.
- MySQL 서버와 클라이언트간의 네트워키 비용을 줄일 수 있음.
- 스토어드 프로시저는 **반드시 독립적으로 호출** 되어야 하고, SELECT/UPDATE 같은 SQL 문장에서 스토어드 프로시저를 참조할 수 없음.

#### 스토어드 프로시저 생성 및 삭제
- 스토어드 프로시저는 `CREATE PROCEDURE` 명령으로 생성할 수 있다.
- 기본적인 형태는 다음과 같다.

```sql
CREATE PROCEDURE sp_sum (IN param1 INTEGER, IN param2 INTEGER, OUT param3 INTEGER)
    BEGIN
        SET param3 = param1 + param2
    END ;;
```
- 위 예제의 프로시저 이름은 `sp_sum` 이고 3개의 파라미터를 받는다.
- `BEGIN`, `END` 까지는 본문에 속한다.

`스토어드 프로시저 생성시 주의 사항`
- 스토어드 프로시저는 **기본 반환값이 없음**
  - 내부에서 `RETURN` 명령으로 값을 반환할 수 없다.
- 스토어드 프로시저의 각 파라미터는 **3가지 특성** 을 가진다.
  - `IN` 타입은 입력 전용 파라미터. 본문에서 읽기 전용으로 이해하면 됨
  - `OUT` 타입은 출력 전용 파라미터. 실행 완료시 외부로 결과를 반환하는 용도
  - `INPUT` 타입은 입/출력 용도 모두 사용 가능

스토어드 프로그램 사용시 **SQL 구분자를 변경** 해서 사용해야 한다.

일반적으로 `;` 가 쿼리의 끝을 의미하는데, 스토어드 프로그램 본문은 무수히 많은 `;` 를 사용하기 때문에 프로시저 생성 명령의 끝을 알 수 없음.

때문에 별도의 문자열을 구분자로 설정해 사용해야 한다.

`스토어드 프로그램 종료문자 변경`
- 명령의 끝을 알려주는 종류 문자를 변경하는 명령어는 `DELIMITER`
- 일반적으로 `;;` 또는 `//` 같이 연속된 2개의 문자열을 종료문자로 설정한다.
- 종료문자를 변경하면 일반적인 쿼리에서도 해당 종료문자를 사용해야 하기 때문에 프로시저 정의가 끝났다면 **기본 종료문자로 롤백** 하는 것이 좋음.

```sql
DELIMITER ;;

CREATE PROCEDURE sp_sum (IN param1 INTEGER, IN param2 INTEGER, OUT param3 INTEGER)
BEGIN
        SET param3 = param1 + param2
END ;;

DELIMETER ;
```

`스토어드 프로시저 변경 및 삭제`
- 스토어드 프로시저를 변경할때는 `ALTER PROCEDURE` 명령을, 삭제시에는 `DROP PRODECURE` 명령을 사용한다.
- 보안 및 작동방식과 관련된 옵션을 변경할 때만 `ALTER PROCEDURE` 명령을 사용할 수 있으므로 주의.

```sql
ALTER PROCEDURE sp_sum SQL SECURITY DEFINER;

DROP PROCEDURE sp_sum;;
CREATE PROCEDURE sp_sum (IN param1 INTEGER, IN param2 INTEGER, OUT param3 INTEGER)
BEGIN
        SET param3 = param1 + param2
END ;;
```
- 스토어드 프로시저의 파라미터나 본문을 숮어할 때는 DROP&CREATE 형태로 사용할 수 있다.

#### 스토어드 프로시저 실행
- 스토어드 프로시저와 스토어드 함수의 가장 큰 차이는 **실행하는 방법**
- 스토어드 프로시저는 반드시 `CALL` 명령어로 실행해야 한다.
- 또한 `IN` 파라미터는 상수를 사용할 수 있지만 `OUT` 이나 `INOUT` 은 세션 변수를 통해 주고받아야 한다.

```sql
SET @result:=0;

CALL sp_sum(1, 2, @result);
```
- 자바와 같은 프로그래밍 언어에서는 세션 변수를 사용하지 않아도 `OUT`, `INOUT` 타입 변수를 읽어올 수 있다.

#### 스토어드 프로시저의 커서 변환
- 스토어드 프로그램은 **명시적으로 커서를 파라미터로 전달 받거나 반환할 수 없음**
- 하지만 프로시저 내에서 커서를 오픈하지 않거나 SELECT 결과 셋을 페치하지 않으면 해딩 쿼리 결과 셋은 클라이언트로 바로 전송된다.

```sql
CREATE PROCEDURE sp_selectEmployees (IN in_empno INTEGER)
    BEGIN
        SELECT * FROM employees WHERE emp_no = in_empno;
    END;;

CALL sp_selectEmployees(10001);;
```
- 결과를 `OUT` 변수에 담거나 화면 출력처리를 하지 않았음에도 쿼리 결과가 클라이언트로 전송된다.
- 이는 JDBC 를 사용하는 자바에서도 그대로 이용이 가능하다.
- **하나의 스토어드 프로시저에서 2개 이상의 결과 셋을 반환할 수도 있음**
- 이런 기능은 프로시저의 **디버깅 용도** 로 주로 사용한다.
- 메세지를 화면에 출력하거나 별도 로그파일에 기록하는 기능은 제공하지 않음.
- `SIGNAL` 과 `RESIGNAL`  또는 `DIAGNOSTICS` 도 좋은 디버깅 방법이다.

#### 스토어드 프로시저 딕셔너리
- MySQL 8.0 이전까지 스토어드 프로시저는 `mysql.proc` 테이블에 저장되었다.
- 8.0 이후부터 사용자에게 보이지 않는 시스템 테이블로 저장된다.
- 사용자는 `information_schema.ROUTINES` 뷰를 통해서 조회만 할 수 있다.

```sql
SELECT routine_schema, routine_name, routine_type
FROM information_schema.ROUTINES
WHERE routine_schema='test';
```
- 이는 스토어드 프로시저와 스토어드 함수의 **메타 정보** 를 저장하고 있다.

### 스토어드 함수
- 스토어드 함수는 **하나의 SQL 문장으로 작성 불가능한 기능을 하나의 SQL 로 구현해야 할 때** 사용하는 기능
- 예를 들어 부서별 가장 최근에 배속된 사원 2명씩 가져오는 기능
  - 부서별 그루핑은 가능하지만, 최근 2명씩 가져오는 방법은 없다.
  - 이때 부서코드를 인자로 받아 최근 2명 사원만 SELECT 해 반환하는 삼수룰 만들어 사용하면 됨.
- **SQL 문장과 관계없이 별도로 실행되는 기능** 이라면 스토어드 함수를 개발할 필요가 없다.
  - 독립적으로 실행되어도 된다면 프로시저를 사용하는 것이 좋음.
  - 스토어드 함수가 상대적 제약사항이 많음.
  - 유일한 장점은 SQL 문장의 일부로 사용할 수 있다는 점

#### 스토어드 함수 생성 및 삭제
- 스토어드 함수는 `CREATE FUNCTION` 명령으로 생성 가능하며, 모든 파라미터는 읽기 전용이다.
  - `IN`, `OUT` 과 같은 형식 지정 불가
- 반드시 정의부에 `RETURNS` 키워드를 통해 반환 타입을 명시해야만 한다.
- 본문 마지막에 `RETURNS` 로 명시한 타입과 동일한 값을 반환해야 한다.

```sql
CREATE FUNCTION sf_sum(param1 INTEGER, param2 INTEGER)
    RETURNS INTEGER
BEGIN
    DECLARE param3 INTEGER DEFAULT 0;
    SET param3 = param1 + param2;
    RETURN param3;
END ;;
```
- 프로시저와 달리 함수의 본문에서는 다음과 같은 사항을 사용하지 못한다.
  - `PREARE` 와 `EXECUTE` 명령을 이용한 프리페어 스테이트먼트를 사용할 수 없음.
  - 명시적/묵시적 `ROLLBACK/COMMIT` 을 할 수 없음.
  - 재귀호출을 사용할 수 없음
  - 스토어드 함수 내에서 프로시저 호출 불가
  - 결과를 반환하는 SQL 문장 사용 불가
- 프로시저와 마찬가지로 `ALTER FUNCTION` 을 사용할 수 있으며, 제약사항은 프로시저와 동일하다.
- 파라미터나 내용 변경시 DROP&CREATE 형식으로 재 생성해야 한다.

#### 스토어드 함수 실행
- 스토어드 함수는 `CALL` 명령으로 실행할 수 없다.
- `SELECT` 문의 일부로만 실행할 수 있음

```sql
SELECT sf_sum(1, 2) AS sum;
```

### 트리거
- 트리거는 **테이블에 레코드가 저장되거나 변경될 때 미리 정의해둔 작업을 자동으로 실행해주는 스토어드 프로그램**
- 데이터 변화시 다른 작업을 기동해주는 **방아쇠** 역할 이다.
- MySQL 의 트리거는 INSERT/UPDATE/DELETE 시에 사용 할 수 있다
- 대표적으로 유효성 검사나 테이블 복사 및 백업 등에 사용한다.
- 트리거는 함수/프로시저에 비해 필요성이 떨어진다.
- 트리거가 생성되어 있으면 컬럼 추가 및 삭제시 성능이 떨어짐.
  - 컬럼추가시 임시 테이블레 데이터 복사 작업이 필요한데, 매 레코드 마다 트리거가 실행되기 때문
- MySQL 트리거는 **테이블** 에 대해서만 생성할 수 있다.
- 5.7 버전이전까지는 테이블당 하나의 이벤트만 가능했으나 5.7이후 동일 이벤트에 2개 이상의 트리거를 생성할 수 있다.
- `ROW` 포맷 바이너리 로그를 사용하는 경우 소스서버에서만 트리거가 실행되고, 레플리카서버에서는 실행되지 않는다.
- `STATEMENT` 포맷 바이너리 로그를 사용하는 경우 소스서버에서는 트리거가 실행되지 않고 레플리카서버에서만 실행된다.

> 동일한 결과를 만들어 내지만, 트리거 실행 위치가 다름

#### 트리거 생성
- 트리거는 `CREATE TRIGGER` 명령으로 실행한다.
- `BEFORE`, `AFTER` 키워드와 INSERT/UPDATE/DELETE 로 **트리거가 실행될 이벤트와 시점** 를 명시할 수 있다.
- 트리거 정의부 마지막에 `FOR EACH ROW` 키워드로 레코드 단위 트리거를 실행하게 할 수 있다.
- 예전에는 문장기반 트리거를 구현할 예정이었으나 제거 되었음 `FOR EACH STATEMENT`
- 트리거는 레코드 단위로만 동작하게 됨.

```sql
CREATE TRIGGER on_delete BEFORE DELETE ON employees
    FOR EACH ROW 
BEGIN
    DELETE FROM salaries WHERE emp_no = OLD.emp_no;
END ;;
```
- `BEFORE DELETE` 로 트리거가 언제 실행될지 명시 한다.
- `OLD` 키워드는 대상 테이블의 변경되기 전 레코드를 지칭하며, 변경될 레코드 지칭시 `NEW` 키워드를 사용한다.

`트리거 관련 이벤트`

| SQL 종류 | 발생 트리거 이벤트 |
| --- | --- |
| INSERT | BEFORE INSERT => AFTER INSERT |
| LOAD DATA | BEFORE INSERT => AFTER INSERT |
| REPLACE | BEFORE INSERT => AFTER INSERT (중복 레코드 없을시), BEFORE DELETE => AFTER DELETE => BEFORE INSERT => AFTER INSERT (중복 레코드 존재시) |
| INSERT INTO ... ON DUPLICATE SET | BEFORE INSERT => AFTER INSERT (중복 없을 시), BEFORE UPDATE => AFTER UPDATE (중복 있을시) |
| UPDATE | BEFORE UPDATE => AFTER UPDATE |
| DELETE | BEFORE DELETE => AFTER DELETE |
| TRUNCATE | 이벤트 발생하지 않음 |
| DROP TABLE | 이벤트 발생하지 않음 |

트리거의 BEGIN ... END 에서는 다음 유형의 작업들은 수행하지 않는다.
- 외래키 관계에 의해 자동변경되는 경우 호출되지 않는다.
- 명시적/묵시적 `ROLLBACK/COMMIT` 을 할 수 없음.
- `RETURN` 문을 사용할 수 없으며 트리거 종료시 `LEAVE` 명령 사용
- mysql, information_schema, performance_schema 데이터베이스에 존재하는 테이블에는 트리거 생성 불가

#### 트리거 실행
- 트리거는 동작을 확인하기 위해 명시적으로 실행할 방법이 없다.
- 해당 트리거를 동작시키는 조건을 직접 수행해야함 (INSERT/UPDATE 등..)

#### 트리거 딕셔너리
- MySQL 8.0 이전까지는 **해당 데이터베이스 디렉터리의 *.TRG 파일로 기록** 되었다.
- 8.0 버전 부터는 시스템 테이블로 통합되어 더이상 파일ㅇ로 저장하지 않는다.
- mysql 데이터베이스의 시스템 테이블에 저장되고 `information_schema.TRIGGERS` 뷰로 조회만 가능하다.

```sql
SELECT trigger_schema, trigger_name, event_manipulation, action_timing
FROM information_schema.TRIGGERS
WHERE trigger_schema='employees';
```
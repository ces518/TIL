# 지옥 스터디 - 10 쿼리 작성 및 최적화
- 애플리케이션 코드를 튜닝해 2배의 성능 향상을 한다는 건 쉽지 않은 일이다.
- 하지만 DBMS 에서 몇배 ~ 몇십배 성능 향상이 이뤄지는 것은 흔한일
- 때문에 SQL 처리에서 **어떻게 (How) 를 이해** 하고 쿼리를 작성하는 것이 중요하다. 

## 쿼리 작성과 관련된 시스템 변수
- 대소문자 구분과 같은 SQL 작성 규칙은 **MySQL 서버 시스템 설정** 에 따라 달라짐

### SQL 모드
- MySQL 서버의 `sql_mode` 설정은 여러 값이 동시에 설정될 수 있음
- SQL 문서 작성 규칙 뿐 아니라 자동으로 실행되는 데이터 타입 변환 및 기본값 제어 등과 관련된 옵션도 가지고 있다
- 사용자 테이블을 생성하고 데이터를 저장하기 시작했다면 옵션을 변경하지 않는 것이 좋음
- MySQL 8.0 기준 sql_mode 의 기본값은 다음과 같다
  - ONLY_FULL_GROUP_BY
  - STRICT_TRANS_TABLES
  - NO_ZERO_IN_DATE
  - NO_ZERO_DATE
  - ERROR_FOR_DIVISION_BY_ZERO
  - NO_ENGINE_SUBSTITUTION

`sql_mode options`

| 옵션 명 | 설명 |
| --- | --- |
| STRICT_ALL_TABLES & STRICT_TRANS_TABLES  | INSERT/UPDATE 문 수행시 저장되는 타입이 다른 경우 자동으로 타입 변경을 수행 <br/> `STRICT_TRANS_TABLES` 는 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드를 적용하고, `STRICT_ALL_TABLES` 는 이와 관계없이 모든 스토리지 엔진에 엄격한 모드를 적용한다 <br/> MySQL을 서비스 투입전 반드시 활성화 할 것을 권장 |
| ANTI_QUOTES | MySQL 은 문자열을 표현하기 위해 홑따옴표/쌍따옴표를 동시에 사용할 수 있음 <br/> 옵션 활성화시 홑따옴표만 문자열 값 표기로 사용할 수 있다. |
| ONLY_FULL_GROUP_BY | GROUP BY 절이 사용된 문장의 SELECT 절에는 GROUP BY 에 사용된 컬럼과 집계함수만 사용할 수 있다. 5.7 기준 기본값 비활성화, 8.0 기준 기본값 활성화 |
| PIPE_AS_CONCAT | MySQL 에서 &#124;&#124; 는 OR 연산자와 동일함. 옵션 활성화시 오라클과 동일하게 문자 연결 연산사로 사용할 수 있다 |
| PAD_CHAR_TO_FULL_LENGTH | MySQL 에서는 CHAR 타입이더라도 VARCHAR 와 같이 문자열 뒤의 공백문자는 제거되어 반환됨. 옵션 활성화시 문자 뒤의 공백문자가 제거되지 않고 반환됨 |
| NO_BACKSLASH_ESCAPES | 역슬래시를 이스케이프 문자로 사용할 수 있음. 옵션 활성화시 이스케이프 용도로 사용하지 못한다 |
| IGNORE_SPACE | 스토어드 프로시저나 함수명 사이 공백까지도 해당 이름으로 간주함. 옵션 활성화시 사이의 공백을 무시한다. 이는 **내장 함수에만 적용** 됨 |
| REAL_AS_FLOAT | MySQL 에서 부동소수점 타입은 FLOAT/DOUBLE 을 지원함. REAL 타입은 DOUBLE 타입의 동의어이다. 옵션 활성화시 FLOAT 타입의 동의어로 변경됨 |
| NO_ZERO_IN_DATE & NO_ZERO_DATE | 두 옵션 활성화 시 DATE/DATETIME 타입에 2020-00-00 과 같은 잘못된 날짜를 입력하지 못함 |
| ANSI | MySQL 서버가 최대한 ANSI 표준에 맞게 동작하게끔 만들어 준다. `REAL_AS_FLOAT`, `PIPES_AS_CONCAT`, `ANSI_QUOTES`, `IGNORE_SPACE`, `ONLY_FULL_GROUP_BY` 로 조합됨 |
| TRADITIONAL | STRICT_TRANS_TABLE/STRICT_ALL_TABLES 보다 더 엄격한 방법으로 동작을 제어함. `STRICT_TRANS_TABLES`, `STRICT_ALL_TABLES`, `NO_ZERO_IN_DATE`, `NO_ZERO_DATE`, `ERROR_FOR_DIVISION_BY_ZERO`, `NO_ENGINE_SUBSTITUTION` 로 조합됨 |

### 영문 대소문자 구분
- MySQL 서버는 기본적으로 **설치된 운영체제에 따라 테이블명의 대소문자를 구분** 한다.
  - DB 나 테이블은 디스크의 디렉터리/파일 로 매핑되기 때문
  - 유닉스 계열 운영체제에서 대소문자를 구분
  - 윈도우는 구분하지 않음
- `lower_case_table_names=1` 설정시 모두 소문자로만 저장하고, 대소문자를 구분하지 않게 동작한다.
  - 기본값 = 0
- 설정 자체를 떠나 가능하면 DB 생성시 대문자 혹은 소문자로만 통일해 사용하는 것이 좋음.

### MySQL 예약어
- 예약어를 사용하면 해당 칼럼이나 테이블을 SQL 에서 사용하기 위해 항상 백틱이나 쌍따옴표로 감싸주어야 한다.
- 테이블 생성시에는 항상 백틱으로 둘러싸지 않은 상태로 생성하길 권장
  - 에러나 경고가 무시될 수 있기 때문

## 메뉴얼의 SQL 문법 표기를 읽는 방법

```sql
 INSERT [LOW_PRIORITY | DELAYED | HIGH{PRIORITY ] [IGNORE]  
    [INTO] tbl_name
    SET col_name  = {expr | DEFAULT} ...
    [ON DUPLICATE  KEY UPDATE
        col_name = expr
        [, col_name = expr]....]
```

## MySQL 연산자와 내장함수
- 기본적인 연산자는 MySQL 에서도 비슷하게 사용되지만 MySQL 에서만 사용되는 연산자/표기법이 존재한다.
- ANSI 표준 형태가 아닌 것들이 많음
- 가능하면 SQL 작성시 ANSI 표준 연산자를 사용할 것을 권장한다.

### 리터럴 문자열 표기법

#### 문자열
- SQL 표준에서 문자열은 항상 홑따옴표를 사용해 표기하지만, MySQL 에서는 쌍따옴표를 사용해 표기할 수도 있다.
- 예약어의 경우 백틱을 사용해 충돌을 피할 수 있다.

```sql
SELECT * FROM departments WHERE dept_no = "d001";
```
- sql_mode 옵션에 `ANSI_QUOTES` 설정시 문자열 리터럴에 쌍따옴표를 사용할 수 없고, 예약어 충돌을 피하기 위해 쌍따옴표를 사용해야 한다.

#### 숫자
- 숫자 상수 값을 사용하려면 따옴표 없이 숫자를 입력하면 된다.
- 문자열 형태 따옴표를 사용하더라도, 타입이 일치하지 않는다면 자동 변환한다.

```sql
SELECT * FROM tab_test WHERE string_column = 10001;
```
- 두 비교대상이 문자열과 숫자 타입으로 다를 경우 자동변환이 발생한다.
- 숫자 타입과 문자타입 비교시 **숫자 타입을 우선** 하므로 문자열을 숫자로 변경한 뒤 비교를 수행한다.
- 위 쿼리의 경우 인덱스를 제대로 활용하지 못한다.
  - 문자컬럼과 숫자 상수의 비교
  - 문자컬럼의 값을 숫자로 변환한 뒤 비교를 수행하기 때문

> 주로 코드나 타입과 같은 값을 저장하는 컬럼에서 위와 같은 문제가 자주발생하므로 주의해야 함

#### 날짜
- MySQL 에서는 정해진 날짜 포맷으로 표기한다면 DATE/DATETIME 값으로 자동 변환하기 떄문에 STR_TO_DATE() 같은 함수를 사용하지 않아도 된다.

#### 불리언
- BOOL/BOOLEAN 이라는 타입이 존재하지만 사실 **TINYINT 타입의 동의어** 이다
- TRUE/FALSE 형태로 비교하거나 값을 저장할 수 있다.

### MySQL 연산자

#### 동등 비교
- 다른 DBMS 와 동일하게 "=" 기호로 비교를 수행하면 됨
- 추가적응로 동등 비교를 위해 "<=>" 연산자도 제공한다. 이는 "=" 와 동일하지만 부가적으로 NULL 값에 대한 비교까지 수행한다.
- 이를 **NULL-Safe 연산자** 라고 한다.
- NULL 은 기본적으로 IS NULL 연산자 외에는 비교할 방법이 없다
- Null-Safe 비교 연산자를 사용하면 양쪽 비교 대상모두 NULL 인 경우 TRUE, 한쪽만 NULL 인 경우 FALSE 를 반환한다.
- "<=>" 연산자는 NULL 을 하나의 값으로 인식하고 비교하는 방법

#### 부정 비교
- 같지 않다 비교를 위한 연산자는 "<>" 를 일반적으로 많이 사용한다.
  - != 도 사용 가능
- SQL 작성시 어느쪽을 사용해도 상관없지만 가독성을 위해 둘중 한가지 방법으로 통일해서 작성해야 한다

#### NOT 연산자
- TRUE/FALSE 연산의 결과를 부정하기 위해 NOT 을 사용한다.
  - ! 도 사용 가능
- 이는 불리언 뿐이 아닌 숫자나 문자에서도 사용할 수 있지만 결과를 정확히 예측할 수 없는경우 사용하지 않는 것을 권장한다.

#### AND OR 연산자
- MySQL 에서는 AND OR 뿐 아닌 && 과 || 도 허용한다
- sql_mode 옵션에 PIPE_AS_CONCAT 을 설정하면, 오라클과 동일하게 변경됨
- SQL 작성시 다른 용도로 사용될 수 있는 && 와 || 는 사용하지 않는 것이 좋다

#### 나누기와 나머지 연산자
- 나누기의 경우 일반적으로 알려진 "/" 연산자를 사용한다
- 나머지를 가져오는 연산자의 경우 "%" 또는 MOD 연산자를 사용한다

#### REGEXP 연산자
- 문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자
- `RLIKE` 는 `REGEXP` 와 동일한 비교를 수행한다.
- REGEXP 연산자의 정규표현식은 POSIX 표준으로 구현되어 있다
- REGEXP 를 단독으로 사용하는 경우 인덱스 레인지 스캔을 사용할 수 없다.

#### LIKE 연산자
- DBMS 에서는 단순 문자열 패턴 비교시 LIKE 연산자를 더 많이 사용한다
- LIKE 연산자를 인덱스를 활용할 수 있다
- 와일드카드 패턴을 지원함
  - %
  - _
- REGEXP 와 차이는, LIKE 의 경우 항상 비교 대상 문자열의 처음부터 끝까지 일치하는 경우에만 TRUE 를 반환한다
- 와일드카드가 검색어의 앞쪽에 위치한다면 **인덱스 레인지 스캔을 활용할 수 없다**

#### BETWEEN 연산자
- "크거나 같다" 와 "작거나 같다" 두 개의 연산자를 하나로 합친 연산자
- 다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의해야한다

```sql
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;
```
- BETWEEN 의 경우 d003 보다 크고 d005 보다 작은 레코드를 모두 스캔해야 한다.
- BETWEEN 과 IN 을 동일하게 생각하는 경우도 있는데, 이는 잘못된 생각
- IN 연산자의 경우 동등 비교 연산자와 비슷하다.
  - 여러 개의 동등 비교를 하나로 묶은 것과 같은 연산자
- 둘의 동작방식에는 차이가 있다

![MySQL Between In Index](./images/mysql_between_in_index.png)

- BETWEEN 은 선형으로 인덱스를 검색하는 반면, IN 은 동등 비교를 여러번 수행한다.
- 때문에 인덱스 앞쪽 컬럼의 선택도가 떨어지는 경우 IN 으로 변경해 성능을 개선하는 방법도 존재함

```sql
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;

SELECT * FROM dept_emp
WHERE dept_no IN ('d003', 'd004', 'd005') AND emp_no = 10001;
```
- 위 두 쿼리 모두 인덱스 레인지 스캔을 하지만, 실행 계획 떠보면 rows 의 레코드 건수는 큰 차이가 있음
- 8.0 버전 이전에는 BETWEEN 을 위와 같이 IN 쿼리로 변경하려면 해당 부서코드들을 조회한 뒤 직접 조건을 만들어 주어야 했다
- 하지만 8.0 버전 부터 IN (subquery) 형태로 자겅하면 세미조인 최적화를 사용해 더 빠른 쿼리로 변환해 준다

```sql
SELECT * dept_emp
WHERE dept_no IN (
    SELECT dept_no
    FROM departments
    WHERE dept_no BETWEEN 'd003' AND 'd005'
) AND emp_no = 10001;
```

#### IN 연산자
- IN 연산자는 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
- 범위 검색이 아닌, 여러 번의 동등비교를 수행하기 때문에 일반적으로 빠륵 ㅔ처리된다.
- 8.0 이전까지는 IN 절에 튜플 (레코드) 를 사용하면 항상 풀 테이블 스캔을 사용했다
  - 8.0 이후 개선됨
- NOT IN 의 경우 인덱스 풀 스캔이 일어난다.
  - 동등이 아닌 부정 비교이기 때문에 인덱스를 이용해 범위조건을 줄일 수 없다

### MySQL 내장 함수
- 기본적인 기능의 함수는 대부분 동일하게 제공된다
- **함수명이나 사용법은 표준이 없기 때문에 DBMS 별로 호환되지 않음**
- MySQL 의 함수는 기본적으로 제공하는 **내장 함수** 와 **사용자 정의 함수 (UDF User Defined Function)** 으로 구분된다

#### NULL 값 비교 및 대체 (IFNULL, ISNULL)
- `IFNULL()` 함수는 칼럼이나 표현식의 값이 NULL 인지 비교하고, NULL 인 경우 다른 값으로 대체한다
  - 첫번째 인자가 NULL 이아니면 첫번째 인자의 값을, 아니라면 두번째 인자의 값을 반환
- `ISNULL()` 함수는 칼럼이나 표현식의 값이 NULL 인지 비교하는 한다

#### 현재 시각 조회 (NOW, SYSDATE)
- 현재의 시간을 반환하는 함수
- 하나의 SQL 에서 모든 NOW() 함수는 항상 같은 값을 가진다
- 하지만 SYSDATE() 함수는 호출 시점에 따라 결괏 값이 달라지므로 유의해야한다
  - `sysdate_is_now` 시스템 변수를 활성화 하면 NOW() 와 동일하게 동작

> 레플리카 서버에서 안정적으로 복제되지 않기 때문에 유의

#### 날짜와 시간의 포맷 (DATE_FORMAT, STR_TO_DATE)
- DATETIME 타입의 컬럼이나 값을 원하는 형태의 문자열로 변환하려면 `DATE_FORMAT()` 함수를 사용
- 날짜 포맷변경을 위한 지정자는 모두 **대소문자를 구분** 하므로 유의
- SQL 표준 형태 (년-월-일 시:분:초) 인 문자열을 필요시 자동으로 타입변환이 일어난다
  - DATETIME 타입

#### 날짜와 시간의 연산 (DATE_ADD, DATE_SUB)
- 특정 날짜에서 연도나 월일 또는 시간 등을 더하거나 뺄때 `DATE_ADD()`, `DATE_SUB()` 함수를 사용
  - DATE_SUB() 은 크게 쓸일이 없음
  - DATE_ADD() 로 모든 처리가 가능함
- 첫 번째 인자는 연사를 수행할 날짜, 두번 째는 더하거나 빼고자하는 월/일의 수

#### 타임스탬프 연산 (UNIX_TIMESTAMP, FROM_UNIXTIME)
- `UNIX_TIMESTAMP()` 함수는 '1970-01-01 00:00:00' 으로부터 경과된 초를 반환하는 함수
- 함수 인자가 없는 경우 현재 날짜와 시간의 타임스탬프 값을 반환하고, 특정 날짜를 입력하면 해당 날짜와 시간의 타임스탬프를 반환한다

> TIMESTAMP 타입은 4바이트 숫자 타입으로 저장된다. <br/>
> 때문에 실제 값의 범위는 1970-01-01 00:00:01 ~ 2038-01-09 03:14:07 까지 날짜값만 가능하다

#### 문자열 처리 (RPAD, LPAD / RTRIM, LTRIM, TRIM)
- `RPAD()`, `LPAD()` 함수는 문자열 좌측 혹은 우측에 문자를 덧붙여 지정된 길이의 문자열로 만드는 함수
  - 첫번째 인자는 패딩 처리를할 문자열
  - 두번째 인자는 몇 바이트까지 패딩할 것인지
  - 세번째 인자는 어떤 문자를 패딩할 것인지를 의미
- `RTRIM()`, `LTRIM()` 함수는 문자열 우측 혹은 좌측에 연속된 공백 문자를 제거하는 함수
- `TRIM()` 함수는 위 두 함수의 처리를 동시에 수행하는 함수

#### 문자열 결합 (CONCAT)
- 여러 문자열을 연결해 하나의 문자열로 반환하는 함수
- 숫자를 인자로 전달하면 문자열 타입으로 변환한 후 처리한다
- 명시적으로 `CAST()` 함수를 이용해 타입을 문자열로 변환하는 것이 안전함
- 유사한 함수로 `CONCAT_WS()` 함수가 있다

#### GROUP BY 문자열 결합 (GROUP_CONCAT)
- COUNT(), MAX(), MIN(), AVG() 등과 같이 그룹 함수 중 하나이다
- `GROUP_CONCAT()` 함수는 값을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중 중복을 제거하고 연결하는 것도 가능하다.
  - 주로 GROUP BY 와 함께 사용한다
- 지정한 값들을 연결하기 위한 메모리 버퍼 공간을 사용한다.
  - `group_concat_max_len` 시스템 변수
  - 해당 크기를 초과할 경우 경고 메세지가 발생한다
  - 기본값은 1KB

#### 값의 비교와 대체 (CASE WHEN.. THEN.. END)
- CASE WHEN 은 프로그래밍 언어에서 제공하는 `SWITCH` 구문과 같은 역할을 수행한다.

#### 타입의 변환 (CAST, CONVERT)
- **프리페어 스테이트먼트 (Prepared Statement)** 를 제외하면 SQL 은 문자열 기반으로 동작하기 때문에 모든 입력값은 문자열 처럼 취급된다.
- 명시적인 타입 변환이 필요한 경우 `CAST()` 함수를 사용하면 된다.
  - `CONVERT()` 도 이와 비슷하다.
- 변환 가능한 데이터 타입은, **DATE, TIME, DATETIME, BINARY, CHAR, DECIMAL, SIGNED INTEGER, UNSIGNED INTEGER** 이다.
- MySQL 의 자동변환중 SIGNED, UNSIGNED 같이 부호가 있거나 없는 정수 값의 변환은 자동으로 이뤄지지 못하는 경우가 많음
- 그런 경우 명시적인 타입 변환을 해야함
- `CONVERT()` 는 타입 변환 외에도 **문자 집합을 변환하는 용도** 로도 사용할 수 있다.

#### 이진값과 16진수 문자열 (Hex String) 변환 (HEX UNHEX)
- `HEX()` 함수는 이진값을 사람이 읽을 수 있는 16진수 문자열로 변환하는 함수
- `UNHEX()` 는 16진수 문자열을 이진값으로 변환하는 함수
- 여기서의 이진값은 바이너리 값이다.

#### 암호화 및 해시함수 (MD5, SHA, SHA2)
- `SHA()` 함수는 SHA-1 암호화 알고리즘을 사용
- `SHA2()` 함수는 SHA 알고리즘 보다 강력한 224 ~ 512 비트 알고리즘을 사용
- `MD5()` 함수는 메세지 다이제스트 알고리즘을 사용해 128 비트 해시값을 반환한다.
  - MD5 는 문자열 길이를 줄이는 용도
- 위 3가지 함수는 모두 중복 가능성이 매우 낮기 때문에 긴 데이터의 크기를 줄여 인덱싱 하는 용도로도 사용된다.

#### 처리 대기 (SLEEP)
- `SLEEP()` 함수는 프로그래밍 언어나 셸 스크립트에서 제공하는 SLEEP 기능을 제공
- SQL 개발이나 디버깅 용도로 사용한다

#### 벤치마크 (BENCHMARK)
- `BENCHMARK()` 함수는 디버깅이나 간단한 함수 성능 테스트용으로 유용한 함수이다.
  - 첫 번째 인자는 반복해서 수행할 횟수
  - 두 번째 인자는 반드시 스칼라 값을 반환하는 쿼리
- 쿼리를 직접 수행하는것과 벤치마크 함수를 사용하는 것은 큰 차이가 있음
- 벤치마크함수를 사용하면, 벤치마크 횟수와 관계없이 단 1번의 네트워크, 쿼리 파싱 및 최적화 비용이 소요된다.

> 벤치마크 함수로 얻은 성능은 큰 의미가 없다. 두 개의 동일한 기능을 상대적으로 비교 분석하는 용도로 사용할 것을 권장한다.

#### IP 주소 변환 (INET_ATON, INET_NTOA)
- `INET_ATON()`, `INET_NTOA()` 함수로 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장가능하게 제공한다.
  - INET_ATON() 함수는 IPv4 주소를 정수형으로 변환하는함수
  - INET_NTOA() 함수는 정수형의 IPv4 주소를 . 으로 구분된 문자열로 변환하는 함수
- `INET6_ATON()`, `INET6_NTOA()` 함수로 IPv6 주소도 지원한다
  - 위 두 함수로 저장시 바이너리 값을 저장할 수 있는 타입을 사용해야 함

#### JSON 포맷 (JSON_PRETTY)
- `JSON_PRETTY()` 함수를 이용하면 JSON 컬럼의 값을 읽기 쉬운 포맷으로 변환해 준다.

#### JSON 필드 크기 (JSON_STORAGE_SIZE)
- MySQL 서버는 JSON 데이터 저장시 **BSON (Binary JSON)** 포맷을 사용한다
  - 디스크 저장공간 절약을 위함
- `JSON_STORAGE_SIZE()` 함수는 BSON 으로 변환시 크기를 확인을 위함

#### JSON 필드 추출 (JSON_EXTRACT)
- `JSON_EXTRACT()` 함수는 JSON 도큐먼트에서 특정 필드 값을 가져오는 방법중 가장 일반적인 방법
  - 첫 번째 인자는 JSON 데이터
  - 두 번째 인자는 JSON 경로
- `JSON_EXTRACT()` 의 결과는 따옴표가 붙은 상태로 반환된다. `JSON_UNQUOTE()` 를 사용하면 따옴표가 제거된 값만 가져올 수 있음
- 또한 사용자 편의를 위한 연산자를 추가적으로 제공한다.

```sql
SELECT emp_no, doc->>"$.first_name" FROM employee_docs LIMIT 2;
```
- `->` 연산자는 JSON_EXTRACT() 와 동일
- `->>` 연산자는 JSON_UNQUOTE() 와 JSON_EXTRACT() 를 조합한 것과 동일

#### JSON 오브젝트 포함 여부 확인 (JSON_CONTAINS)
- JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 포함하고 있는지 확인하는 함수

#### JSON 오브젝트 생성 (JSON_OBJECT)
- RDBMS 컬럼 값을 이용해 JSON 오브젝트를 생성하는 함수

#### JSON 컬럼으로 집계 (JSON_OBJECTAGG & JSON_ARRAYAGG)
- GROUP BY 절과 함께 사용되는 집계 함수
- RDBMS 칼럼 값들을 모아 JSON 배열이나 도큐먼트를 생성하는 함수이다.

#### JSON 데이터를 테이블로 변환 (JSON_TABLE)
- JSON 데이터 값들을 모아 RDBMS 테이블로 만들어 반환하는 함수
- 해당 함수가 반환하는 테이블의 레코드 건수는 원본 테이블과 동일한 레코드 건수를 가짐
- 이는 **항상 내부 임시테이블을 사용** 하기 때문에 유의

## SELECT
- 일반적인 온라인 트랜잭션 처리환경의 경우 INSERT/UPDATE 는 레코드 단위로 발생하기 때문에 성능상 문제가 되는 경우는 드물다.
- 하지만 SELECT 쿼리의 비율은 높음 이에 관련해서 성능 위주로 살펴봄

### SELECT 절 처리 순서

![MySQL SELECT QUERY](./images/mysql_select_query_order.png)
- 대부분의 경우 위 순서가 바뀌어 실행되는 쿼리는 거의 없다.
- SQL 에 ORDER BY, GROUP BY 가 있더라도 인덱스 를 이용해 처리한다면 불필요한 단계가 되므로 생략됨

![MySQL SELECT QUERY](./images/mysql_select_query_order_v2.png)
- 위 경우는 예외적인 순서로 실행되는 경우이다
- 첫 번째 테이블만 읽어 정렬이후 나머지 테이블을 읽는데, 주로 GROUP BY 없이 ORDER BY 만 사용된 쿼리에서 보이는 순서

### WHERE, GROUP BY, ORDER BY 의 인덱스 사용
- WHERE 절 뿐만 아니라 GROUP BY, ORDER BY 에서도 인덱스를 사용해 빠른 처리가 가능하다.

#### 인덱스 사용을 위한 기본 규칙
- WHERE, GROUP BY, ORDER BY 가 인덱스를 사용하려면 **인덱스된 칼럼의 값을 변환하지 않고 그대로 사용** 해야한다.
- WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교대상 값은 **데이터 타입이 일치** 해야 한다.
- 저장하고자 하는 값의 타입에 맞춰 칼럼 타입을 선정하고, SQL 작성시 데이터 타입에 맞춰 비교 조건을 사용하는 것을 권장한다.

#### WHERE 절의 인덱스 사용
- WHERE 조건이 인덱스를 사용하는 방법은 **작업 범위 결정 조건** 과 **체크 조건** 두 가지로 구분할 수 있다.
- 작업 범위 결정 조건은, 동등 비교조건이나 IN 으로 구성된 조건에서 칼럼들이 인덱스 칼럼 구성과 좌측부터 비교했을때 얼마나 일치하는지에 따라 달라진다.

![MySQL Where Index Rule](./images/mysql_where_index_rule.png)
- 각 조건이 AND 로 연결되어 있다면 레코드 건수를 줄이는 역할을 하지만, OR 로 연결되어 있다면 비교할 레코드가 더 늘어나기 때문에 주의해야 함

#### GROUP BY 절의 인덱스 사용
- GROUP BY 절의 각 칼럼은 비교 연산자를 가지지 않으므로 작업범위 결정 조건 등을 생각할 필요가 없다.
- 명시된 칼럼의 순서가 인덱스를 구성하는 순서와 동일하다면 인덱스를 사용할 수 있다.

![MySQL Group By Index Rule](./images/mysql_group_by_index_rule.png)

#### ORDER BY 절의 인덱스 사용
- GROUP BY 와 ORDER BY 의 처리는 상당히 비슷하다.
- 인덱스 사용여부도 거의 흡사하지만 추가적인 조건이 하나 더 있다.
- 각 컬럼의 **오름차순 및 내림차순 옵션이 인덱스와 같거나 정 반대인 경우에만 사용** 할 수 있다.
- MySQL 은 모든 칼럼이 오름차순으로 정렬되어 있기 때문에 ORDER BY 절의 모든 컬럼이 오른차순이거나 내림차순 일때만 인덱스를 사용할 수 있다.

![MySQL Order By Index Rule](./images/mysql_order_by_index_rule.png)

#### WHERE 조건과 ORDER BY (GROUP BY) 절의 인덱스 사용
- SQL 문이 WHERE, ORDER BY 절이 가지고 있다고 가정했을때, WHERE 는 A 인덱스를 사용하고, ORDER BY 는 B 인덱스를 사용하도록 쿼리가 실행될 수는 없다.
- 같이 사용된 하나의 쿼리의 문장은 다음 3가지 중 한가지 방법으로만 인덱스를 사용한다.

`WHERE 절과 ORDER BY 절이 동시에 같은 인덱스 사용`
- 두 가지가 하나의 인덱스를 사용한다.
- 나머지 두 방식보다 빠른 성능을 보이기에 가능하면 이 방식을 사용하도록 튜닝하는 것이 좋음

`WHERE 절만 인덱스 사용`
- ORDER BY 는 인덱스를 사용해 정렬이 불가능 하다.
- 검색 결과 렠도르르 별도의 정렬을 통해 정렬을 수행한다.
- WHERE 조건에 일치하는 레코드가 적은 경우 효율적이다.

`ORDER BY 절만 인덱스 사용`
- ORDER BY 순서대로 인덱스를 읽으며 레코드를 한건씩 WHERE 조건에 비교하고 버리는 형태로 처리한다.
- 주로 아주 많은 레코드를 읽어 정렬해야 하는경우 선택하는 방법

#### GROUP BY 절과 ORDER BY 절의 인덱스 사용
- GROUP BY 와 ORDER BY 가 동시에 사용된 쿼리에서 모두 하나의 인덱스를 사용해 처리하려면 두 가지모두 순서와 내용이 같아야한다.
- 5.7 버전까지는 GROUP BY 의 경우 GROUP BY 컬럼에 대한 정렬까지 수행하는 것이 기본 동작방식 이었다.
- 8.0 버전부터는 정렬까지는 보장하지 않는 형태로 바뀌었다.
  - 그루핑과 정렬을 모두 수행하기 위해서는 두가지 절 모두 명시해야 함

#### WHERE 조건과 ORDER BY, GROUP BY 의 인덱스 사용
- WHERE, GROUP BY, ORDER BY 가 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법
1. WHERE 절이 인덱스를 사용할 수 있는가 ?
2. GROUP BY 절이 인덱스를 사용할 수 있는가 ?
3. GROUP BY, ORDER BY 가 동시에 인덱스를 사용할 수 있는가 ?

![MySQL Where Group By Order By](./images/mysql_where_order_by_group_by_index_rule.png)

### WHERE 절의 비교 조건 사용시 주의사항

#### NULL 비교
- MySQL 에서는 NULL 이 포함된 레코드도 인덱스로 관리됨
  - 인덱스에서는 NULL 도 하나의 값으로 인정한다는 의미
- 쿼리에서 NULL 인지 비교하려면 `IS NULL 또는 <=> 연산자` 를 활용해야 함
- `ISNULL()` 함수도 제공하는데 이는 주의할 점이 있다.

```sql
SELECT * FROM titles WHERE to_date IS NULL;
SELECT * FROM titles WHERE ISNULL(to_date);
SELECT * FROM titles WHERE ISNULL(to_date)=1;
SELECT * FROM titles WHERE ISNULL(to_date)=true;
```
- 위 쿼리는 모두 NULL 인지 판별해 내는 쿼리
- 하지만 3/4번 째 의 경우 인덱스를 활용하지 못한다
- NULL 비교시 가급적 IS NULL 연산자 사용을 권장

#### 문자열이나 숫자 비교
- 문자열 이나 숫자를 비교할 때는 반드시 타입에 맞는 상수 사용을 권장
- 옵티마이저가 어떤 경우에 어떻게 타입변환을 유도하는지 아는것도 중요하지만, 칼럼 타입에 맞게 상수 리터럴 비교를 사용하는 것이 중요

#### 날짜 비교
- MySQL 에는 날짜만 저장하는 DATE 타입과 날짜와 시간을 함께 저장하는 DATETIME/TIMSTAMP 가 있고, 시간만 저장하는 TIME 타입도 있다.

`DATE 또는 DATETIME 과 문자열 비교`
- 문자열 값을 자동으로 DATETIME 타입 값으로 변환해 비교를 수행한다.
- 인덱스를 효율적으로 사용하려면 **컬럼 원본 값을 변형해서는 안됨**

`DATE 와 DATETIME 의 비교`
- DATETIME 과 DATE 의 비교에서 타입 변환은 인덱스 사용 여부에 영향을 미치지 않는다.
- 때문에 성능보단 쿼리의 결과에 주의할 것

`DATETIME 과 TIMESTAMP 의 비교`
- DATE/DATETIME 과 TIMESTAMP 비교시 잘 동작하고, 실행 계획도 **인덱스 레인지 스캔을 사용하는 것 같지만 사실은 그렇지 않음**
- 반드시 비교값으로 사용되는 상수 리터럴을 비교 대상 칼럼의 타입에 맞게 변환해 사용해야 ㅏㄴ다
- 칼럼이 DATETIME 이라면 FROM_UNIXTIME() 함수로 TIMESTAMP 를 DATETIME 으로 변환한 뒤 비교해야 한다.

#### Short-Circuit Evaluation
- 여러 개의 표현식이 AND/OR 처럼 논리연산자로 이어진 경우
- 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말것인지 결정하는 최적화 이다.
- 일반적인 프로그래밍 언어처럼 MySQL 에서도 동일하게 동작한다.
- 단, WHERE 절의 조건중 인덱스 사용 가능한 조건이 있다면 이와 무관하게 그 조건을 최우선으로 사용한다.
- WHERE 절에 나열된 순서에 인덱스 사용여부를 결정짓지 않음.
- MySQL 에서 쿼리 작성시 가능하면 복잡한 연산이나 다른 테이블을 읽어야 하는 서브쿼리 등은 WHERE 의 뒤쪽에 배치하는 것이 성능상 도움이 됨

### DISTINCT
- DISTINCT 를 남발하는 것은 성능적인 문제도 있지만, 쿼리의 결과도 의도한 것과 달라질 수 있으므로 주의해야 한다.

### LIMIT n
- MySQL 의 LIMIT 은 WHERE 조건이 아니기 때문에 **항상 쿼리의 마지막에 실행** 된다.
- 중요한 특성은, 필요한 레코드 건수만 준비된다면 즉시 쿼리를 종료한다.
- 정렬이 필요한 쿼리에서 모든 레코드의 정렬이 끝나지 않더라도 상위 n 건 까지만 정렬된다면 작업을 멈춘다.
> DISTINCT 가 인덱스를 이용해 처리할 수 있다면, LIMIT 은 쿼리 작업량을 상당히 줄여줆
- LIMIT 의 제한 사항은 인자로 표현식이나 서브쿼리를 사용할 수 없다는 점
- 실제 쿼리 성능은 레코드 가 몇건 출력되느냐 보다 그 **결과를 만들기 위해 어떤 작업을 했는지가 중요** 하다.

### COUNT()
- `COUNT()` 함수는 결과 레코드 건수를 반환하는 함수
- `*` 를 사용하는 경우도 잇는데 이는 모든 컬럼을 가져오라는 의미가 아닌 그냥 레코드 자체를 의미한다.
- COUNT(1) 과 같이 처리하지 않아도 동일한 처리 성능을 보여준다.
- COUNT 쿼리에서 가장 많이하는 실수는 ORDER BY 나 LEFT JOIN 같은 레코드 건수를 가져오는 것과는 무관한 작업을 포함하는 것이다.
- COUNT 함수에 칼럼이나 표현식이 인자로 사용되는 경우 NULL 이 아닌 레코드 건수만 반환하므로 유의할 것

> MySQL 8.0 부터는 COUNT 쿼리에 포함된 ORDER BY 는 무시하도록 개선됨

### JOIN

#### JOIN 순서와 인덱스
- 인덱스 레인지 스캔은 **인덱스 탐색 (Index Seek)** 과 **인덱스 스캔 (Index Scan)** 과정으로 구분할 수 있다.
- 인덱스 스캔 작업은 부하가 작지만, 특정 인덱스 키를 찾는 탐색 작업은 상대적인 부하가 큰 편이다.
- 드라이빙 테이블과 드리븐 테이블이 1:1 조인되더라도, 드리븐 테이블을 읽는 것이 더 큰 부하를 차지함
  - 드리븐 테이블은 드라이빙 테이블에서 읽은 레코드 건수 * (인덱스 탐색 + 스캔 작업) 을 수행함. 
  - 때문에 항상 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.

#### JOIN 칼럼의 데이터 타입
- WHERE 절에 사용되는 조건에서 비교 대상 칼럼과 표현식의 데이터 타입을 반드시 동일하게 사용해야 한다.
- 이는 테이블 조언에서도 동일하다.
- 인덱스를 사용하려면, 양쪽항의 데이터 타입을 일치시켜야 한다.
- 단 영향을 미치지 않는 타입 도 존재한다.
  - CHAR 와 VARCHAR
  - INT 와 BIGINT
  - DATE 와 DATETIME

#### OUTER JOIN 의 성능과 주의사항
- 이너 조인은 **조인 대상 테이블에 모두 존재하는 레코드만 결과 집합으로 반환** 한다.
- MySQL 옵티마이저는 절대로 **아우터 조인되는 테이블을 드라이빙 테이블로 선택하지 못한다.**
  - 최적화 기회를 놓치는 경우가 될 수 있음
- 반드시에 필요한 경우에만 사용할 것을 권장함.
- 또 다른 문제는 아우터 조인 되는 테이블에 대한 조건을 WHERE 절에 함께 명시하는 것

```sql
SELECT *
FROM employees e
LEFT JOIN dept_manager mgr ON mrg.emp_no = e.emp_no
WHERE mgr.dept_no = 'd001';
```
- 이는 잘못된 조인 방법
- 옵티마이저는 WHERE 절 조건때문에 LEFT JOIN 을 INNER JOIN 으로 변환해 실행해 버린다.
- 예외적으로 이런 조인이 필요한 경우가 있는데, 이는 **안티 조인** 효과를 기대하는 경우이다.

```sql
SELECT * 
FROM employees e
LEFT JOIN dept_manager dm ON dm_emp_no = e.emp_no
WEHRE dm.emp_no IS NULL 
LIMIT 10;
```
- 위와 같은 형태만이 유일한 경우이므로 주의 할 것.

#### JOIN 과 외래키
- 외래키는 조인과 아무런 관련이 없다.
- 외래키 생성의 주 목적은 데이터 무결성을 보장하기 위함
- 외래키와 연관된 무결성을 참조 무결성 이라고 한다.

#### 지연된 조인 (Delayed Join)
- 조인을 사용하는 쿼리에서 인덱스를 사용하지 못한다면, 우선 모든 조인을 실행하고, GROUP BY 나 ORDER BY 를 실행한다.
- 지연된 조인은 조인 실행이전 GROUP BY / ORDER BY 를 실행 시키는 방식을 말한다.
- 주로 LIMIT 을 사용한 쿼리에서 더 큰 효과를 얻을 수 있음

```sql
SELECT e.*
FROM salaries s, employees e
WHERE e.emp_no = s.emp_no
AND s.emp_no BETWEEN 10001 AND 13000
GROUP BY s.emp_no
ORDER BY SUM(s.salary) DESC
LIMIT 10;
```
- 위 쿼리는 레코드 3천건을 읽고, 조인을 수행한다.
  - 수행 횟수는 12,000 번  (3000 * 4)
- 조인 결과를 임시테이블에 저장한 뒤 GROUP BY 로 3천건으로 줄이고 ORDER BY 로 상위 10건만 반환한다.

```sql
SELECT e.*
FROM (
     SELECT s.emp_no
     FROM salaries s
     WHERE s.emp_no BETWEEN 10001 AND 13000
     GROUP BY s.emp_no
     ORDER BY SUM(s.salary) DESC
     LIMIT 10) x,
     employees e
WHERE e.emp_no = x.emp_no;
```
- 위 쿼리는 지연된 조인으로 변경한 쿼리이다.
- 모든 처리를 salaries 테이블에서만 수행하고, 최종 10건만 employees 테이블과 조인하도록 변경 했다.
  - 10건을 읽어 조인을 10번만 수행함
- 조인 횟수를 비교해 보면 지연된 조인으로 변경된 쿼리보다 조인 횟수가 훨씬 적다.
- 잘 튜닝된 지연 쿼리는 기존 쿼리보다 몇십배 몇백배 더 나은 성능을 보일 수도 있다.
- 지연 쿼리는 다음 과 같은 조건이 갖춰져야만 사용이 가능하다
1. LEFT JOIN 인 경우 드라이빙/드리븐 테이블은 1:1 혹은 M:1 관계여야 한다.
2. INNER JOIN 인 경우 드라이빙/드리븐 테이블은 1:1 또는 M:N 인 동시에 드라이빙 테이블에 존재하는 레코드는 모두 드리븐 테이블에도 존재해야 한다.

#### 래터럴 조인
- 8.0 버전부터는 래터럴 조인 기능이 추가되 **특정 그룹별로 서브쿼리를 실행해 그 결과와 조인이 가능** 해 졌다.

```sql
SELECT *
FROm employees e
LEFT JOIN LATERAL (
    SELECT * FROM salaries s
    WHERE s.emp_no = e.emp_no
    ORDER BY s.from_date DESC LIMIT 2) s2
ON s2.emp_no = e.emp_no
WHERE e.first_name = 'Matt';
```
- 래터럴 조인에서 가장 중요한 부분은 **FROM 절에 사용된 서브 쿼리가 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것**
- LATERAL 키워드를 가진 서브 쿼리는 조인 순서상 **후순위** 로 밀리고 외부 쿼리 결과 레코드 단위로 **임시테이블이 생성** 되기 때문에 반드시 필요한 경우에만 사용해야 함

#### 실행 계획으로 인한 정렬 흐트러짐
- 8.0버전 부터는 해시조인 방식이 도입됨
- 해시 조인이 사용되면 쿼리 결과의 레코드 정렬 순서가 달라진다.

### GROUP BY

#### WITH ROLLUP
- GROUP BY 가 사용된 쿼리에서 그루핑된 그룹별로 소계를 가져올 수 있는 기능
- 엑셀의 피벗 테이블과 거의 동일한 기능이다.
- WITH ROLLUP 과 함께 사용된 GROUP BY 쿼리 결과는 그룹별 소계를 출력하는 레코드가 추가되어 표시된다.
- 소계 레코드의 칼럼값은 항상 NULL 로 표시되므로 주의해야 함

```sql
SEELCT dept_no, COUNT(*)
FROM dept_emp
GROUP BY dept_no WITH ROLLUP;
```

| dept_no | COUNT(*) |
| --- | --- |
| d001 | 20211 |
| d002 | 17346 |
| NULL | 331603 |

- 8.0 버전 부터는 그룹에 표시되는 NULL 을 사용자가 변경 가능하도록 `GROUPING()` 함수를 제공한다.

### ORDER BY
- ORDER BY 절이 사용되지 않으면 SELECT 쿼리는 어떤 순서로 정렬되는가 ?
  - 인덱스를 사용한 경우라면 인덱스에 정렬된 순서대로 레코드를 가져온다.
  - 풀테이블 스캔의 경우 기본적으로 PK 순서대로 레코드를 가져온다.
  - 임시 테이블을 거쳐 처리되면 조회되는 순서를 예측하기 어렵다.
- ORDER BY 절이 없는 SELECT 쿼리 결과의 순서는 처리 절차에 따라 달라질 수 있다.
- 어떤 DBMS 도 ORDER BY 절이 없는 쿼리에 대해서는 어떠한 정렬도 보장하지 않는다.
- ORDER BY 가 인덱스를 사용하지 못하면 Extra "Using filesort" 코멘트가 표시되며 MySQL 서버가 명시적인 정렬을 수행했다는 의미

#### ORDER BY 사용법 및 주의사항
- ORDER BY 는 1개 또는 그 이상의 여러 칼럼으로 정렬을 수행할 수 있고, 정렬 순서대로 제각각 명시가 가능하다.
- ORDER BY 2 와 같이 명시하면 SELECT 컬럼 중 2번째 칼럼으로 정렬하라는 의미가 된다.
- 하지만 ORDER BY 뒤에 숫자 값이 아닌 문자열 상수가 사용되는 경우 옵티마이저는 ORDER BY 절 자체를 무시하므로 주의해야 한다.

```sql
SELECT firat_name, last_name 
FROM employees
ORDER BY 'last_name';
```

#### 여러 방향으로 동시 정렬
- MySQL 8.0 이전까지는 각 컬럼의 정렬 순서가 오름차순/내림차순 혼용되면 인덱스 사용이 불가능 했다.
- 8.0버전 부터는 이를 혼용해 인덱스 생성이 가능하도록 개선 되었다.

```sql
ALTER TABLE salaries ADD INDEX ix_salary_fromdate (salary DESC, from_date ASC);
```

#### 함수나 표현식을 이용한 정렬
- 8.0 이전까지는 연산의 결과를 기준으로 정렬하기 위해 **가상 칼럼** 을 추가하고 인덱스를 생성해야 했다.
- 8.0 버전 부터는 함수 기반 인덱스를 지원한다.

### 서브쿼리
- 5.6 버전까지는 서브쿼리를 최적으로 실행하지 못할 때가 많았지만 8.0 버전부터는 서브쿼리 처리가 많이 개선되었다.

#### SELECT 절에 사용된 서브쿼리
- SELECT 절의 서브쿼리는 임시테이블을 생성하거나 쿼리를 비효율적으로 실행하진 않는다.
- 때문에 서브쿼리가 인덱스를 사용한다면 크게 주의할 사항은 없다.
- 일반적으로 SELECT 절의 서브쿼리는 **항상 칼럼과 레코드가 하나인 결과를 반환** 해야 한다.
- SELECT 절에서는 로우 서브쿼리를 사용할 수 없고, 스칼라 서브쿼리만 사용할 수 있다.

#### FROM 절에 사용된 서브쿼리
- MySQL 은 FROM 절 서브쿼리가 사용되면 항상 서브쿼리 결과를 임시테이블에 저장했다.
- 하지만 5.7 버전부터는 옵티마이저가 외부 쿼리로 병합하는 최적화룰 수행하도록 개선되었다.
- FROM 절의 모든 서브쿼리를 병합할 수 있는것은 아니며 대표적으로 다음 기능들은 병합하지 못한다.
  - 집합 함수가 사용된 경우
  - DISTINCT
  - GROUP BY / HAVING
  - LIMIt
  - UNION / UNION ALL
  - SELECT 절에 서브쿼리가 사용된 경우
  - 사용자 변수 사용

#### WHERE 절에 사용된 서브쿼리
- WHERE 절 서브쿼리는 다양한 형태로 사용될 수 있는데 크게 3가지로 구분해 살펴 본다.

`동등 또는 크다 작다 비교`
- 5.5 이전까지는 서브쿼리 외부의 조건으로 쿼리를 실행하고, 서브쿼리를 체크조건으로 사용했다
- 때문에 풀 테이블스캔이 많이 발생해 성능 저하가 심각했음
- 5.5 버전부터는 이전과 반대로 실행되도록 개선되었다.
- 서브쿼리를 먼저 실행항 후 상수 변환해 나머지를 처리한다.

> 단일 값 비교가 아닌 튜플 비교의 경우 외부 쿼리 인덱스를 사용하지 못하는 문제가 있다. (풀 테이블 스캔 발생)

`IN 비교`
- 조인은 아니지만 다른 테이블의 레코드를 이용한 표현식과 일치하는지 체크하는 방식을 **세미 조인** 이라고 한다.
  - WHERE IN (subquery) 도 세미 조인
- 5.5 버전까지는 세미조인 최적화가 미흡해 대부분 풀 테이블스캔을 사용했다.
- 5.6 버전부터 8.0 까지 세미 조인 최적화가 많이 개선되었다.
- 세미 조인 최적화는 다음 5개 최적화 전략을 사용한다
  - 테이블 풀 아웃
  - 퍼스트 매치
  - 루스 스캔
  - 구체화
  - 중복 제거

`NOT IN 비교`
- IN (subquery) 와 비슷하지만 이를 **안티 세미 조인** 이라고 한다.
- 일반적으로 <> 연산자는 인덱스를 활용할 수 없듯이 이 또한 최적화 가능한 방법이 별로 없다.
  - NOT EXISTS
  - 구체화
- 위 두가지 방식 모두 성능향상에 그닥 도움이 되지 않으므로 최대한 다른 조건을 사용하는 것이 좋음
- WHERE 절에 단독으로 안티 세미 조인이 사용되면 풀 테이블 스캔을 피할수 없으므로 주의

### CTE (Common Table Expression)
- CTE 는 이름을 가지는 임시 테이블이다.
- SQL 문이 종료되면 자동으로 제거되고 재귀호출도 가능하다.

#### 비재귀적 CTE (Non-Recursive CTE)
- MySQL 은 ANSI 표준을 이용해 WITH 절을 사용한 CTE 를 정의한다.

```sql
WITH cte1 AS (SELECT * FROM departments)
SELECT * FROM cte1;
```
- CTE 로 생성된 임시테이블은 다른 CTE 쿼리에서도 참조할 수 있다.

#### 재귀적 CTE (Recursive CTE)
- 재귀적 CTE 쿼리는, **비 재귀적 파트** 와 **재귀적 파트** 로 구분된다.
- 이 둘을 UNION / UNION ALL 로 연결하는 쿼리를 반드시 작성해야만 한다.

```sql
WITH RECURSIVE cte (no) AS (
    SELECT 1
    UNION ALL 
    SELECT (no + 1) FROM cte WHERE no < 5
)
SELECT * FROM cte;
```
- 위 쿼리가 동작하는 방식은 다음과 같다.
1. CTE 쿼리의 비재귀적 파트 실행
2. 1 의 결과를 이용해 cte 라는 이름을 가진 임시테이블 생성
3. 1 의 결과를 cte 임시테이블에 저장
4. 1 의 결과를 입력으로 사용한 CTE 쿼리의 재귀 파트 실행
5. 4 의 결과를 cte 임시테이블에 저장 (UNION 연산 실행)
6. 전 단계의 결과를 입력으로 사용해 CTE 쿼리의 재귀파트 실행
7. 6 의 쿼리 결과가 없다면 CTE 쿼리 종료
8. 6 의 결과를 cte 임시테이블에 저장
9. 6 으로 돌아가 반복 실행

1 번 과정이 매우 중요한데 이때 **임시테이블의 구조가 결정** 된다.
- 임시 테이블의 구조는 CTE 쿼리의 비재귀적 파트에서 결정됨
- 재귀적 파트는 데이터를 생성하는 역할
- 또한 재귀적 파트는, **직전 단계의 결과만 입력으로 사용** 된다.
- 반복 종료조건이 사용되었지만 실제 재귀쿼리가 반복을 멈추는 조건은 **재귀 파트 쿼리 결과가 0건일때 까지** 이다.

CTE 가 종료조건을 만족하지 못해 발생하는 무한 반복을 막기 위해 `cte_max_recursive_max` 시스템 변수를 제공한다.

### 윈도우 함수 (Window Function)
- 윈도우 함수는, **조회하는 현재 레코드를 기준으로 연관된 레코드의 집합 연산을 수행** 한다.
- 집계함수의 경우 주어진 그룹 별로 하나의 레코드로 묶어서 출력한다.
- 윈도우 함수의 경우 **조건에 일치하는 레코드 건수는 변하지 않고 그대로 유지** 하는 것이 차이점 이다.

#### 쿼리 각 절의 실행 순서
- 윈도우 함수를 사용하는 쿼리의 과에 보여지는 레코드는 **FROM, WHERE, GROUP BY, HAVING** 에 의해 결정되고 그 이후 윈도우 함수가 실행된다.
- 그리고 마지막으로 SELECT, ORDER BY, LIMIT 이 실행되며 최종 결과가 반환된다.

![MySQL Query Execute Order](./images/mysql_query_execute_order.png)

#### 윈도우 함수 기본 사용법
- 윈도우 함수의 기본 사용법은 다음과 같다.

```sql
AGGREGATE_FUNC() OVER (<partition><order>) AS window_func_column
```
- 윈도우 함수는 용도별로 다양한 함수를 사용할 수 있다.
- 집계 함수와 달리 함수뒤에 `OVER` 절을 이용해 연산 대산을 파티션하기 위한 옵션을 명시할 수 있다.
- OVER 절에 의해 만들어진 그룹을 파티션 또는 윈도우 라고 한다.

```sql
SELECT e.*,
    RANK() OVER (ORDER BY e.hire_date) AS hire_date_rank
FROM employees e;
```
- 소그룹 파티션이나 정렬이 필요하지 않은 경우 PARTITION / ORDER BY 없이 비어 있는 OVER() 절을 사용하면 된다.
- 각 파티션 내에서도 연산 대상 레코드 별로 연산을 수행할 **소그룹** 이 사용된다.
  - 이를 프레임 이라고 함
- 프레임은 레코드 순서대로 현재 레코드 기준 앞뒤 몇 건을 **연산 범위로 제한하는 역할**
- MySQL 은 상황에 맞게 프레임을 묵시적으로 선택한다.

```sql
AGGREGATE_FUNC() OVER (<partition><order><frame>) AS window_func_column
```

`프레임을 만드는 기준`
- ROWS : 레코드의 위치를 기준으로 생성
- RANGE : ORDER BY 절에 명시된 칼럼을 기준으로 값의 범위로 생성

`프레임의 시작과 끝을 의미하는 키워드`
- CURRENT ROW : 현재 레코드
- UNBOUNDED PRECEDING : 파티션의 첫 번째 레코드
- UNBOUNDED FOLLOWING : 파티션의 마지막 레코드
- expr PRECEDING : 현재 레코드에서 n 번째 이전 레코드
- expr FOLLOWING : 현재 레코드에서 n 번째 이후 레코드

> 프레임이 ROWS 라면 expr 에는 레코드 위치가 명시되고, RANGE 라면 칼럼과 비교할 값이 명시되어야 한다.

일부 윈도우함수들은 프레임이 이미 고정되어 있는데, SQL 에서 프레임을 별도로 명시하더라도 아래 함수들에서는 프레임이 모두 무시된다.
- CUME_DIST()
- DENSE_RANK()
- LAG()
- LEAD()
- NTILE()
- PRECENT_RANK()
- RANK()
- ROW_NUMBER()

#### 윈도우 함수
- 윈도우 함수에는 집계 함수와 비 집계 함수 모두 사용이 가능하다.
- 집계 함수는 `OVER()` 절 없이 단독 사용이 가능하고, 비 집계 함수는 반드시 `OVER()` 절이 존재해야 한다.

| 함수 명 | 설명 |
| --- | --- |
| AVG() | 평균 값 반환 |
| BIT_AND() | AND 비트 연산 |
| BIT_OR() | OR 비트 연산 |
| BIT_XOR() | XOR 비트 연산 |
| COUNT() | 레코드 건수 |
| JSON_ARRAYAGG() | 결과를 JSON 배열로 반환 |
| JSON_OBJECTAGG() | 결과를 JSON OBJECT 배열로 반환 |
| MAX() | 최댓값 반환 |
| MIN() | 최솟값 반환 |
| STDEV_POP(), STDDEV(), STD() | 표준 편차 값 반환 |
| STDDEV_SAMP() | 표본 표준 편차 값 반환 |
| SUM() | 합계 값 반환 |
| VAR_POP(), VARIANCE() | 표준 분산 값 반환 |
| VAR_SAMP() | 표본 분산 값 반환 |
| CUME_DIST() | 누적 분포 값 반환 |
| DENSE_RANK() | 랭킹 값 반환 |
| FIRST_VALUE() | 파티션의 첫 번째 레코드 값 반환 |
| LAG() | 파티션 내에서 N 을 이용해 N 번째 이전 레코드 값 반환 |
| LAST_VALUE() | 파티션의 마지막 레코드 값 반환 |
| LEAD() | 파티션 내에서 N 을 이용해 N 번째 이후 레코드 값 반환 |
| NTH_VALUE() | 파티션의 N 번째 값 반환 |
| NTILE() | 파티션별 전첸 건수를 파라미터로 N 등분한 값 반환 |
| PRECENT_RANK() | 퍼센트 랭킹 값 반환 |
| RANK() | 랭킹 값 반환 |
| ROW_NUMBER() | 파티션의 레코드 순번 반환 |

#### DENSE_RANK(), RANK(), ROW_NUMBER()
- DENSE_RANK(), RANK() 모두 ORDER BY 기준으로 매겨진 순위를 반환한다.
- RANK() 는 동점 레코드가 두 건이상이라면, 그 다음 레코드를 동점인 레코드 수만큼 순위를 증가시킴
- DENSE_RANK() 는 동점 레코드를 1건으로 가정하고 순위를 매긴다
- ROW_NUMBER() 는 각 레코드의 고유 순번을 반환한다.

#### LAG(), LEAD()
- LAG() 는 파티션 내에서 현재 레코드를 기준으로 N 번째 이전 레코드를 반환한다.
- LEAD() 함수는 반대로 N 번쨰 이후 레코드를 반환한다.

#### 윈도우 함수와 성능
- 윈도우 함수는 8.0에 처음 도입되어 인덱스 최적화가 부족한 부분도 있다.
- 쿼리 요건에 따라 ORDER BY 나 다른 기존 기능으로 윈도우 함수를 대체할 수 없겠지만, 가능하면 윈도우 함수에 너무 의존하지 않는 것이 좋다.

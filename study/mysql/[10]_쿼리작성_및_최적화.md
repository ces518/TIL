# 지옥 스터디 - 10 쿼리 작성 및 최적화
- 애플리케이션 코드를 튜닝해 2배의 성능 향상을 한다는 건 쉽지 않은 일이다.
- 하지만 DBMS 에서 몇배 ~ 몇십배 성능 향상이 이뤄지는 것은 흔한일
- 때문에 SQL 처리에서 **어떻게 (How) 를 이해** 하고 쿼리를 작성하는 것이 중요하다. 

## 쿼리 작성과 관련된 시스템 변수
- 대소문자 구분과 같은 SQL 작성 규칙은 **MySQL 서버 시스템 설정** 에 따라 달라짐

### SQL 모드
- MySQL 서버의 `sql_mode` 설정은 여러 값이 동시에 설정될 수 있음
- SQL 문서 작성 규칙 뿐 아니라 자동으로 실행되는 데이터 타입 변환 및 기본값 제어 등과 관련된 옵션도 가지고 있다
- 사용자 테이블을 생성하고 데이터를 저장하기 시작했다면 옵션을 변경하지 않는 것이 좋음
- MySQL 8.0 기준 sql_mode 의 기본값은 다음과 같다
  - ONLY_FULL_GROUP_BY
  - STRICT_TRANS_TABLES
  - NO_ZERO_IN_DATE
  - NO_ZERO_DATE
  - ERROR_FOR_DIVISION_BY_ZERO
  - NO_ENGINE_SUBSTITUTION

`sql_mode options`

| 옵션 명 | 설명 |
| --- | --- |
| STRICT_ALL_TABLES & STRICT_TRANS_TABLES  | INSERT/UPDATE 문 수행시 저장되는 타입이 다른 경우 자동으로 타입 변경을 수행 <br/> `STRICT_TRANS_TABLES` 는 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드를 적용하고, `STRICT_ALL_TABLES` 는 이와 관계없이 모든 스토리지 엔진에 엄격한 모드를 적용한다 <br/> MySQL을 서비스 투입전 반드시 활성화 할 것을 권장 |
| ANTI_QUOTES | MySQL 은 문자열을 표현하기 위해 홑따옴표/쌍따옴표를 동시에 사용할 수 있음 <br/> 옵션 활성화시 홑따옴표만 문자열 값 표기로 사용할 수 있다. |
| ONLY_FULL_GROUP_BY | GROUP BY 절이 사용된 문장의 SELECT 절에는 GROUP BY 에 사용된 컬럼과 집계함수만 사용할 수 있다. 5.7 기준 기본값 비활성화, 8.0 기준 기본값 활성화 |
| PIPE_AS_CONCAT | MySQL 에서 &#124;&#124; 는 OR 연산자와 동일함. 옵션 활성화시 오라클과 동일하게 문자 연결 연산사로 사용할 수 있다 |
| PAD_CHAR_TO_FULL_LENGTH | MySQL 에서는 CHAR 타입이더라도 VARCHAR 와 같이 문자열 뒤의 공백문자는 제거되어 반환됨. 옵션 활성화시 문자 뒤의 공백문자가 제거되지 않고 반환됨 |
| NO_BACKSLASH_ESCAPES | 역슬래시를 이스케이프 문자로 사용할 수 있음. 옵션 활성화시 이스케이프 용도로 사용하지 못한다 |
| IGNORE_SPACE | 스토어드 프로시저나 함수명 사이 공백까지도 해당 이름으로 간주함. 옵션 활성화시 사이의 공백을 무시한다. 이는 **내장 함수에만 적용** 됨 |
| REAL_AS_FLOAT | MySQL 에서 부동소수점 타입은 FLOAT/DOUBLE 을 지원함. REAL 타입은 DOUBLE 타입의 동의어이다. 옵션 활성화시 FLOAT 타입의 동의어로 변경됨 |
| NO_ZERO_IN_DATE & NO_ZERO_DATE | 두 옵션 활성화 시 DATE/DATETIME 타입에 2020-00-00 과 같은 잘못된 날짜를 입력하지 못함 |
| ANSI | MySQL 서버가 최대한 ANSI 표준에 맞게 동작하게끔 만들어 준다. `REAL_AS_FLOAT`, `PIPES_AS_CONCAT`, `ANSI_QUOTES`, `IGNORE_SPACE`, `ONLY_FULL_GROUP_BY` 로 조합됨 |
| TRADITIONAL | STRICT_TRANS_TABLE/STRICT_ALL_TABLES 보다 더 엄격한 방법으로 동작을 제어함. `STRICT_TRANS_TABLES`, `STRICT_ALL_TABLES`, `NO_ZERO_IN_DATE`, `NO_ZERO_DATE`, `ERROR_FOR_DIVISION_BY_ZERO`, `NO_ENGINE_SUBSTITUTION` 로 조합됨 |

### 영문 대소문자 구분
- MySQL 서버는 기본적으로 **설치된 운영체제에 따라 테이블명의 대소문자를 구분** 한다.
  - DB 나 테이블은 디스크의 디렉터리/파일 로 매핑되기 때문
  - 유닉스 계열 운영체제에서 대소문자를 구분
  - 윈도우는 구분하지 않음
- `lower_case_table_names=1` 설정시 모두 소문자로만 저장하고, 대소문자를 구분하지 않게 동작한다.
  - 기본값 = 0
- 설정 자체를 떠나 가능하면 DB 생성시 대문자 혹은 소문자로만 통일해 사용하는 것이 좋음.

### MySQL 예약어
- 예약어를 사용하면 해당 칼럼이나 테이블을 SQL 에서 사용하기 위해 항상 백틱이나 쌍따옴표로 감싸주어야 한다.
- 테이블 생성시에는 항상 백틱으로 둘러싸지 않은 상태로 생성하길 권장
  - 에러나 경고가 무시될 수 있기 때문

## 메뉴얼의 SQL 문법 표기를 읽는 방법

```sql
 INSERT [LOW_PRIORITY | DELAYED | HIGH{PRIORITY ] [IGNORE]  
    [INTO] tbl_name
    SET col_name  = {expr | DEFAULT} ...
    [ON DUPLICATE  KEY UPDATE
        col_name = expr
        [, col_name = expr]....]
```

## MySQL 연산자와 내장함수
- 기본적인 연산자는 MySQL 에서도 비슷하게 사용되지만 MySQL 에서만 사용되는 연산자/표기법이 존재한다.
- ANSI 표준 형태가 아닌 것들이 많음
- 가능하면 SQL 작성시 ANSI 표준 연산자를 사용할 것을 권장한다.

### 리터럴 문자열 표기법

#### 문자열
- SQL 표준에서 문자열은 항상 홑따옴표를 사용해 표기하지만, MySQL 에서는 쌍따옴표를 사용해 표기할 수도 있다.
- 예약어의 경우 백틱을 사용해 충돌을 피할 수 있다.

```sql
SELECT * FROM departments WHERE dept_no = "d001";
```
- sql_mode 옵션에 `ANSI_QUOTES` 설정시 문자열 리터럴에 쌍따옴표를 사용할 수 없고, 예약어 충돌을 피하기 위해 쌍따옴표를 사용해야 한다.

#### 숫자
- 숫자 상수 값을 사용하려면 따옴표 없이 숫자를 입력하면 된다.
- 문자열 형태 따옴표를 사용하더라도, 타입이 일치하지 않는다면 자동 변환한다.

```sql
SELECT * FROM tab_test WHERE string_column = 10001;
```
- 두 비교대상이 문자열과 숫자 타입으로 다를 경우 자동변환이 발생한다.
- 숫자 타입과 문자타입 비교시 **숫자 타입을 우선** 하므로 문자열을 숫자로 변경한 뒤 비교를 수행한다.
- 위 쿼리의 경우 인덱스를 제대로 활용하지 못한다.
  - 문자컬럼과 숫자 상수의 비교
  - 문자컬럼의 값을 숫자로 변환한 뒤 비교를 수행하기 때문

> 주로 코드나 타입과 같은 값을 저장하는 컬럼에서 위와 같은 문제가 자주발생하므로 주의해야 함

#### 날짜
- MySQL 에서는 정해진 날짜 포맷으로 표기한다면 DATE/DATETIME 값으로 자동 변환하기 떄문에 STR_TO_DATE() 같은 함수를 사용하지 않아도 된다.

#### 불리언
- BOOL/BOOLEAN 이라는 타입이 존재하지만 사실 **TINYINT 타입의 동의어** 이다
- TRUE/FALSE 형태로 비교하거나 값을 저장할 수 있다.

### MySQL 연산자

#### 동등 비교
- 다른 DBMS 와 동일하게 "=" 기호로 비교를 수행하면 됨
- 추가적응로 동등 비교를 위해 "<=>" 연산자도 제공한다. 이는 "=" 와 동일하지만 부가적으로 NULL 값에 대한 비교까지 수행한다.
- 이를 **NULL-Safe 연산자** 라고 한다.
- NULL 은 기본적으로 IS NULL 연산자 외에는 비교할 방법이 없다
- Null-Safe 비교 연산자를 사용하면 양쪽 비교 대상모두 NULL 인 경우 TRUE, 한쪽만 NULL 인 경우 FALSE 를 반환한다.
- "<=>" 연산자는 NULL 을 하나의 값으로 인식하고 비교하는 방법

#### 부정 비교
- 같지 않다 비교를 위한 연산자는 "<>" 를 일반적으로 많이 사용한다.
  - != 도 사용 가능
- SQL 작성시 어느쪽을 사용해도 상관없지만 가독성을 위해 둘중 한가지 방법으로 통일해서 작성해야 한다

#### NOT 연산자
- TRUE/FALSE 연산의 결과를 부정하기 위해 NOT 을 사용한다.
  - ! 도 사용 가능
- 이는 불리언 뿐이 아닌 숫자나 문자에서도 사용할 수 있지만 결과를 정확히 예측할 수 없는경우 사용하지 않는 것을 권장한다.

#### AND OR 연산자
- MySQL 에서는 AND OR 뿐 아닌 && 과 || 도 허용한다
- sql_mode 옵션에 PIPE_AS_CONCAT 을 설정하면, 오라클과 동일하게 변경됨
- SQL 작성시 다른 용도로 사용될 수 있는 && 와 || 는 사용하지 않는 것이 좋다

#### 나누기와 나머지 연산자
- 나누기의 경우 일반적으로 알려진 "/" 연산자를 사용한다
- 나머지를 가져오는 연산자의 경우 "%" 또는 MOD 연산자를 사용한다

#### REGEXP 연산자
- 문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자
- `RLIKE` 는 `REGEXP` 와 동일한 비교를 수행한다.
- REGEXP 연산자의 정규표현식은 POSIX 표준으로 구현되어 있다
- REGEXP 를 단독으로 사용하는 경우 인덱스 레인지 스캔을 사용할 수 없다.

#### LIKE 연산자
- DBMS 에서는 단순 문자열 패턴 비교시 LIKE 연산자를 더 많이 사용한다
- LIKE 연산자를 인덱스를 활용할 수 있다
- 와일드카드 패턴을 지원함
  - %
  - _
- REGEXP 와 차이는, LIKE 의 경우 항상 비교 대상 문자열의 처음부터 끝까지 일치하는 경우에만 TRUE 를 반환한다
- 와일드카드가 검색어의 앞쪽에 위치한다면 **인덱스 레인지 스캔을 활용할 수 없다**

#### BETWEEN 연산자
- "크거나 같다" 와 "작거나 같다" 두 개의 연산자를 하나로 합친 연산자
- 다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의해야한다

```sql
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;
```
- BETWEEN 의 경우 d003 보다 크고 d005 보다 작은 레코드를 모두 스캔해야 한다.
- BETWEEN 과 IN 을 동일하게 생각하는 경우도 있는데, 이는 잘못된 생각
- IN 연산자의 경우 동등 비교 연산자와 비슷하다.
  - 여러 개의 동등 비교를 하나로 묶은 것과 같은 연산자
- 둘의 동작방식에는 차이가 있다

![MySQL Between In Index](./images/mysql_between_in_index.png)

- BETWEEN 은 선형으로 인덱스를 검색하는 반면, IN 은 동등 비교를 여러번 수행한다.
- 때문에 인덱스 앞쪽 컬럼의 선택도가 떨어지는 경우 IN 으로 변경해 성능을 개선하는 방법도 존재함

```sql
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;

SELECT * FROM dept_emp
WHERE dept_no IN ('d003', 'd004', 'd005') AND emp_no = 10001;
```
- 위 두 쿼리 모두 인덱스 레인지 스캔을 하지만, 실행 계획 떠보면 rows 의 레코드 건수는 큰 차이가 있음
- 8.0 버전 이전에는 BETWEEN 을 위와 같이 IN 쿼리로 변경하려면 해당 부서코드들을 조회한 뒤 직접 조건을 만들어 주어야 했다
- 하지만 8.0 버전 부터 IN (subquery) 형태로 자겅하면 세미조인 최적화를 사용해 더 빠른 쿼리로 변환해 준다

```sql
SELECT * dept_emp
WHERE dept_no IN (
    SELECT dept_no
    FROM departments
    WHERE dept_no BETWEEN 'd003' AND 'd005'
) AND emp_no = 10001;
```

#### IN 연산자
- IN 연산자는 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
- 범위 검색이 아닌, 여러 번의 동등비교를 수행하기 때문에 일반적으로 빠륵 ㅔ처리된다.
- 8.0 이전까지는 IN 절에 튜플 (레코드) 를 사용하면 항상 풀 테이블 스캔을 사용했다
  - 8.0 이후 개선됨
- NOT IN 의 경우 인덱스 풀 스캔이 일어난다.
  - 동등이 아닌 부정 비교이기 때문에 인덱스를 이용해 범위조건을 줄일 수 없다

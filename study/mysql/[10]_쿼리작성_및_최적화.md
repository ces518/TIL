# 지옥 스터디 - 10 쿼리 작성 및 최적화
- 애플리케이션 코드를 튜닝해 2배의 성능 향상을 한다는 건 쉽지 않은 일이다.
- 하지만 DBMS 에서 몇배 ~ 몇십배 성능 향상이 이뤄지는 것은 흔한일
- 때문에 SQL 처리에서 **어떻게 (How) 를 이해** 하고 쿼리를 작성하는 것이 중요하다. 

## 쿼리 작성과 관련된 시스템 변수
- 대소문자 구분과 같은 SQL 작성 규칙은 **MySQL 서버 시스템 설정** 에 따라 달라짐

### SQL 모드
- MySQL 서버의 `sql_mode` 설정은 여러 값이 동시에 설정될 수 있음
- SQL 문서 작성 규칙 뿐 아니라 자동으로 실행되는 데이터 타입 변환 및 기본값 제어 등과 관련된 옵션도 가지고 있다
- 사용자 테이블을 생성하고 데이터를 저장하기 시작했다면 옵션을 변경하지 않는 것이 좋음
- MySQL 8.0 기준 sql_mode 의 기본값은 다음과 같다
  - ONLY_FULL_GROUP_BY
  - STRICT_TRANS_TABLES
  - NO_ZERO_IN_DATE
  - NO_ZERO_DATE
  - ERROR_FOR_DIVISION_BY_ZERO
  - NO_ENGINE_SUBSTITUTION

`sql_mode options`

| 옵션 명 | 설명 |
| --- | --- |
| STRICT_ALL_TABLES & STRICT_TRANS_TABLES  | INSERT/UPDATE 문 수행시 저장되는 타입이 다른 경우 자동으로 타입 변경을 수행 <br/> `STRICT_TRANS_TABLES` 는 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드를 적용하고, `STRICT_ALL_TABLES` 는 이와 관계없이 모든 스토리지 엔진에 엄격한 모드를 적용한다 <br/> MySQL을 서비스 투입전 반드시 활성화 할 것을 권장 |
| ANTI_QUOTES | MySQL 은 문자열을 표현하기 위해 홑따옴표/쌍따옴표를 동시에 사용할 수 있음 <br/> 옵션 활성화시 홑따옴표만 문자열 값 표기로 사용할 수 있다. |
| ONLY_FULL_GROUP_BY | GROUP BY 절이 사용된 문장의 SELECT 절에는 GROUP BY 에 사용된 컬럼과 집계함수만 사용할 수 있다. 5.7 기준 기본값 비활성화, 8.0 기준 기본값 활성화 |
| PIPE_AS_CONCAT | MySQL 에서 &#124;&#124; 는 OR 연산자와 동일함. 옵션 활성화시 오라클과 동일하게 문자 연결 연산사로 사용할 수 있다 |
| PAD_CHAR_TO_FULL_LENGTH | MySQL 에서는 CHAR 타입이더라도 VARCHAR 와 같이 문자열 뒤의 공백문자는 제거되어 반환됨. 옵션 활성화시 문자 뒤의 공백문자가 제거되지 않고 반환됨 |
| NO_BACKSLASH_ESCAPES | 역슬래시를 이스케이프 문자로 사용할 수 있음. 옵션 활성화시 이스케이프 용도로 사용하지 못한다 |
| IGNORE_SPACE | 스토어드 프로시저나 함수명 사이 공백까지도 해당 이름으로 간주함. 옵션 활성화시 사이의 공백을 무시한다. 이는 **내장 함수에만 적용** 됨 |
| REAL_AS_FLOAT | MySQL 에서 부동소수점 타입은 FLOAT/DOUBLE 을 지원함. REAL 타입은 DOUBLE 타입의 동의어이다. 옵션 활성화시 FLOAT 타입의 동의어로 변경됨 |
| NO_ZERO_IN_DATE & NO_ZERO_DATE | 두 옵션 활성화 시 DATE/DATETIME 타입에 2020-00-00 과 같은 잘못된 날짜를 입력하지 못함 |
| ANSI | MySQL 서버가 최대한 ANSI 표준에 맞게 동작하게끔 만들어 준다. `REAL_AS_FLOAT`, `PIPES_AS_CONCAT`, `ANSI_QUOTES`, `IGNORE_SPACE`, `ONLY_FULL_GROUP_BY` 로 조합됨 |
| TRADITIONAL | STRICT_TRANS_TABLE/STRICT_ALL_TABLES 보다 더 엄격한 방법으로 동작을 제어함. `STRICT_TRANS_TABLES`, `STRICT_ALL_TABLES`, `NO_ZERO_IN_DATE`, `NO_ZERO_DATE`, `ERROR_FOR_DIVISION_BY_ZERO`, `NO_ENGINE_SUBSTITUTION` 로 조합됨 |

### 영문 대소문자 구분
- MySQL 서버는 기본적으로 **설치된 운영체제에 따라 테이블명의 대소문자를 구분** 한다.
  - DB 나 테이블은 디스크의 디렉터리/파일 로 매핑되기 때문
  - 유닉스 계열 운영체제에서 대소문자를 구분
  - 윈도우는 구분하지 않음
- `lower_case_table_names=1` 설정시 모두 소문자로만 저장하고, 대소문자를 구분하지 않게 동작한다.
  - 기본값 = 0
- 설정 자체를 떠나 가능하면 DB 생성시 대문자 혹은 소문자로만 통일해 사용하는 것이 좋음.

### MySQL 예약어
- 예약어를 사용하면 해당 칼럼이나 테이블을 SQL 에서 사용하기 위해 항상 백틱이나 쌍따옴표로 감싸주어야 한다.
- 테이블 생성시에는 항상 백틱으로 둘러싸지 않은 상태로 생성하길 권장
  - 에러나 경고가 무시될 수 있기 때문

## 메뉴얼의 SQL 문법 표기를 읽는 방법

```sql
 INSERT [LOW_PRIORITY | DELAYED | HIGH{PRIORITY ] [IGNORE]  
    [INTO] tbl_name
    SET col_name  = {expr | DEFAULT} ...
    [ON DUPLICATE  KEY UPDATE
        col_name = expr
        [, col_name = expr]....]
```

## MySQL 연산자와 내장함수
- 기본적인 연산자는 MySQL 에서도 비슷하게 사용되지만 MySQL 에서만 사용되는 연산자/표기법이 존재한다.
- ANSI 표준 형태가 아닌 것들이 많음
- 가능하면 SQL 작성시 ANSI 표준 연산자를 사용할 것을 권장한다.

### 리터럴 문자열 표기법

#### 문자열
- SQL 표준에서 문자열은 항상 홑따옴표를 사용해 표기하지만, MySQL 에서는 쌍따옴표를 사용해 표기할 수도 있다.
- 예약어의 경우 백틱을 사용해 충돌을 피할 수 있다.

```sql
SELECT * FROM departments WHERE dept_no = "d001";
```
- sql_mode 옵션에 `ANSI_QUOTES` 설정시 문자열 리터럴에 쌍따옴표를 사용할 수 없고, 예약어 충돌을 피하기 위해 쌍따옴표를 사용해야 한다.

#### 숫자
- 숫자 상수 값을 사용하려면 따옴표 없이 숫자를 입력하면 된다.
- 문자열 형태 따옴표를 사용하더라도, 타입이 일치하지 않는다면 자동 변환한다.

```sql
SELECT * FROM tab_test WHERE string_column = 10001;
```
- 두 비교대상이 문자열과 숫자 타입으로 다를 경우 자동변환이 발생한다.
- 숫자 타입과 문자타입 비교시 **숫자 타입을 우선** 하므로 문자열을 숫자로 변경한 뒤 비교를 수행한다.
- 위 쿼리의 경우 인덱스를 제대로 활용하지 못한다.
  - 문자컬럼과 숫자 상수의 비교
  - 문자컬럼의 값을 숫자로 변환한 뒤 비교를 수행하기 때문

> 주로 코드나 타입과 같은 값을 저장하는 컬럼에서 위와 같은 문제가 자주발생하므로 주의해야 함

#### 날짜
- MySQL 에서는 정해진 날짜 포맷으로 표기한다면 DATE/DATETIME 값으로 자동 변환하기 떄문에 STR_TO_DATE() 같은 함수를 사용하지 않아도 된다.

#### 불리언
- BOOL/BOOLEAN 이라는 타입이 존재하지만 사실 **TINYINT 타입의 동의어** 이다
- TRUE/FALSE 형태로 비교하거나 값을 저장할 수 있다.

### MySQL 연산자

#### 동등 비교
- 다른 DBMS 와 동일하게 "=" 기호로 비교를 수행하면 됨
- 추가적응로 동등 비교를 위해 "<=>" 연산자도 제공한다. 이는 "=" 와 동일하지만 부가적으로 NULL 값에 대한 비교까지 수행한다.
- 이를 **NULL-Safe 연산자** 라고 한다.
- NULL 은 기본적으로 IS NULL 연산자 외에는 비교할 방법이 없다
- Null-Safe 비교 연산자를 사용하면 양쪽 비교 대상모두 NULL 인 경우 TRUE, 한쪽만 NULL 인 경우 FALSE 를 반환한다.
- "<=>" 연산자는 NULL 을 하나의 값으로 인식하고 비교하는 방법

#### 부정 비교
- 같지 않다 비교를 위한 연산자는 "<>" 를 일반적으로 많이 사용한다.
  - != 도 사용 가능
- SQL 작성시 어느쪽을 사용해도 상관없지만 가독성을 위해 둘중 한가지 방법으로 통일해서 작성해야 한다

#### NOT 연산자
- TRUE/FALSE 연산의 결과를 부정하기 위해 NOT 을 사용한다.
  - ! 도 사용 가능
- 이는 불리언 뿐이 아닌 숫자나 문자에서도 사용할 수 있지만 결과를 정확히 예측할 수 없는경우 사용하지 않는 것을 권장한다.

#### AND OR 연산자
- MySQL 에서는 AND OR 뿐 아닌 && 과 || 도 허용한다
- sql_mode 옵션에 PIPE_AS_CONCAT 을 설정하면, 오라클과 동일하게 변경됨
- SQL 작성시 다른 용도로 사용될 수 있는 && 와 || 는 사용하지 않는 것이 좋다

#### 나누기와 나머지 연산자
- 나누기의 경우 일반적으로 알려진 "/" 연산자를 사용한다
- 나머지를 가져오는 연산자의 경우 "%" 또는 MOD 연산자를 사용한다

#### REGEXP 연산자
- 문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자
- `RLIKE` 는 `REGEXP` 와 동일한 비교를 수행한다.
- REGEXP 연산자의 정규표현식은 POSIX 표준으로 구현되어 있다
- REGEXP 를 단독으로 사용하는 경우 인덱스 레인지 스캔을 사용할 수 없다.

#### LIKE 연산자
- DBMS 에서는 단순 문자열 패턴 비교시 LIKE 연산자를 더 많이 사용한다
- LIKE 연산자를 인덱스를 활용할 수 있다
- 와일드카드 패턴을 지원함
  - %
  - _
- REGEXP 와 차이는, LIKE 의 경우 항상 비교 대상 문자열의 처음부터 끝까지 일치하는 경우에만 TRUE 를 반환한다
- 와일드카드가 검색어의 앞쪽에 위치한다면 **인덱스 레인지 스캔을 활용할 수 없다**

#### BETWEEN 연산자
- "크거나 같다" 와 "작거나 같다" 두 개의 연산자를 하나로 합친 연산자
- 다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의해야한다

```sql
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;
```
- BETWEEN 의 경우 d003 보다 크고 d005 보다 작은 레코드를 모두 스캔해야 한다.
- BETWEEN 과 IN 을 동일하게 생각하는 경우도 있는데, 이는 잘못된 생각
- IN 연산자의 경우 동등 비교 연산자와 비슷하다.
  - 여러 개의 동등 비교를 하나로 묶은 것과 같은 연산자
- 둘의 동작방식에는 차이가 있다

![MySQL Between In Index](./images/mysql_between_in_index.png)

- BETWEEN 은 선형으로 인덱스를 검색하는 반면, IN 은 동등 비교를 여러번 수행한다.
- 때문에 인덱스 앞쪽 컬럼의 선택도가 떨어지는 경우 IN 으로 변경해 성능을 개선하는 방법도 존재함

```sql
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;

SELECT * FROM dept_emp
WHERE dept_no IN ('d003', 'd004', 'd005') AND emp_no = 10001;
```
- 위 두 쿼리 모두 인덱스 레인지 스캔을 하지만, 실행 계획 떠보면 rows 의 레코드 건수는 큰 차이가 있음
- 8.0 버전 이전에는 BETWEEN 을 위와 같이 IN 쿼리로 변경하려면 해당 부서코드들을 조회한 뒤 직접 조건을 만들어 주어야 했다
- 하지만 8.0 버전 부터 IN (subquery) 형태로 자겅하면 세미조인 최적화를 사용해 더 빠른 쿼리로 변환해 준다

```sql
SELECT * dept_emp
WHERE dept_no IN (
    SELECT dept_no
    FROM departments
    WHERE dept_no BETWEEN 'd003' AND 'd005'
) AND emp_no = 10001;
```

#### IN 연산자
- IN 연산자는 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
- 범위 검색이 아닌, 여러 번의 동등비교를 수행하기 때문에 일반적으로 빠륵 ㅔ처리된다.
- 8.0 이전까지는 IN 절에 튜플 (레코드) 를 사용하면 항상 풀 테이블 스캔을 사용했다
  - 8.0 이후 개선됨
- NOT IN 의 경우 인덱스 풀 스캔이 일어난다.
  - 동등이 아닌 부정 비교이기 때문에 인덱스를 이용해 범위조건을 줄일 수 없다

### MySQL 내장 함수
- 기본적인 기능의 함수는 대부분 동일하게 제공된다
- **함수명이나 사용법은 표준이 없기 때문에 DBMS 별로 호환되지 않음**
- MySQL 의 함수는 기본적으로 제공하는 **내장 함수** 와 **사용자 정의 함수 (UDF User Defined Function)** 으로 구분된다

#### NULL 값 비교 및 대체 (IFNULL, ISNULL)
- `IFNULL()` 함수는 칼럼이나 표현식의 값이 NULL 인지 비교하고, NULL 인 경우 다른 값으로 대체한다
  - 첫번째 인자가 NULL 이아니면 첫번째 인자의 값을, 아니라면 두번째 인자의 값을 반환
- `ISNULL()` 함수는 칼럼이나 표현식의 값이 NULL 인지 비교하는 한다

#### 현재 시각 조회 (NOW, SYSDATE)
- 현재의 시간을 반환하는 함수
- 하나의 SQL 에서 모든 NOW() 함수는 항상 같은 값을 가진다
- 하지만 SYSDATE() 함수는 호출 시점에 따라 결괏 값이 달라지므로 유의해야한다
  - `sysdate_is_now` 시스템 변수를 활성화 하면 NOW() 와 동일하게 동작

> 레플리카 서버에서 안정적으로 복제되지 않기 때문에 유의

#### 날짜와 시간의 포맷 (DATE_FORMAT, STR_TO_DATE)
- DATETIME 타입의 컬럼이나 값을 원하는 형태의 문자열로 변환하려면 `DATE_FORMAT()` 함수를 사용
- 날짜 포맷변경을 위한 지정자는 모두 **대소문자를 구분** 하므로 유의
- SQL 표준 형태 (년-월-일 시:분:초) 인 문자열을 필요시 자동으로 타입변환이 일어난다
  - DATETIME 타입

#### 날짜와 시간의 연산 (DATE_ADD, DATE_SUB)
- 특정 날짜에서 연도나 월일 또는 시간 등을 더하거나 뺄때 `DATE_ADD()`, `DATE_SUB()` 함수를 사용
  - DATE_SUB() 은 크게 쓸일이 없음
  - DATE_ADD() 로 모든 처리가 가능함
- 첫 번째 인자는 연사를 수행할 날짜, 두번 째는 더하거나 빼고자하는 월/일의 수

#### 타임스탬프 연산 (UNIX_TIMESTAMP, FROM_UNIXTIME)
- `UNIX_TIMESTAMP()` 함수는 '1970-01-01 00:00:00' 으로부터 경과된 초를 반환하는 함수
- 함수 인자가 없는 경우 현재 날짜와 시간의 타임스탬프 값을 반환하고, 특정 날짜를 입력하면 해당 날짜와 시간의 타임스탬프를 반환한다

> TIMESTAMP 타입은 4바이트 숫자 타입으로 저장된다. <br/>
> 때문에 실제 값의 범위는 1970-01-01 00:00:01 ~ 2038-01-09 03:14:07 까지 날짜값만 가능하다

#### 문자열 처리 (RPAD, LPAD / RTRIM, LTRIM, TRIM)
- `RPAD()`, `LPAD()` 함수는 문자열 좌측 혹은 우측에 문자를 덧붙여 지정된 길이의 문자열로 만드는 함수
  - 첫번째 인자는 패딩 처리를할 문자열
  - 두번째 인자는 몇 바이트까지 패딩할 것인지
  - 세번째 인자는 어떤 문자를 패딩할 것인지를 의미
- `RTRIM()`, `LTRIM()` 함수는 문자열 우측 혹은 좌측에 연속된 공백 문자를 제거하는 함수
- `TRIM()` 함수는 위 두 함수의 처리를 동시에 수행하는 함수

#### 문자열 결합 (CONCAT)
- 여러 문자열을 연결해 하나의 문자열로 반환하는 함수
- 숫자를 인자로 전달하면 문자열 타입으로 변환한 후 처리한다
- 명시적으로 `CAST()` 함수를 이용해 타입을 문자열로 변환하는 것이 안전함
- 유사한 함수로 `CONCAT_WS()` 함수가 있다

#### GROUP BY 문자열 결합 (GROUP_CONCAT)
- COUNT(), MAX(), MIN(), AVG() 등과 같이 그룹 함수 중 하나이다
- `GROUP_CONCAT()` 함수는 값을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중 중복을 제거하고 연결하는 것도 가능하다.
  - 주로 GROUP BY 와 함께 사용한다
- 지정한 값들을 연결하기 위한 메모리 버퍼 공간을 사용한다.
  - `group_concat_max_len` 시스템 변수
  - 해당 크기를 초과할 경우 경고 메세지가 발생한다
  - 기본값은 1KB

#### 값의 비교와 대체 (CASE WHEN.. THEN.. END)
- CASE WHEN 은 프로그래밍 언어에서 제공하는 `SWITCH` 구문과 같은 역할을 수행한다.

#### 타입의 변환 (CAST, CONVERT)
- **프리페어 스테이트먼트 (Prepared Statement)** 를 제외하면 SQL 은 문자열 기반으로 동작하기 때문에 모든 입력값은 문자열 처럼 취급된다.
- 명시적인 타입 변환이 필요한 경우 `CAST()` 함수를 사용하면 된다.
  - `CONVERT()` 도 이와 비슷하다.
- 변환 가능한 데이터 타입은, **DATE, TIME, DATETIME, BINARY, CHAR, DECIMAL, SIGNED INTEGER, UNSIGNED INTEGER** 이다.
- MySQL 의 자동변환중 SIGNED, UNSIGNED 같이 부호가 있거나 없는 정수 값의 변환은 자동으로 이뤄지지 못하는 경우가 많음
- 그런 경우 명시적인 타입 변환을 해야함
- `CONVERT()` 는 타입 변환 외에도 **문자 집합을 변환하는 용도** 로도 사용할 수 있다.

#### 이진값과 16진수 문자열 (Hex String) 변환 (HEX UNHEX)
- `HEX()` 함수는 이진값을 사람이 읽을 수 있는 16진수 문자열로 변환하는 함수
- `UNHEX()` 는 16진수 문자열을 이진값으로 변환하는 함수
- 여기서의 이진값은 바이너리 값이다.

#### 암호화 및 해시함수 (MD5, SHA, SHA2)
- `SHA()` 함수는 SHA-1 암호화 알고리즘을 사용
- `SHA2()` 함수는 SHA 알고리즘 보다 강력한 224 ~ 512 비트 알고리즘을 사용
- `MD5()` 함수는 메세지 다이제스트 알고리즘을 사용해 128 비트 해시값을 반환한다.
  - MD5 는 문자열 길이를 줄이는 용도
- 위 3가지 함수는 모두 중복 가능성이 매우 낮기 때문에 긴 데이터의 크기를 줄여 인덱싱 하는 용도로도 사용된다.

#### 처리 대기 (SLEEP)
- `SLEEP()` 함수는 프로그래밍 언어나 셸 스크립트에서 제공하는 SLEEP 기능을 제공
- SQL 개발이나 디버깅 용도로 사용한다

#### 벤치마크 (BENCHMARK)
- `BENCHMARK()` 함수는 디버깅이나 간단한 함수 성능 테스트용으로 유용한 함수이다.
  - 첫 번째 인자는 반복해서 수행할 횟수
  - 두 번째 인자는 반드시 스칼라 값을 반환하는 쿼리
- 쿼리를 직접 수행하는것과 벤치마크 함수를 사용하는 것은 큰 차이가 있음
- 벤치마크함수를 사용하면, 벤치마크 횟수와 관계없이 단 1번의 네트워크, 쿼리 파싱 및 최적화 비용이 소요된다.

> 벤치마크 함수로 얻은 성능은 큰 의미가 없다. 두 개의 동일한 기능을 상대적으로 비교 분석하는 용도로 사용할 것을 권장한다.

#### IP 주소 변환 (INET_ATON, INET_NTOA)
- `INET_ATON()`, `INET_NTOA()` 함수로 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장가능하게 제공한다.
  - INET_ATON() 함수는 IPv4 주소를 정수형으로 변환하는함수
  - INET_NTOA() 함수는 정수형의 IPv4 주소를 . 으로 구분된 문자열로 변환하는 함수
- `INET6_ATON()`, `INET6_NTOA()` 함수로 IPv6 주소도 지원한다
  - 위 두 함수로 저장시 바이너리 값을 저장할 수 있는 타입을 사용해야 함

#### JSON 포맷 (JSON_PRETTY)
- `JSON_PRETTY()` 함수를 이용하면 JSON 컬럼의 값을 읽기 쉬운 포맷으로 변환해 준다.

#### JSON 필드 크기 (JSON_STORAGE_SIZE)
- MySQL 서버는 JSON 데이터 저장시 **BSON (Binary JSON)** 포맷을 사용한다
  - 디스크 저장공간 절약을 위함
- `JSON_STORAGE_SIZE()` 함수는 BSON 으로 변환시 크기를 확인을 위함

#### JSON 필드 추출 (JSON_EXTRACT)
- `JSON_EXTRACT()` 함수는 JSON 도큐먼트에서 특정 필드 값을 가져오는 방법중 가장 일반적인 방법
  - 첫 번째 인자는 JSON 데이터
  - 두 번째 인자는 JSON 경로
- `JSON_EXTRACT()` 의 결과는 따옴표가 붙은 상태로 반환된다. `JSON_UNQUOTE()` 를 사용하면 따옴표가 제거된 값만 가져올 수 있음
- 또한 사용자 편의를 위한 연산자를 추가적으로 제공한다.

```sql
SELECT emp_no, doc->>"$.first_name" FROM employee_docs LIMIT 2;
```
- `->` 연산자는 JSON_EXTRACT() 와 동일
- `->>` 연산자는 JSON_UNQUOTE() 와 JSON_EXTRACT() 를 조합한 것과 동일

#### JSON 오브젝트 포함 여부 확인 (JSON_CONTAINS)
- JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 포함하고 있는지 확인하는 함수

#### JSON 오브젝트 생성 (JSON_OBJECT)
- RDBMS 컬럼 값을 이용해 JSON 오브젝트를 생성하는 함수

#### JSON 컬럼으로 집계 (JSON_OBJECTAGG & JSON_ARRAYAGG)
- GROUP BY 절과 함께 사용되는 집계 함수
- RDBMS 칼럼 값들을 모아 JSON 배열이나 도큐먼트를 생성하는 함수이다.

#### JSON 데이터를 테이블로 변환 (JSON_TABLE)
- JSON 데이터 값들을 모아 RDBMS 테이블로 만들어 반환하는 함수
- 해당 함수가 반환하는 테이블의 레코드 건수는 원본 테이블과 동일한 레코드 건수를 가짐
- 이는 **항상 내부 임시테이블을 사용** 하기 때문에 유의

## SELECT
- 일반적인 온라인 트랜잭션 처리환경의 경우 INSERT/UPDATE 는 레코드 단위로 발생하기 때문에 성능상 문제가 되는 경우는 드물다.
- 하지만 SELECT 쿼리의 비율은 높음 이에 관련해서 성능 위주로 살펴봄

### SELECT 절 처리 순서

![MySQL SELECT QUERY](./images/mysql_select_query_order.png)
- 대부분의 경우 위 순서가 바뀌어 실행되는 쿼리는 거의 없다.
- SQL 에 ORDER BY, GROUP BY 가 있더라도 인덱스 를 이용해 처리한다면 불필요한 단계가 되므로 생략됨

![MySQL SELECT QUERY](./images/mysql_select_query_order_v2.png)
- 위 경우는 예외적인 순서로 실행되는 경우이다
- 첫 번째 테이블만 읽어 정렬이후 나머지 테이블을 읽는데, 주로 GROUP BY 없이 ORDER BY 만 사용된 쿼리에서 보이는 순서

### WHERE, GROUP BY, ORDER BY 의 인덱스 사용
- WHERE 절 뿐만 아니라 GROUP BY, ORDER BY 에서도 인덱스를 사용해 빠른 처리가 가능하다.

#### 인덱스 사용을 위한 기본 규칙
- WHERE, GROUP BY, ORDER BY 가 인덱스를 사용하려면 **인덱스된 칼럼의 값을 변환하지 않고 그대로 사용** 해야한다.
- WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교대상 값은 **데이터 타입이 일치** 해야 한다.
- 저장하고자 하는 값의 타입에 맞춰 칼럼 타입을 선정하고, SQL 작성시 데이터 타입에 맞춰 비교 조건을 사용하는 것을 권장한다.

#### WHERE 절의 인덱스 사용
- WHERE 조건이 인덱스를 사용하는 방법은 **작업 범위 결정 조건** 과 **체크 조건** 두 가지로 구분할 수 있다.
- 작업 범위 결정 조건은, 동등 비교조건이나 IN 으로 구성된 조건에서 칼럼들이 인덱스 칼럼 구성과 좌측부터 비교했을때 얼마나 일치하는지에 따라 달라진다.

![MySQL Where Index Rule](./images/mysql_where_index_rule.png)
- 각 조건이 AND 로 연결되어 있다면 레코드 건수를 줄이는 역할을 하지만, OR 로 연결되어 있다면 비교할 레코드가 더 늘어나기 때문에 주의해야 함

#### GROUP BY 절의 인덱스 사용
- GROUP BY 절의 각 칼럼은 비교 연산자를 가지지 않으므로 작업범위 결정 조건 등을 생각할 필요가 없다.
- 명시된 칼럼의 순서가 인덱스를 구성하는 순서와 동일하다면 인덱스를 사용할 수 있다.

![MySQL Group By Index Rule](./images/mysql_group_by_index_rule.png)

#### ORDER BY 절의 인덱스 사용
- GROUP BY 와 ORDER BY 의 처리는 상당히 비슷하다.
- 인덱스 사용여부도 거의 흡사하지만 추가적인 조건이 하나 더 있다.
- 각 컬럼의 **오름차순 및 내림차순 옵션이 인덱스와 같거나 정 반대인 경우에만 사용** 할 수 있다.
- MySQL 은 모든 칼럼이 오름차순으로 정렬되어 있기 때문에 ORDER BY 절의 모든 컬럼이 오른차순이거나 내림차순 일때만 인덱스를 사용할 수 있다.

![MySQL Order By Index Rule](./images/mysql_order_by_index_rule.png)

#### WHERE 조건과 ORDER BY (GROUP BY) 절의 인덱스 사용
- SQL 문이 WHERE, ORDER BY 절이 가지고 있다고 가정했을때, WHERE 는 A 인덱스를 사용하고, ORDER BY 는 B 인덱스를 사용하도록 쿼리가 실행될 수는 없다.
- 같이 사용된 하나의 쿼리의 문장은 다음 3가지 중 한가지 방법으로만 인덱스를 사용한다.

`WHERE 절과 ORDER BY 절이 동시에 같은 인덱스 사용`
- 두 가지가 하나의 인덱스를 사용한다.
- 나머지 두 방식보다 빠른 성능을 보이기에 가능하면 이 방식을 사용하도록 튜닝하는 것이 좋음

`WHERE 절만 인덱스 사용`
- ORDER BY 는 인덱스를 사용해 정렬이 불가능 하다.
- 검색 결과 렠도르르 별도의 정렬을 통해 정렬을 수행한다.
- WHERE 조건에 일치하는 레코드가 적은 경우 효율적이다.

`ORDER BY 절만 인덱스 사용`
- ORDER BY 순서대로 인덱스를 읽으며 레코드를 한건씩 WHERE 조건에 비교하고 버리는 형태로 처리한다.
- 주로 아주 많은 레코드를 읽어 정렬해야 하는경우 선택하는 방법

#### GROUP BY 절과 ORDER BY 절의 인덱스 사용
- GROUP BY 와 ORDER BY 가 동시에 사용된 쿼리에서 모두 하나의 인덱스를 사용해 처리하려면 두 가지모두 순서와 내용이 같아야한다.
- 5.7 버전까지는 GROUP BY 의 경우 GROUP BY 컬럼에 대한 정렬까지 수행하는 것이 기본 동작방식 이었다.
- 8.0 버전부터는 정렬까지는 보장하지 않는 형태로 바뀌었다.
  - 그루핑과 정렬을 모두 수행하기 위해서는 두가지 절 모두 명시해야 함

#### WHERE 조건과 ORDER BY, GROUP BY 의 인덱스 사용
- WHERE, GROUP BY, ORDER BY 가 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법
1. WHERE 절이 인덱스를 사용할 수 있는가 ?
2. GROUP BY 절이 인덱스를 사용할 수 있는가 ?
3. GROUP BY, ORDER BY 가 동시에 인덱스를 사용할 수 있는가 ?

![MySQL Where Group By Order By](./images/mysql_where_order_by_group_by_index_rule.png)

### WHERE 절의 비교 조건 사용시 주의사항

#### NULL 비교
- MySQL 에서는 NULL 이 포함된 레코드도 인덱스로 관리됨
- 
# 지옥 스터디 - 14 데이터 타입
- 칼럼의 데이터 타입을 선정하는 일은 물리 모델링에서 중요한 작업.
- 데이터 타입과 길이 선정시 다음 사항을 주의해야 한다.
  - 저장되는 값의 **성격에 맞는 최적의 타입** 선정
  - 가변 길이 칼럼의 경우 최적의 길이 설정
  - 조인 조건으로 사용되는 경우 동일한 데이터 타입으로 선정
- 일반적으로 저장되는 값의 특성을 고려하지 않고 가능한 최대 길이로 선택하는 것이 일반적인데, 무분별하게 크게 선정되면 디스크 는 물론 메모리/CPU 자원도 함께 낭비된다.
  - 그로 인해 SQL 성능 저하는 당연한 결과.
- 데이터 타입의 길이는 너무 넉넉해도 안되고 부족해도 문제가 된다.
- 실제 저장되는 값의 성격을 정확히 분석하고 최적의 타입과 길이를 선정하는것이 중요.

## 문자열 (CHAR 와 VARCHAR)
- 문자열 컬럼을 사용하는 경우 CHAR 와 VARCHAR 중 선택해야 하낟.
- 이 둘은 장단점을 갖고 있으며 저장 공간과 비교 방식 관점에서 이들을 살펴본다.

### 저장 공간
- CHAR 와 VARCHAR 의 공통점은 문자열 저장이 가능한 데이터 타입이다.
- 가장 큰 차이는 **고정길이** 냐, **가변길이** 냐 이다.
- 고정길이는 실제 칼럼값의 길이에 따라 저장 공간의 크기가 변하지 않음.
  - 저장 공간의 크기가 고정적 이다.
- 가변길이는 최대 저장 가능한 값의 길이는 제한되어 있지만, 그 보다 작은 값이 저장되면 그 만큼 저장공간이 줄어듦
  - 하지만 저장된 값의 크기를 가지는 메타 정보를 가지고 있어야하기 때문에 1 ~ 2 바이트 정도 저장 공간이 추가로 더 필요하다.
- VARCHAR 의 경우 문자열 길이 관리를 위한 1 ~ 2 바이트 공간을 추가로 사용한다.
  - 255 바이트 이하면 1바이트만  사용하고, 256 바이트 이상이라면 2바이트를 사용한다.
  - VARCHAR 타입의 최대 길이는 2바이트로 범위를 넘어선다면 사용할 수 없다.
  - 즉 VARCHAR 타입에 저장가능한 최대 길이는 65,536 바이트

`참고`
- MySQL 에서 하나의 레코드는 TEXT/BLOB 타입을 제외한 전체 크기가 64KB 를 초과할 수 없다.
- 만약 다른컬럼에서 40KB 를 사용하고 있다면 VARCHAR 는 24KB 가 최대값.
- 24KB 를 넘도록 생성할경우 에러가 발생하거나 자동으로 TEXT 타입으로 대체된다.
- 때문에 컬럼을 새로 추가한다면 VARCHAR 가 TEXT 타입으로 자동변환되었는지 확인하는 것이 좋다.

> 문자열 값의 길이가 항상 일정하다면 CHAR 를, 가변적이라면 VARCHAR 를 사용하는 것이 일반적이지만 문자열 길이가 정적이냐 가변적이냐 여부로만 타입을 결정하는 것은 좋지 않다.

`타입 결졍시 고려할 두 가지`
- 저장되는 문자열의 길이가 대개 비슷한가 ?
- 칼럼의 값이 자주 변경되는가 ?

> 값의 길이도 중요하지만, 해당 칼럼의 값이 얼마나 자주 변경되느냐 가 기준이 되어야 한다.

CHAR(10) 타입 사용중이라면 값 변경시 10바이트가 준비되어 있으므로 변경되는 값을 업데이트만 하면 된다.

하지만 VARCHAR(10) 타입을 사용중이라면 기존에 4바이트 데이터가 저장되었다가 길이가 더 큰 값으로 변경되는 경우 **레코드 자체를 다른 공간으로 옮겨 저장하는 작업이 필요** 하다.

주민등록번호 처럼 항상 값의 길이가 고정이라면 CHAR 를 사용 해야한다. 값이 2 ~ 3 바이트 차이나더라도 자주 변경되는 부서 번호나 게시물 상태 값 등은 CHAR 를 사용하는 것이 좋다.
- 레코드 이동이나 분리작업이 2 ~ 3 바이트 공간 보다 비용이 더 크기 때문임.

CHAR 나 VARCHAR 뒤 크기는 해당 칼럼의 바이트 크기가 아닌 **문자의 수** 를 의미한다.
- CHAR(10) 이라면 10글자를 저장할 수 있는 공간을 의미.

`참고`
- MySQL 5.5 이전버전 까지 utf8 문자셋을 사용했지만 이는 한글자당 최대 3바이트 까지만 지원했다.
  - SMP, SIP 그 이후 플레인 문자는 저장 불가능
- 이르 해결하기 위해 utf8mb4 문자셋이 도입됨 (최대 4바이트)
- 이는 유니코드에서 지원하는 대부분의 문자를 지원함.

### 저장 공간과 스키마 변경 (Online DDL)
- VARCHAR 데이터 타입의 길이를 늘리는 작업은 경우에 따라 읽기잠금을 걸고 레코드 복사작업이 필요할 수도 있다.

```sql
CREATE TABLE test (
    id INT PRIMARY KEY,
    value VARCHAR(60)
) DEFAULT CHARSET=utf8mb4;

ALTER TABLE test MODIFY value VARCHAR(63), ALGORITHM=INPLACE, LOCK=NONE;
// 성공

ALTER TABLE test MODIFY value VARCHAR(64), ALGORITHM=INPLACE, LOCK=NONE;
// 에러 발생
```
- 기존에 길이가 60 으로 정의된 타입을 63 으로 늘릴 경우 문제가 없지만 64로 늘릴 경우 에러가 발생한다.
- 이는 VARCHAR 타입이 가지는 길이 저장 공간의 크기 때문.
- VARCHAR(60) 은 1바이트면 되지만, VARCHAR(64) 의 경우 2바이트로 변경되어야 한다.
- 문자열 길이 저장 공간의 크기가 바뀌면 MySQL 서버는 스키마를 변경하는 동안 읽기 잠금을 걸고 레코드를 복사하는 방식을 사용한다.

> 위와 같은 이유로 문자열 타입 설계시 VARCHAR 의 길이가 크게 변경될 것으로 예상된다면 길이 저장 공간의 크기가 바뀌지 않도록 조금 크게 설계하는 것이 좋다.

### 문자 집합 (CharacterSet)
- MySQL 에서 문자 집합은 문자열을 저장하는 CHAR, VARCHAR, TEXT 컬럼에만 설정이 가능하다.
- 최종적으로 칼럼 단위로 문자 집합을 관리하지만, 편의를 위해 MySQL 서버와 DB, 테이블 단위 설정 기능을 제공한다.
- 사용 가능한 문자 집합은 `SHOW CHARACTER SET` 명령으로 확인 가능하다.
- `latin` 계열 문자는 알파벳/숫자 특수문자로 구성된 문자열만 저장해도 될 때 저장 공간 절약이 가능한 문자 집합이다.
- `euckr` 은 한국어 전용이며 모든 글자는 1 ~ 2 바이트를 사용한다.
- `utf8mb4` 는 다국어 문자를 포함할 수 있는 컬럼에 사용하기 적합하다.
  - 일반적으로 1 ~ 4 바이트까지 사용함.
- `utf8` 은 한 글자 저장시 1 ~ 3 바이트 까지 사용한다.

`MySQL 문자 집합 설정 시스템 변수`
- `character_set_system`
  - MySQL 서버가 식별자 저장시 사용하는 문자 집합
  - 기본값 utf8
- `character_set_server`
  - MySQL 서버의 기본 문자 집합
  - DB 나 테이블 혹은 칼럼에 설정된게 없을 경우 이 값이 사용됨
  - 기본 값 utf8mb4
- `character_set_database`
  - MySQL DB 의 기본 문자 집합
  - DB 생성시 설정된게 없을 경우 이 값이 사용됨
  - 기본 값 utf8mb4
- `character_set_filesystem`
  - `LOAD DATA INFILE ...` 혹은 `SELECT ... INTO OUTFILE` 실행시 인자로 지정되는 파일 이름 해석시 사용되는 문자 집합
  - 파일 내용이 아닌 파일 이름을 찾을 때 사용하는 것 임을 유의.
  - 기본 값 binary
- `character_set_client`
  - MySQL 클라이언트가 보낸 문장은 `character_set_client` 에 설정된 문자 집합으로 인코딩해 MySQL 서버로 전송한다.
  - 기본 값 utf8mb4
- `character_set_connection`
  - MySQL 서버가 클라이언트로부터 받은 SQL 문장을 처리하기 위해 `character_set_connection` 의 문자 집합으로 변환한다.
  - 기본 값 utf8mb4
- `character_set_results`
  - MySQL 서버가 쿼리의 처리 결과를 클라이언트로 보낼때 사용하는 문자 집합
  - 기본 값 utf8mb4

#### 클아이언트로 부터 쿼리 요청시 문자 집합 변환
- MySQL 서버는 받은 문자열 데이터를 `character_set_connection` 에 정의된 문자 집합으로 변환한다.
- SQL 문장에서 별도로 문자 집합을 설정하는 지정자를 **인트로듀서** 라고 한다.

```sql
SELECT emp_no, first_name FROM employees WHERE first_name = _latin1'Matt';
```
- 일반적으로 인트로듀서는 문자열 리터럴 앞에 언더스코어와 문자 집합의 이름을 붙여 표현한다.

#### 처리 결과를 클라이언트로 전송할 때의 문자 집합 변환
- MySQL 서버는 쿼리의 결과를 `character_set_results` 변수에 설정된 문자 집합으로 변환해 클라이언트로 전송한다.
- 결과 셋에 포함된 칼럼값이나 메타데이터도 모두 인코딩되어 전송됨
- 변환전 문자 집합과 변환할 문자 집합이 일치한다면 문자집합 변환 작업은 모두 생략된다.

### 콜레이션 (Collation)
- 콜레이션은, **문자열 컬럼 값에 대한 비교나 정렬 순서를 위한 규칙** 이다.
  - 영문 대소문자로 처리할지, 더 크거나 작은 것으로 판단할지에 대한 규칙
- MySQL 의 모든 문자열 타입은 독립적인 문자 집합과 콜레이션을 가진다.
  - 지정하지 않을 경우 기본 문자 집합과 콜레이션이 설정됨
- 문자열 값을 비교/정렬할 때는 항상 문자 집합뿐 아닌 콜레이션 일치 여부에 따라 결과가 달라지고 쿼리 성능 또한 상당한 영향을 받는다.

#### 콜레이션의 이해
- 문자 집합은 2개 이상의 콜레이션을 가지고 있다.
- 하나의 문자 집합에 속한 콜레이션은 다른 문자 집합과 공유해 사용할 수 있다.
- 테이블이나 컬럼에 문자 집합만 설정할 경우 해당 문자 집합의 기본 콜레이션이 해당 칼럼의 콜레이션으로 지정됨.
- 콜레이션 목록은 `SHOW COLLATION` 명령으로 확인 가능

`콜레이션의 구조`
- 일반적으로 콜레이션의 이름은 2개 혹은 3개 파트로 구분되어 있다.

`3개 파트로 구성된 콜레이션`
- 첫번째는 **문자 집합의 이름**
- 두번째는 **해당 문자 집합의 하위 분류**
- 세번째는 **대소문자 구분 여부**
  - CI (Case Insensitive)
  - CS (Case Sensitive)

`2개 파트로 구성된 콜레이션`
- 첫번째는 **문자 집합의 이름**
- 두번째는 항상 `bin` 키워드가 사용된다
  - 이는 binary (이진데이터) 를 의미하고, 이진 데이터로 관리되는 컬럼은 별도 콜레이션을 가지지 않는다.

대부분의 경우 2 ~ 3개 파트로 구성되어 있지만 `utf8mb4` 의 콜레이션은 많이 복잡하다.

`utf8mb4_0900` 으로 시작하는 콜레이션에서 0900 은 **UCA (Unicode Collation Algorithm)** 의 버전을 의미.
- 이는 문자 비교 규칙 정도로 이해하면 됨.
- 2020년 기준 13.0.0 이 최신버전

`utf8mb4_0900_ai_ci` 처럼 `ai` 나 `as` 를 포함하는 경우는 액센트 문자와 그렇지 않은 문자를 동일 문자로 판단할지 여부를 결정한다.

`참고`
- MySQL 에서 문자열의 정렬이나 검색을 위한 비교 작업이 단순히 저장된 문자열 값의 인코딩된 바이트 값 (Code Point) 으로 비교하지 않음.
- 인코딩된 상태로 저장된 문자열을 가져와 각 인코딩된 바이트 값에 해당하는 콜레이션으로 일치 시킨 후 비교를 수행한다.

> 타입의 이름과 문자열의 길이, 문자 집합과 콜레이션까지 모두 일치해야 동일한 타입 이라고 볼 수 있다.

#### utf8mb4 문자 집합의 콜레이션
- 대부분 다국어 지원이  필수적이라 `utf8mb4` 문자 집합을 사용한다.
- 콜레이션의 이름에 **로케일 (Locale)** 포함 여부로 언어 종속적인 콜레이션과 비종속적인 콜레이션으로 구분할 수 있다.

| 콜레이션 | 언어 | 표기 |
| --- | --- | --- |
| utf8mb4_0900_ai_ci | N/A | 없음 |
| utf8mb4_zh_0900_as_cs | 중국어 | zh |
| utf8mb4_la_0900_ai_ci | 클래식 라틴 | la 또는 roman |
| utf8mb4_de_pb_0900_ai_ci | 독일 전화번호 안내 책자 순서 | de_pb 또는 german2 |
| utf8mb4_ja_0900_as_cs | 일본어 | ja |
| utf8mb4_ro_0900_ai_ci | 로마어 | ro 또는 romanian |
| utf8mb4_ru_0900_ai_ci | 러시아어 | ru |
| utf8mb4_es_0900_ai_ci | 현대 스페인어 | es 또는 spanish |
| utf8mb4_vi_0900_ai_ci | 베트남 | vi 또는 vietnamese |

- 언어 비종속적인 콜레이션은 **문자 셋의 기본 정렬 순서** 에 의해 정렬 및 비교가 수행되고
- 언어 종속적인 콜레이션은 해당 언어에서 정의한 순서에 따라 수행된다.
- 범용 프로그램일 경우 `utf8mb4_0900_ai_ci` 로 충분ㅇ할 것이다.

`8.0 으로 업그레이드 시 주의`
- utf8mb4 문자의 콜레이션에 주의해야 한다.
- `utfmb4_0900` 콜레이션은 8.0 에서 처음 도입되었다.
- 5.7, utf8mb4 기준 기본 콜레이션은 `utf8mb4_general_ci` 였지만 8.0에서는 `utf8mb4_0900_ai_ci` 로 변경됨
- 8.0 버전 설정파일에 별도 콜레이션 설정이 없다면 모두 `utf8mb4_0900_ai_ci` 로 초기화 된다.
- 5.7버전 부터 존재하던 테이블과 신규 생성하는 테이블의 콜레이션이 불일치 하는 문제가  발생할 수 있다.
- 이를 해결하기 위해 `default_collation_for_utf8mb4` 시스템 변수를 제공한다.
  - `utf8mb4_generai_ci` 로 설정

### 비교 방식
- MySQL 의 문자열 비교 방식은 CHAR/VARCHAR 가 거의 동일하다.
- MySQL 에서 지원하는 대부분의 문자 집합과 콜레이션은 CHAR/VARCHAR 타입 비교시 공백 문자를 붙여 길이를 일치 시킨 후 비교를 수행한다.
- 하지만 UCA 9.0.0 을 지원하며 비교 방식이 달라졌다.
- `utf8mb4_0900_bin` 콜레이션을 사용할 경우 공백이 비교 결과에 영향을 미칠 수 있음.
- 이를 확인하려면 `information_schema.COLLATIONS` 뷰의 `PAD_ATTRIBUTE` 컬럼값을 확인하면 된다.
  - `PAD SPACE` 인 경우 공백을 추가해 길이를 일치 시킨 후 비교를 수행한다.
  - `NO PAD` 의 경우 길이를 일치시키지 않고 그대로 비교하게 됨.
- 대부분의 콜레이션은 `PAD SPACE` 이고 `utf8mb4_0900` 으로 시작하는 콜레이션만 `NO PAD` 이다.
- LIKE 를 사용한 문자열 패턴 비교에서는 공백 문자가 유효 문자로 취급된다.

### 문자열 이스케이프 처리
- SQL 문장에서 사용하는 문자열은 프로그래밍 언어처럼 '\' 를 이용ㅎ애 이스케이프 처리가 가능하다.

| 이스케이프 표기 | 의미 |
| --- | --- |
| \0 | 아스키 NULL 문자 |
| \' | 홑따옴표 |
| \" | 쌍따옴표 |
| \b | 백스페이스 문자 |
| \n | 개행 문자 |
| \r | 캐리지 리턴 문자 |
| \t | 탭 문자 |
| \\ | 백슬래시 문자 |
| \% | 퍼센트 문자 |
| \_ | 언더 스코어 문자 |

## 숫자
- 숫자 타입은 **값의 정확도** 에 따라 참 값 (Exact Value) 와 근삿값 타입으로 나눌 수 있다.
  - 참 값 : 소수점 이하의 값과 상관 없이 정확히 그 값을 유지하는 것. INTEGER 를 포함한 INT, DECIMAL 타입이 있다.
  - 근삿값 : 흔히 부동 소수점이라 불리는 값. FLOAT, DOUBLE 이 있다.
- 값이 저장되는 포맷에 따라 **십진 표기법 (DECIMAL)** 과 이진 표기법 으로 나눌 수 있다.
  - 이진 표기법 : 흔히 프로그래밍 언어에서 사용하는 정수/실수 타입
    - 256 까지의 숫자를 표현할 수 있기 때문에 숫자 값을 적은 메모리나 디스크에 저장할 수 있다.
    - INTEGER/BIGINT 등 대부분의 숫자 타입
  - 십진 표기법 (DECIMAL) : 각 자리값을 표현하기 위해 4비트나 한 바이트를 사용해 표기하는 방법
    - DECIMAL 뿐이며, 돈 처럼 정확하게 관리해야하는 경우 사용한다.
- 근삿값의 경우 저장/조회시 값이 정확히 일치하지 않는다.
- 특히 `STATEMENT` 기반 포맷을 사용하는 복제에서 데이터 차이가 발생할 수 있다.
  - FLOAT/DOUBLE 같은 부동소수점 타입을 잘 사용하지 않음
- `DECIMAL` 타입은 이진 표기법을 사용하는 타입 보다 저장공간을 2배 더 사용한다.

### 정수
- `DECIMAL` 을 제외한 정수 저장시 사용가능한 타입은 5가직 ㅏ있다.
- 이들은 숫자 값의 범위만 다를 뿐 거의 차이가 없음.

| 데이터 타입 | 저장 공간 | 최솟값 (Signed) | 최솟값 (Unsigned) | 최대값 (Signed) | 최대값 (Unsigned) |
| --- | --- | --- | --- | --- | --- |
| TINYINT | 1 | -128 | 0 | 127 | 255 |
| SMALLINT | 2 | -32768 | 0 | 32767 | 65535 |
| MEDIUMINT | 3 | -8388608 | 0 | 8388607 | 16777215 |
| INT | 4 | -2147483648 | 0 | 2147483647 | 4294967295 |
| BIGINT | 8 | -263 | 0 | 263-1 | 264-1 |

- 정수타입은 `UNSIGNED` 옵션을 사용할 수 있고, 이를 명시하지 않으면 기본적으로 양수/음수를 모두 저장할 수 있다.
- 이는 조인할 때 인덱스 사용여부까지 영향을 미치진 않으며 외래키로 사용하는 칼럼이나 조인 조건이 되는 컬럼은 일치시키는 것이 좋음.

### 부동 소수점
- 부동 소수점을 저장하기 위해 `FLOAT` 과 `DOUBLE` 을 사용할 수 있다.
- 부동 소수점은 근삿값을 저장하는 방식이라 동등 비교는 사용할 수 없다.
- `FLOAT` 는 일반적으로 정밀도를 명시하지 않으면 4바이트를 사용해 유효 자릿수를 8개까지 유지 하며, 정밀도가 명시된 경우 최대 8바이트 까지 저장공간을 사용할 수 있다.
- `DOUBLE` 기준 8바이트 저장공간을 필요올 하고 최대 유효자릿수 16개 까지 유지가 가능하다.

### DECIMAL
- MySQL 에서 소수점 이하 값 까지 정확하게 관리하려면 `DECIMAL` 타입을 사용해야 하낟.
- 이는 숫자 하나를 저장하는데 1/2 바이트가 필요한다.
- `DECIMAL` 로 저장하는/2 결괏 값을 올림 처리한 만큼 바이트수가 필요하다.
- 미세하지만 `DECIMAL` 보다는 `BIGINT` 가 곱연산시 더 빠르다.
- 단순 정수 관리시 `INTEGER`, `BIGINT` 를 사용하는 것이 좋음.

### 정수 컬럼 생성시 주의
- `FLOAT`, `DOUBLE` 의 경우 저장 공간의 크기가 고정이라 정밀도를 조절한다해서 저장공간 크기가 바뀌진 않는다.
- 하지만 `DECIMAL` 타입은 저장 공간의 크기가 가변적이라 정밀도 설정시 저장공간의 크기까지 제한하므로 주의해야 함.
- 5.7 버전까지는 정수 타입생성시에도 `BIGINT(10)` 과 같이 크기를 명시하는 문법을 제공했다.
- 하지만 이는 화면에 표시할 자릿수이며 저장가능한 값을 제한하는 용도가 아니다.
- 때문에 8.0 부터 이 기능을 제거 되었다.

### 자동 증가 (AUTO_INCREMENT) 옵션
- PK 를 구성하는 컬럼의 크기가 너무 크거나 사용할만한 컬럼이 없는 경우 숫자 타입 컬럼에 자동 증가 옵션을 사용해 인조키를 생성한다.
- `auto_increment_increment` 와 `auto_increment_offset` 시스템 설정으로 자동 증가값이 얼마나 될지 변경이 가능하다.
  - 기본적으로 1로 사용된다.
- AUTO_INCREMENT 옵션을 사용한 컬럼은 반드시 해당 테이블에서 PK 나 유니크 키의 일부로 정의되어야 한다.
- 하지만 PK 나 유니크기가 여러 컬럼으로 구성되면 AUTO_INCREMENT 컬럼값의 증가 패턴이 스토리지 엔진 별로 달라진다.
  - MyISAM 은 PK 나 유니크키 아무데서나 사용될 수 있다.
  - InnoDB 는 AUTO_INCREMENT 컬럼으로 시작되는 인덱스를 생성해야 한다.
    - 뒤쪽에 배치시 에러가 발생함.
- 또한 AUTO_INCREMENT 컬럼은 테이블당 하나만 사용할 수 있다.
- 현재 증가값은 테이블의 메타 정보에 저장되어 있는데 이는 `SHOW CREATE TABLE` 명령으로 확인이 가능하다.

## 날짜와 시간
- MySQL 에서는 날짜만 저장하거나, 시간만 따로 저장할 수 있으며 날짜와 시간을 합쳐 하나에 저장할 수 있게 다양한 타입을 지원한다.
- 일반적으로 `DATE` 와 `DATETIME` 타입이 많이 사용된다.
- MySQL 5.6 버전부터 `TIME` 타입과 `DATETIME`, `TIMESTAMP` 타입은 밀리초 단위를 저장할 수 있게 되었다.
- 때문에 칼럼의 저장공간은 밀리초 단위를 몇가지까지 저장하느냐에 따라 달라지게 된다.

| 데이터 타입 | MySQL 5.6.4 이전 | MySQL 5.6.4 부터 |
| --- | --- | --- |
| YEAR | 1 바이트 | 1 바이트 | 
| DATE | 3 바이트 | 3 바이트 |
| TIME | 3 바이트 | 3 바이트 + 밀리초 공간 |
| DATETIME | 8 바이트 | 5 바이트 + 밀리초 공간 |
| TIMESTAMP | 4 바이트 | 4 바이트 + 밀리초 공간 |

- 밀리초 단위는 2 자리당 1바이트씩 공간이 더 필요하다.
- 때문에 8.0 버전에서는 마이크로초 까지 저장가능한 `DATETIME(6)` 은 8바이트 (5 + 3) 을 사용한다.

| 밀리초 단위 자리수 | 저장 공간 |
| --- | --- |
| 없음 | 0 바이트 |
| 1,2 | 1 바이트 |
| 3,4 | 2 바이트 |
| 5,6 | 3 바이트 |

- `NOW()` 함수를 사용할 때도 밀리초 자리수를 명시해야 한다. 그렇지 않을 경우 자동으로 `NOW(0)` 으로 실행됨.
- MySQL 의 날짜 타입은 컬럼 자체에 **타임존 정보가 저장되지 않음**
- 하지만 TIMESTAMP 는 항상 **UTC 타임존** 으로 저장되므로 자동 보정 된다.
- MySQL 서버의 컬럼이 `TIMESTAMP` 든 `DATETIME` 이든 관계 없이 JDBC 드라이버는 날짜 및 시간 정보를 MySQL 타임존에서 JVM 타임존으로 변환해서 출력한다.
- 또한 ORM을 사용주이라면 `DATETIME` 컬럼 값을 어떤 JDBC API 를 사용해 페치하는지, 타임존 변환을 기대하는 대로 변환하는지 테스트 해볼 것을 권장한다.
- 타임존 관련 설정은 한번 문제가 되면 해결하기 매우 어려운 문제가 될 수도 있다.

### 자동 업데이트
- MySQL 5.6 이전 버전까지는 `TIMESTAMP` 타입은 레코드의 다른 컬럼데이터가 변경될때 마다 시간이 자동업데이트 되었지만 `DATETIME` 은 그렇지 않았음.
- 5.6 버전부터는 `TIMESTAMP` `DATETIME` 모두 INSERT/UPDATE 문장 실행시 마다 해당시점으로 자동 업데이트 하려면 해당 컬럼 뒤에 **옵션** 을 명시해야 하낟.

```sql
CREATE TABLE tb_autoupdate (
    id BIGINT NOT NULL AUTO_INCREMENT,
    title VARCHAR(20),
    created_at_ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at_ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 
);
```
- `DEFAULT CURRENT_TIMESTAMP` : 레코드가 INSERT 될 떄 마다 자동으로 업데이트 한다.
- `ON UPDATE CURRENT_TIMESTAMP` : 레코드가 UPDATE 될 때 마다 자동으로 업데이트 한다.

## ENUM 과 SET
- `ENUM` 과 `SET` 은 모두 문자열 값을 MySQL 내부적으로 숫자 값으로 매핑해서 관리하는 타입이다.

### ENUM
- ENUM 타입은 테이블 구조 (메타 데이터) 에 나열된 목록 중 하나의 값을 가질 수 있다.
- ENUM 타입의 가장 큰 용도는 코드화된 값을 관리하는 것.

```sql
CREATE TABLE tb_enum (df_enum ENUM ('PROCESSING', 'FAILURE', 'SUCCESS'));
INSERT INTO tb_enum VALUES ('PROCESSING'), ('FAILURE');
SELECT * FROM tb_enum;
```
- ENUM 은, MySQL 서버가 실제 값을 디스크나 메모리에 저장할 때 사용자로 부터 요청된 문자열이 아닌 그 값에 매핑된 정수 값을 사용한다.
- ENUM 타입에 사용가능한 최대 아이템 개수는 **65,535개** 이고, 아이템개수가 255개 미만이라면 1바이트를, 그 이상인 경우 2바이트를 저장공간으로 사용하게 된다.
- 예전에는 코드테이블 형태로 많이 사용했는데, 해당 코드 값이 어떤 의미인지 이해하기가 쉽지 않았다.
- ENUM 타입은 이러한 단점을 보완할 수 있는 상당히 유용한 타입.
- 단점도 명확한데, 칼럼에 저장되는 문자열 값이 테이블의 구조가 되기 때문에 기존 ENUM 타입에 새로운 값을 추가해야 한다면 테이블의 구조가 변경되어야 한다.
  - 예전 버전에선 항상 리빌드가 필요했음.
  - 5.6 부터는 마지막에 추가되는 경우에는 메타데이터 변경만 필요하게 됨.
- 기존 ENUM 타입 아이템의 순서가 변경되거나 중간에 새롭게 추가되는 경우에는 **COPY 알고리즘과 읽기 잠금** 까지 필요하다.
- ENUM 타입은 테이블 구조에 정의된 코드 값만 사용하도록 강제한다는 장점도 있지만, 데이터베이스 서버의 디스크 공간을 줄여 준다는 것이 크다.

> ENUM 타입을 떠나 가능하면 디스크의 데이터 파일 크기는 줄이는 것이 성능과 운영에 많은 도움이 될 것이다.

### SET
- `SET` 타입도 테이블의 구조에 정의된 아이템을 정수 값으로 매핑해 저장하는 방식이다.
- `ENUM` 과의 차이는 **하나의 칼럼에 1개 이상의 값을 저장** 할 수 있다.
- MySQL 은 내부적으로 BIT-OR 연산을 거쳐 1개 이상의 선택된 값을 저장한다.
- 여러개의 값을 저장할 수 있지만, 실제 여러 개의 값을 저장하는 공간을 가지는 것이 아니게 됨.
- 각 아이템값에 매핑되는 정수값은 1씩 증가하는 것이 아닌 2n 의 값을 갖게 된다.
- `SET` 타입은 아이템 값의 멤버수가 8개 이라하면 1바이트 저장공간을, 9 ~ 16개 이하라면 2바이트 저장공간을 사용하며 같은 방식으로 최대 8바이트 까지 사용하게 된다.

```sql
CREATE TABLE tb_set (
    fd_set SET('TENNIS', 'SOCCER', 'GOLF', 'TABLE-TENNIS', 'BASKETBALL', 'BILLIARD')
);
INSERT INTO tb_set (fd_set) VALUES ('SOCCER'), ('GOLF', 'TENNIS');
```
- 동등 비교를 수행하려면, **저장된 순서대로** 문자열을 나열해야 한다.
- 인덱스가 존재하더라도 동등 비교 조건을 제외하고 `FIND_IN_SET()` 함수나 `LIKE` 를 사용하는 쿼리는 인덱스를 사용할 수 없다.
- `SET` 타입 컬럼에 대해 하나의 특정 값을 포함하고 있는지는 `FIND_IN_SET()` 함수를 사용하면 된다.
- ENUM 과 마찬가지로 아이템 중간에 새로운 아이템을 추가하는 경우 읽기 잠금과 리빌드가 필요하다.

## TEXT 와 BLOB
- MySQL 에서 대량의 데이터를 저장하려면 `TEXT` 나 `BLOB` 타입을 사용해야 한다.
- 두 타입은 많은 부분에서 거의 같은 설정이나 방식으로 동작한다.
- 유일한 차이는 `TEXT` 타입은 문자열을 저장하는 컬럼이라 문자집합이나 콜레이션을 가진다.
- 이 둘은 내부적으로 저장가능한 길이에 따라 최대 4가지로 구분한다.
  - TINYTEXT, TINYBLOB
  - TEXT, BLOB
  - MEDIUMTEXT, MEDIUMBLOB,
  - LONGTEXT, LONGBLOB
- TEXT, BLOB 타입은 사용시 주의해야 하고 남용해선 안되며, 주로 다음 과 같은 상황에서 사용한다.
  - 칼럼 하나에 저장되는 데이터 길이를 예측할수 없을만큼 클때 사용
  - 레코드의 전체 크기가 64KB 를 넘어서는 경우
- MySQL 에서 인덱스 레코드의 모든 칼럼은 **최대 제한 크기** 를 가지고 있다.
  - REDUNDANT/COMPACT 로우포맷 인 경우 767 바이트 (InnoDB)
  - DYNAMIC/COMPRESSED 로우포맷 인 경우 3072 바이트 (InnoDB)
- BLOB/TEXT 컬럼으로 정렬을 수행할 경우 `max_sort_length` 시스템 변수에 설정된 길이 까지만 정렬을 수행한다.
  - 기본적으로 1024 바이트로 설정되어 있음.
  - 정렬을 빠르게 하려면 이 값을 줄여서 설정하는 것이 좋음.
- 임시 테이블의 경우 MySQL 8.0 버전부터 TempTable 은 TEXT/BLOB 타입을 지원하지만 MEMORY 엔진은 TEXT/BLOB 을 지원하지 않는다.
  - 가능하면 `tmp_mem_storage_engine` 을 `TempTable` 로 설정하는 것이 좋음.
- BLOB/TEXT 타입이 포함된 SQL 실행시 문장이 매우 길어질 수 있다.
- `max_allowed_packet` 시스템 변수에 설정된 값 보다 크다면 오류가 발생할 수도 있음.
- 이런 경우 필요한 만큼 늘려서 사용하는 것이 좋다.
- BLOB/TEXT 타입 데이터가 어떻게 저장될지 결정하는 요소는 `ROW_FORMAT` 옵션
  - 별도 지정되어 있지 않다면 `innodb_default_row_format` 시스템 변수에 설정된 값을 사용한다.
  - 설정되어 있지 않은 경우 dynamic 이 지정됨
- MySQL 8.0 기준 지금까지 사용가능한 모든 ROW_FORMAT 에서는 가능하면 TEXT/BLOB 을 다른 레코드와 함께 저장하려고 노력한다.
- 이를 불가능하게 하는 것은 레코드의 최대 길이 제한.
- 5.6 기준 테이블 기본 ROW_FORMAT 은 COMPACT, 5.7 부터는 DYNAMIC 이다.
- COMPACT 포맷 기준 저장가능한 레코드 하나의 최대 길이는 데이터 페이지 크기 16KB 의 절반인 8126 바이트
- BLOB/TEXT 컬럼이 외부 페이지로 저장될 때 16KB 를 넘는다면 **값을 여러개로 쪼개 각 페이지에 저장하고 이를 체인으로 연결** 한다.
- 때문에 하나의 컬럼에 여러 BLOB/TEXT 가 존재한다면 하나의 레코드는 여러 외부페이지 체인을 가질 수 있다.

## JSON 타입

### 저장 방식
- MySQL 은 내부적으로 JSON 타입의 값을 `BLOB` 타입에 저장한다.
- 사용자가 입력한 값 그대로가 아닌 바이너리 포맷인 BSON 으로 변환해서 저장하기 때문에 공간 효율이 높다.
- 매우 큰 용량의 JSON 도큐먼트가 저장되면 16KB 단위로 여러 데이터 페이지로 쪼개 저장한다.
- 5.7 버전까지는 이를 단순한 **링크드 리스트** 로 관리 했다.
  - 이는 부분 업데이트 를 효율적으로 처리하지 못함.
- 8.0 버전부터는 BLOB 페이지들의 인덱스를 관리하고 실제 데이터 페이지를 링크를 갖도록 개선했다.
  - 부분 업데이트 효율이 좋아짐.

### 부분 업데이트
- 8.0 버전부터 JSON 타입의 부분 업데이트 기능을 제공한다.
- `JSON_SET()`, `JSON_REPLACE()`, `JSON_REMOVE()` 함수를 이용해 특정 필드 값을 변경하거나 삭제하는 경우에만 동작함.

```sql
UPDATE tb_json
    SET fd = JSON_SET(fd, '$.user_id', '12345')
WHERE id = 2;
```
- `JSON_SET()` 함수로 부분 업데이트로 처리됬는지 확인가능한 명확한 방법은 없다.
- `JSON_STORAGE_SIZE()` 함수와 `JSON_STORAGE_FREE()` 함수를 이용해 대략적인 예측만 그낭할 뿐이다.
- 부분 업데이트와 전체 업데이트의 성능 차이가 크게 느껴지지 않을 수 있는데, 특정 조건에서 매우 빠른 업데이트를 보여준다.

### JSON 타입 콜레이션과 비교
- JSON 컬럼에 저장되는 데이터와 결과값은 모두 utf8mb4 문자집합과 utf8mb4_bin 콜레이션을 가진다.
- 바이너리 콜레이션 이기 때문에 대소문자구분/액센트 문자 등도 구분해 비교하게 된다.

### JSON 컬럼 선택
- JSON 데이터를 저장해야 한다면 BLOB/TEXT 보단 JSON 컬럼을 선택하는 것이 부분 업데이트나 저장공간 측면에서 유리하다.
- 정규화된 컬럼과 JSON 컬럼중 어떤 것을 선택해야하는가 ?
- 만약 성능 중심으로 판단한다면 JSON 컬럼 보단 정규화된 컬럼을 추천한다.

## 가상 컬럼 (파생 칼럼)
- 다른 DBMS 에서는 가상 컬럼 (Virtual Column) 이라고 사용하지만 MySQL 에서는 Generated Column 이라고 사용한다.
- MySQL 서버의 가상 컬럼은 크게, 가상 컬럼/스토어드 컬럼으로 구분할 수 있다.

```sql
CREATE TABLE tb_virtual_column (
    id INT NOT NULL AUTO_INCREMENT,
    price DECIMAL (10, 2) NOT NULL DEFAULT '0.00',
    quantity INT NOT NULL DEFAULT 1,
    total_price DECIMAL (10, 2) AS (quantity * price) VIRTUAL
);

CREATE TABLE tb_stored_column (
    id INT NOT NULL AUTO_INCREMENT,
    price DECIMAL (10, 2) NOT NULL DEFAULT '0.00',
    quantity INT NOT NULL DEFAULT 1,
    total_price DECIMAL (10, 2) AS (quantity * price) STORED    
)
```
- 가상/스토어드 컬럼 모두 `AS` 절로 계산식을 정의하고, `STORED` 인 경우 스토어드 컬럼으로 생성된다. (그 외에는 모두 가상 컬럼임)
- 가상 컬럼의 표현식은 입력이 동일하면 결과가 항상 동일한 `DETERMINISTIC` 표현식만 가능하다.
- 8.0 버전까지는 가상 컬럼의 표현식에 서브쿼리/스토어드 프로그램을 사용할 수 없다.

`가상 컬럼과 스토어드 칼럼의 차이`
- 가상 컬럼
  - 칼럼 값이 디스크에 저장되지 않음
  - 칼럼의 구조 변경은 테이블 리빌드를 하지 않음
  - 칼럼의 값은 레코드 읽기전 또는 BEFORE 트리거 실행 직후 계산됨
- 스토어드 칼럼
  - 칼럼 값이 물리적으로 디스크에 저장됨
  - 칼럼 구조 변경은 테이블 리빌드가 필요
  - INSERT/UPDATE 시점에 칼럼 값이 계산됨

MySQL 8.0 부터 도입된 함수기반 인덱스는 가상 컬럼에 인덱스를 생성하는 방식으로 ㄹ동작한다.

둘중 어느것을 선택해야 하는지 고민이 필요하다면 다음 사항을 고려해 보는것이 좋다.
- 가상 컬럼은 데이터 조회시점에 매번 계산이 필요하기에 시간이 오래걸린다면 스토어드 컬럼으로 변경하는 것이 좋을 수 있다.
- 계산 과정은 빠르지만 저장 공간을 많이 차이하는 경우 스토어드 컬럼을 가상컬럼으로 변경하는 것이 좋을 수 있다.

> 즉 이둘의 차이는 CPU 사용률을 높혀 디스크 부하를 낮출 것인가, 디스크 사용량을 높혀 CPU 사용량을 낮출 것인가의 선택이다.


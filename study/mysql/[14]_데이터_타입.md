# 지옥 스터디 - 14 데이터 타입
- 칼럼의 데이터 타입을 선정하는 일은 물리 모델링에서 중요한 작업.
- 데이터 타입과 길이 선정시 다음 사항을 주의해야 한다.
  - 저장되는 값의 **성격에 맞는 최적의 타입** 선정
  - 가변 길이 칼럼의 경우 최적의 길이 설정
  - 조인 조건으로 사용되는 경우 동일한 데이터 타입으로 선정
- 일반적으로 저장되는 값의 특성을 고려하지 않고 가능한 최대 길이로 선택하는 것이 일반적인데, 무분별하게 크게 선정되면 디스크 는 물론 메모리/CPU 자원도 함께 낭비된다.
  - 그로 인해 SQL 성능 저하는 당연한 결과.
- 데이터 타입의 길이는 너무 넉넉해도 안되고 부족해도 문제가 된다.
- 실제 저장되는 값의 성격을 정확히 분석하고 최적의 타입과 길이를 선정하는것이 중요.

## 문자열 (CHAR 와 VARCHAR)
- 문자열 컬럼을 사용하는 경우 CHAR 와 VARCHAR 중 선택해야 하낟.
- 이 둘은 장단점을 갖고 있으며 저장 공간과 비교 방식 관점에서 이들을 살펴본다.

### 저장 공간
- CHAR 와 VARCHAR 의 공통점은 문자열 저장이 가능한 데이터 타입이다.
- 가장 큰 차이는 **고정길이** 냐, **가변길이** 냐 이다.
- 고정길이는 실제 칼럼값의 길이에 따라 저장 공간의 크기가 변하지 않음.
  - 저장 공간의 크기가 고정적 이다.
- 가변길이는 최대 저장 가능한 값의 길이는 제한되어 있지만, 그 보다 작은 값이 저장되면 그 만큼 저장공간이 줄어듦
  - 하지만 저장된 값의 크기를 가지는 메타 정보를 가지고 있어야하기 때문에 1 ~ 2 바이트 정도 저장 공간이 추가로 더 필요하다.
- VARCHAR 의 경우 문자열 길이 관리를 위한 1 ~ 2 바이트 공간을 추가로 사용한다.
  - 255 바이트 이하면 1바이트만  사용하고, 256 바이트 이상이라면 2바이트를 사용한다.
  - VARCHAR 타입의 최대 길이는 2바이트로 범위를 넘어선다면 사용할 수 없다.
  - 즉 VARCHAR 타입에 저장가능한 최대 길이는 65,536 바이트

`참고`
- MySQL 에서 하나의 레코드는 TEXT/BLOB 타입을 제외한 전체 크기가 64KB 를 초과할 수 없다.
- 만약 다른컬럼에서 40KB 를 사용하고 있다면 VARCHAR 는 24KB 가 최대값.
- 24KB 를 넘도록 생성할경우 에러가 발생하거나 자동으로 TEXT 타입으로 대체된다.
- 때문에 컬럼을 새로 추가한다면 VARCHAR 가 TEXT 타입으로 자동변환되었는지 확인하는 것이 좋다.

> 문자열 값의 길이가 항상 일정하다면 CHAR 를, 가변적이라면 VARCHAR 를 사용하는 것이 일반적이지만 문자열 길이가 정적이냐 가변적이냐 여부로만 타입을 결정하는 것은 좋지 않다.

`타입 결졍시 고려할 두 가지`
- 저장되는 문자열의 길이가 대개 비슷한가 ?
- 칼럼의 값이 자주 변경되는가 ?

> 값의 길이도 중요하지만, 해당 칼럼의 값이 얼마나 자주 변경되느냐 가 기준이 되어야 한다.

CHAR(10) 타입 사용중이라면 값 변경시 10바이트가 준비되어 있으므로 변경되는 값을 업데이트만 하면 된다.

하지만 VARCHAR(10) 타입을 사용중이라면 기존에 4바이트 데이터가 저장되었다가 길이가 더 큰 값으로 변경되는 경우 **레코드 자체를 다른 공간으로 옮겨 저장하는 작업이 필요** 하다.

주민등록번호 처럼 항상 값의 길이가 고정이라면 CHAR 를 사용 해야한다. 값이 2 ~ 3 바이트 차이나더라도 자주 변경되는 부서 번호나 게시물 상태 값 등은 CHAR 를 사용하는 것이 좋다.
- 레코드 이동이나 분리작업이 2 ~ 3 바이트 공간 보다 비용이 더 크기 때문임.

CHAR 나 VARCHAR 뒤 크기는 해당 칼럼의 바이트 크기가 아닌 **문자의 수** 를 의미한다.
- CHAR(10) 이라면 10글자를 저장할 수 있는 공간을 의미.

`참고`
- MySQL 5.5 이전버전 까지 utf8 문자셋을 사용했지만 이는 한글자당 최대 3바이트 까지만 지원했다.
  - SMP, SIP 그 이후 플레인 문자는 저장 불가능
- 이르 해결하기 위해 utf8mb4 문자셋이 도입됨 (최대 4바이트)
- 이는 유니코드에서 지원하는 대부분의 문자를 지원함.

### 저장 공간과 스키마 변경 (Online DDL)
- VARCHAR 데이터 타입의 길이를 늘리는 작업은 경우에 따라 읽기잠금을 걸고 레코드 복사작업이 필요할 수도 있다.

```sql
CREATE TABLE test (
    id INT PRIMARY KEY,
    value VARCHAR(60)
) DEFAULT CHARSET=utf8mb4;

ALTER TABLE test MODIFY value VARCHAR(63), ALGORITHM=INPLACE, LOCK=NONE;
// 성공

ALTER TABLE test MODIFY value VARCHAR(64), ALGORITHM=INPLACE, LOCK=NONE;
// 에러 발생
```
- 기존에 길이가 60 으로 정의된 타입을 63 으로 늘릴 경우 문제가 없지만 64로 늘릴 경우 에러가 발생한다.
- 이는 VARCHAR 타입이 가지는 길이 저장 공간의 크기 때문.
- VARCHAR(60) 은 1바이트면 되지만, VARCHAR(64) 의 경우 2바이트로 변경되어야 한다.
- 문자열 길이 저장 공간의 크기가 바뀌면 MySQL 서버는 스키마를 변경하는 동안 읽기 잠금을 걸고 레코드를 복사하는 방식을 사용한다.

> 위와 같은 이유로 문자열 타입 설계시 VARCHAR 의 길이가 크게 변경될 것으로 예상된다면 길이 저장 공간의 크기가 바뀌지 않도록 조금 크게 설계하는 것이 좋다.

### 문자 집합 (CharacterSet)
- MySQL 에서 문자 집합은 문자열을 저장하는 CHAR, VARCHAR, TEXT 컬럼에만 설정이 가능하다.
- 최종적으로 칼럼 단위로 문자 집합을 관리하지만, 편의를 위해 MySQL 서버와 DB, 테이블 단위 설정 기능을 제공한다.
- 사용 가능한 문자 집합은 `SHOW CHARACTER SET` 명령으로 확인 가능하다.
- `latin` 계열 문자는 알파벳/숫자 특수문자로 구성된 문자열만 저장해도 될 때 저장 공간 절약이 가능한 문자 집합이다.
- `euckr` 은 한국어 전용이며 모든 글자는 1 ~ 2 바이트를 사용한다.
- `utf8mb4` 는 다국어 문자를 포함할 수 있는 컬럼에 사용하기 적합하다.
  - 일반적으로 1 ~ 4 바이트까지 사용함.
- `utf8` 은 한 글자 저장시 1 ~ 3 바이트 까지 사용한다.

`MySQL 문자 집합 설정 시스템 변수`
- `character_set_system`
  - MySQL 서버가 식별자 저장시 사용하는 문자 집합
  - 기본값 utf8
- `character_set_server`
  - MySQL 서버의 기본 문자 집합
  - DB 나 테이블 혹은 칼럼에 설정된게 없을 경우 이 값이 사용됨
  - 기본 값 utf8mb4
- `character_set_database`
  - MySQL DB 의 기본 문자 집합
  - DB 생성시 설정된게 없을 경우 이 값이 사용됨
  - 기본 값 utf8mb4
- `character_set_filesystem`
  - `LOAD DATA INFILE ...` 혹은 `SELECT ... INTO OUTFILE` 실행시 인자로 지정되는 파일 이름 해석시 사용되는 문자 집합
  - 파일 내용이 아닌 파일 이름을 찾을 때 사용하는 것 임을 유의.
  - 기본 값 binary
- `character_set_client`
  - MySQL 클라이언트가 보낸 문장은 `character_set_client` 에 설정된 문자 집합으로 인코딩해 MySQL 서버로 전송한다.
  - 기본 값 utf8mb4
- `character_set_connection`
  - MySQL 서버가 클라이언트로부터 받은 SQL 문장을 처리하기 위해 `character_set_connection` 의 문자 집합으로 변환한다.
  - 기본 값 utf8mb4
- `character_set_results`
  - MySQL 서버가 쿼리의 처리 결과를 클라이언트로 보낼때 사용하는 문자 집합
  - 기본 값 utf8mb4

#### 클아이언트로 부터 쿼리 요청시 문자 집합 변환
- MySQL 서버는 받은 문자열 데이터를 `character_set_connection` 에 정의된 문자 집합으로 변환한다.
- SQL 문장에서 별도로 문자 집합을 설정하는 지정자를 **인트로듀서** 라고 한다.

```sql
SELECT emp_no, first_name FROM employees WHERE first_name = _latin1'Matt';
```
- 일반적으로 인트로듀서는 문자열 리터럴 앞에 언더스코어와 문자 집합의 이름을 붙여 표현한다.

#### 처리 결과를 클라이언트로 전송할 때의 문자 집합 변환
- MySQL 서버는 쿼리의 결과를 `character_set_results` 변수에 설정된 문자 집합으로 변환해 클라이언트로 전송한다.
- 결과 셋에 포함된 칼럼값이나 메타데이터도 모두 인코딩되어 전송됨
- 변환전 문자 집합과 변환할 문자 집합이 일치한다면 문자집합 변환 작업은 모두 생략된다.

### 콜레이션 (Collation)
- 콜레이션은, **문자열 컬럼 값에 대한 비교나 정렬 순서를 위한 규칙** 이다.
  - 영문 대소문자로 처리할지, 더 크거나 작은 것으로 판단할지에 대한 규칙
- MySQL 의 모든 문자열 타입은 독립적인 문자 집합과 콜레이션을 가진다.
  - 지정하지 않을 경우 기본 문자 집합과 콜레이션이 설정됨
- 문자열 값을 비교/정렬할 때는 항상 문자 집합뿐 아닌 콜레이션 일치 여부에 따라 결과가 달라지고 쿼리 성능 또한 상당한 영향을 받는다.

#### 콜레이션의 이해
- 문자 집합은 2개 이상의 콜레이션을 가지고 있다.
- 하나의 문자 집합에 속한 콜레이션은 다른 문자 집합과 공유해 사용할 수 있다.
- 테이블이나 컬럼에 문자 집합만 설정할 경우 해당 문자 집합의 기본 콜레이션이 해당 칼럼의 콜레이션으로 지정됨.
- 콜레이션 목록은 `SHOW COLLATION` 명령으로 확인 가능

`콜레이션의 구조`
- 일반적으로 콜레이션의 이름은 2개 혹은 3개 파트로 구분되어 있다.

`3개 파트로 구성된 콜레이션`
- 첫번째는 **문자 집합의 이름**
- 두번째는 **해당 문자 집합의 하위 분류**
- 세번째는 **대소문자 구분 여부**
  - CI (Case Insensitive)
  - CS (Case Sensitive)

`2개 파트로 구성된 콜레이션`
- 첫번째는 **문자 집합의 이름**
- 두번째는 항상 `bin` 키워드가 사용된다
  - 이는 binary (이진데이터) 를 의미하고, 이진 데이터로 관리되는 컬럼은 별도 콜레이션을 가지지 않는다.

대부분의 경우 2 ~ 3개 파트로 구성되어 있지만 `utf8mb4` 의 콜레이션은 많이 복잡하다.

`utf8mb4_0900` 으로 시작하는 콜레이션에서 0900 은 **UCA (Unicode Collation Algorithm)** 의 버전을 의미.
- 이는 문자 비교 규칙 정도로 이해하면 됨.
- 2020년 기준 13.0.0 이 최신버전

`utf8mb4_0900_ai_ci` 처럼 `ai` 나 `as` 를 포함하는 경우는 액센트 문자와 그렇지 않은 문자를 동일 문자로 판단할지 여부를 결정한다.

`참고`
- MySQL 에서 문자열의 정렬이나 검색을 위한 비교 작업이 단순히 저장된 문자열 값의 인코딩된 바이트 값 (Code Point) 으로 비교하지 않음.
- 인코딩된 상태로 저장된 문자열을 가져와 각 인코딩된 바이트 값에 해당하는 콜레이션으로 일치 시킨 후 비교를 수행한다.

> 타입의 이름과 문자열의 길이, 문자 집합과 콜레이션까지 모두 일치해야 동일한 타입 이라고 볼 수 있다.

#### utf8mb4 문자 집합의 콜레이션
- 대부분 다국어 지원이  필수적이라 `utf8mb4` 문자 집합을 사용한다.
- 콜레이션의 이름에 **로케일 (Locale)** 포함 여부로 언어 종속적인 콜레이션과 비종속적인 콜레이션으로 구분할 수 있다.

| 콜레이션 | 언어 | 표기 |
| --- | --- | --- |
| utf8mb4_0900_ai_ci | N/A | 없음 |
| utf8mb4_zh_0900_as_cs | 중국어 | zh |
| utf8mb4_la_0900_ai_ci | 클래식 라틴 | la 또는 roman |
| utf8mb4_de_pb_0900_ai_ci | 독일 전화번호 안내 책자 순서 | de_pb 또는 german2 |
| utf8mb4_ja_0900_as_cs | 일본어 | ja |
| utf8mb4_ro_0900_ai_ci | 로마어 | ro 또는 romanian |
| utf8mb4_ru_0900_ai_ci | 러시아어 | ru |
| utf8mb4_es_0900_ai_ci | 현대 스페인어 | es 또는 spanish |
| utf8mb4_vi_0900_ai_ci | 베트남 | vi 또는 vietnamese |

- 언어 비종속적인 콜레이션은 **문자 셋의 기본 정렬 순서** 에 의해 정렬 및 비교가 수행되고
- 언어 종속적인 콜레이션은 해당 언어에서 정의한 순서에 따라 수행된다.
- 범용 프로그램일 경우 `utf8mb4_0900_ai_ci` 로 충분ㅇ할 것이다.

`8.0 으로 업그레이드 시 주의`
- utf8mb4 문자의 콜레이션에 주의해야 한다.
- `utfmb4_0900` 콜레이션은 8.0 에서 처음 도입되었다.
- 5.7, utf8mb4 기준 기본 콜레이션은 `utf8mb4_general_ci` 였지만 8.0에서는 `utf8mb4_0900_ai_ci` 로 변경됨
- 8.0 버전 설정파일에 별도 콜레이션 설정이 없다면 모두 `utf8mb4_0900_ai_ci` 로 초기화 된다.
- 5.7버전 부터 존재하던 테이블과 신규 생성하는 테이블의 콜레이션이 불일치 하는 문제가  발생할 수 있다.
- 이를 해결하기 위해 `default_collation_for_utf8mb4` 시스템 변수를 제공한다.
  - `utf8mb4_generai_ci` 로 설정

### 비교 방식
- MySQL 의 문자열 비교 방식은 CHAR/VARCHAR 가 거의 동일하다.
- MySQL 에서 지원하는 대부분의 문자 집합과 콜레이션은 CHAR/VARCHAR 타입 비교시 공백 문자를 붙여 길이를 일치 시킨 후 비교를 수행한다.
- 하지만 UCA 9.0.0 을 지원하며 비교 방식이 달라졌다.
- `utf8mb4_0900_bin` 콜레이션을 사용할 경우 공백이 비교 결과에 영향을 미칠 수 있음.
- 이를 확인하려면 `information_schema.COLLATIONS` 뷰의 `PAD_ATTRIBUTE` 컬럼값을 확인하면 된다.
  - `PAD SPACE` 인 경우 공백을 추가해 길이를 일치 시킨 후 비교를 수행한다.
  - `NO PAD` 의 경우 길이를 일치시키지 않고 그대로 비교하게 됨.
- 대부분의 콜레이션은 `PAD SPACE` 이고 `utf8mb4_0900` 으로 시작하는 콜레이션만 `NO PAD` 이다.
- LIKE 를 사용한 문자열 패턴 비교에서는 공백 문자가 유효 문자로 취급된다.

### 문자열 이스케이프 처리
- SQL 문장에서 사용하는 문자열은 프로그래밍 언어처럼 '\' 를 이용ㅎ애 이스케이프 처리가 가능하다.

| 이스케이프 표기 | 의미 |
| --- | --- |
| \0 | 아스키 NULL 문자 |
| \' | 홑따옴표 |
| \" | 쌍따옴표 |
| \b | 백스페이스 문자 |
| \n | 개행 문자 |
| \r | 캐리지 리턴 문자 |
| \t | 탭 문자 |
| \\ | 백슬래시 문자 |
| \% | 퍼센트 문자 |
| \_ | 언더 스코어 문자 |

## 숫자
- 숫자 타입은 **값의 정확도** 에 따라 참 값 (Exact Value) 와 근삿값 타입으로 나눌 수 있다.
  - 참 값 : 소수점 이하의 값과 상관 없이 정확히 그 값을 유지하는 것. INTEGER 를 포함한 INT, DECIMAL 타입이 있다.
  - 근삿값 : 흔히 부동 소수점이라 불리는 값. FLOAT, DOUBLE 이 있다.
- 값이 저장되는 포맷에 따라 **십진 표기법 (DECIMAL)** 과 이진 표기법 으로 나눌 수 있다.
  - 이진 표기법 : 흔히 프로그래밍 언어에서 사용하는 정수/실수 타입
    - 256 까지의 숫자를 표현할 수 있기 때문에 숫자 값을 적은 메모리나 디스크에 저장할 수 있다.
    - INTEGER/BIGINT 등 대부분의 숫자 타입
  - 십진 표기법 (DECIMAL) : 각 자리값을 표현하기 위해 4비트나 한 바이트를 사용해 표기하는 방법
    - DECIMAL 뿐이며, 돈 처럼 정확하게 관리해야하는 경우 사용한다.
- 근삿값의 경우 저장/조회시 값이 정확히 일치하지 않는다.
- 특히 `STATEMENT` 기반 포맷을 사용하는 복제에서 데이터 차이가 발생할 수 있다.
  - FLOAT/DOUBLE 같은 부동소수점 타입을 잘 사용하지 않음
- `DECIMAL` 타입은 이진 표기법을 사용하는 타입 보다 저장공간을 2배 더 사용한다.

### 정수
- `DECIMAL` 을 제외한 정수 저장시 사용가능한 타입은 5가직 ㅏ있다.
- 이들은 숫자 값의 범위만 다를 뿐 거의 차이가 없음.

| 데이터 타입 | 저장 공간 | 최솟값 (Signed) | 최솟값 (Unsigned) | 최대값 (Signed) | 최대값 (Unsigned) |
| --- | --- | --- | --- | --- | --- |
| TINYINT | 1 | -128 | 0 | 127 | 255 |
| SMALLINT | 2 | -32768 | 0 | 32767 | 65535 |
| MEDIUMINT | 3 | -8388608 | 0 | 8388607 | 16777215 |
| INT | 4 | -2147483648 | 0 | 2147483647 | 4294967295 |
| BIGINT | 8 | -263 | 0 | 263-1 | 264-1 |

- 정수타입은 `UNSIGNED` 옵션을 사용할 수 있고, 이를 명시하지 않으면 기본적으로 양수/음수를 모두 저장할 수 있다.
- 이는 조인할 때 인덱스 사용여부까지 영향을 미치진 않으며 외래키로 사용하는 칼럼이나 조인 조건이 되는 컬럼은 일치시키는 것이 좋음.

### 부동 소수점
- 부동 소수점을 저장하기 위해 `FLOAT` 과 `DOUBLE` 을 사용할 수 있다.
- 부동 소수점은 근삿값을 저장하는 방식이라 동등 비교는 사용할 수 없다.
- `FLOAT` 는 일반적으로 정밀도를 명시하지 않으면 4바이트를 사용해 유효 자릿수를 8개까지 유지 하며, 정밀도가 명시된 경우 최대 8바이트 까지 저장공간을 사용할 수 있다.
- `DOUBLE` 기준 8바이트 저장공간을 필요올 하고 최대 유효자릿수 16개 까지 유지가 가능하다.

### DECIMAL
- MySQL 에서 소수점 이하 값 까지 정확하게 관리하려면 `DECIMAL` 타입을 사용해야 하낟.
- 이는 숫자 하나를 저장하는데 1/2 바이트가 필요한다.
- `DECIMAL` 로 저장하는/2 결괏 값을 올림 처리한 만큼 바이트수가 필요하다.
- 미세하지만 `DECIMAL` 보다는 `BIGINT` 가 곱연산시 더 빠르다.
- 단순 정수 관리시 `INTEGER`, `BIGINT` 를 사용하는 것이 좋음.

### 정수 컬럼 생성시 주의
- `FLOAT`, `DOUBLE` 의 경우 저장 공간의 크기가 고정이라 정밀도를 조절한다해서 저장공간 크기가 바뀌진 않는다.
- 하지만 `DECIMAL` 타입은 저장 공간의 크기가 가변적이라 정밀도 설정시 저장공간의 크기까지 제한하므로 주의해야 함.
- 5.7 버전까지는 정수 타입생성시에도 `BIGINT(10)` 과 같이 크기를 명시하는 문법을 제공했다.
- 하지만 이는 화면에 표시할 자릿수이며 저장가능한 값을 제한하는 용도가 아니다.
- 때문에 8.0 부터 이 기능을 제거 되었다.

### 자동 증가 (AUTO_INCREMENT) 옵션
- PK 를 구성하는 컬럼의 크기가 너무 크거나 사용할만한 컬럼이 없는 경우 숫자 타입 컬럼에 자동 증가 옵션을 사용해 인조키를 생성한다.
- `auto_increment_increment` 와 `auto_increment_offset` 시스템 설정으로 자동 증가값이 얼마나 될지 변경이 가능하다.
  - 기본적으로 1로 사용된다.
- AUTO_INCREMENT 옵션을 사용한 컬럼은 반드시 해당 테이블에서 PK 나 유니크 키의 일부로 정의되어야 한다.
- 하지만 PK 나 유니크기가 여러 컬럼으로 구성되면 AUTO_INCREMENT 컬럼값의 증가 패턴이 스토리지 엔진 별로 달라진다.
  - MyISAM 은 PK 나 유니크키 아무데서나 사용될 수 있다.
  - InnoDB 는 AUTO_INCREMENT 컬럼으로 시작되는 인덱스를 생성해야 한다.
    - 뒤쪽에 배치시 에러가 발생함.
- 또한 AUTO_INCREMENT 컬럼은 테이블당 하나만 사용할 수 있다.
- 현재 증가값은 테이블의 메타 정보에 저장되어 있는데 이는 `SHOW CREATE TABLE` 명령으로 확인이 가능하다.
# 지옥 스터디 - 04 예외

## 서론
- 자바 개발자가 가장 신경쓰기 귀찮아 하는것 ? -> 예외
- 예외와 관련된 코드는 자주 엉망이 되거나 무성의하게 만들어지기 쉽다.
- JdbcTemplate 을 대표로 스프링 데이터 엑세스 기능에 담겨있는 예외 처리 및 관련된 접근 방법 그리고 예외 처리시 베스트 프렉티스에 대해 살펴본다.

## 사라진 SQLException
- JdbcContext 를 JdbcTemplate 으로 변경하면서 달라진점? -> 예외를 throws 하는 부분이 사라졌다.

```java
public void deleteAll() throws SQLException {
    jdbcContext.executeSql("delete from users");    
}

public void deleteAll() {
    jdbcTemplate.update("delete from users");    
}
```

## 초난감 예외처리
- 개발자들의 코드에서 종종 발견되는 초난감 예외처리의 대표 선수들을 살펴보자.

`예외 블랙홀`

```java
try {
    // ...
} catch (SQLException e) {
        
}
```
- 예외를 잡고는 아무런 것도 하지 않는다.
- 예외 발생을 무시하고 정상적인 상황처럼 취급하는데, 이런 방식은 **지양** 해야 한다.
    - 예외가 발생했지만 무시되어 비정상적 동작을 하거나, 원인을 찾아내기가 매우 힘들다.

`초난감 예외처리 2`

```java
try {
    // ...
} catch (SQLException e) {
    System.out.println(e);
}
```

`초난감 예외처리 3`

```java
try {
    // ...
} catch (SQLException e) {
    e.printStackTrace();
}
```
- 언뜻보면 2/3은 별 문제가 없어보인다.
- 로그를 찍긴하지만, 다른 로그나 메세지에 묻히면 놓치기 쉽상이다.
- 누군가 로그를 계속 모니터링 하지않는 이상 이는 심각한 폭탄으로 남아있을 가능성이 높다.
- catch 블록을 통해 메세지 출력을 한 것은 예외 처리를 한 것이 아니다!!
    - 로그를 남길경우 **로깅 프레임워크** 를 사용하는 것이 좋다.
    - Tomcat에서 e.printStackTrace()로 콘솔에 찍힌 값은 {TOMCAT_HOME}/logs/catalina.out 에만 남는다.
    - 로깅 프레임워크를 이용하면 파일을 쪼개는 정책을 설정할 수 있고, 
    - 여러 서버의 로그를 한곳에서 모아서 보는 시스템을 활용할 수도 있다.

> SQL Exception 이 발생하는 경우 대부분은 복구하지 못하는 경우가 많다. <br/>
> 콘솔에 로그나 예외 메세지를 출력하는것은 아무런 도움이 되지 못한다.

`무의미하고 무책임한 throws`
- catch 해 봐야 해결할 방법도 없고, 매번 throws 선언도 귀찮아지기 시작하면 다음과 같은 코드가 양산된다.

```java
public void method1() throws Exception {}
public void method2() throws Exception {}
public void method3() throws Exception {}
```
- EJB 가 한창쓰일때 자주 보이던 코드이다.
- 정말 어떤 예외가 발생할 수 있는지 얻을 수 있는 정보가 없다.
- 때문에 이런 메소드를 호출하는 메소드에서도 따라서 throw Exception 를 사용하는 수 밖에 없다
- 지금까지 살펴본 방식을 어떤 경우에도 용납하지 말아야 한다.

## 예외의 종류와 특징

`Error`
- java.lang.Error 의 서브클래스들
- 시스템에 비정상적인 상황이 발생한 경우 사용된다.
- 주로 VM 에서 발생하는 것이기 때문에 애플리케이션에서 잡으려고 해선 안된다.
- OutOfMemoryError / ThreadDeath 와 가은 에러는 catch 로 잡아봤자 아무런 대응 방법이 없다.
- 시스템 레벨에서 특별한 작업을 하는것이 아니라면 이런 에러에 대한 처리는 신경쓰지 않아도 된다.

`Exception 과 체크 예외`
- java.lang.Exception 과 서브 클래스들
- 이는 개발자들이 만든 애플리케이션에서 발생할 수 있는 예외상황에서 사용된다.
- Exception 클래스는 체크 예외와 언체크 예외로 나뉜다.
- 체크 예외는 반드시 catch 로 잡거나 throws 로 던져야 한다.
- 그렇지 않으면 컴파일 에러가 발생한다.

`Exception 과 언체크 예외`
- java.lang.RuntimeException 과 서브 클래스들
- 명시적인 예외처리를 강제하지 않는다.
- 이는 주로 프로그램 오류가 있을때 발생하도록 의도된 것들이다.
  - NPE / IllegalArgumentException 과 같은 것들이다.

![JavaException](images/java_exception.png)

## 예외처리 방법

`예외 복구`
- 예외상황을 파악하고 문제를 해결해 **정상 상태로 돌려놓는 것** 이다.
- 예를 들어 IOException 이 발생했을때, 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내해 해결할 수 있다.
- 하지만 에러메세지가 사용자에게 그냥 던져지는 것은 에러복구라고 볼 수 없다.
- 예외처리가 됬다면 기능적으로는 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 **정상적으로 설계된 흐름을 따라 진행** 되어야 한다.

`예외처리 회피`
- 자신이 담당하지 않고 호출한 쪽으로 던져버리는 것이다.
- 이는 **자신이 처리하지 않고 회피** 하는 방법
- JdbcContext/JdbcTemplate 의 콜백 오브젝트를 보면 모두 예외를 throws 하고 있다.
  - 그 이유는 예외 처리의 책임이 콜백 오브젝트의 것이 아니기 때문이다.
  - 예외 처리에 대한 책임은 템플릿 (컨텍스트) 에게 있다.
- 예외를 **회피** 하는 것은 분명한 의도가 있어야한다.
- 템플릿/콜백 처럼 긴밀한 관계가 있는 다른 오브젝트에게 책임을 지게 하거나 자신을 사용하는 쪽에서 예외를 처리하는 것이 최선이라는 확신이 있어야 한다.

`예외 전환`
- 예외를 전환 하는 방법
- 회피와 비슷하게 예외를 복구해서 정상적으로 만들수 없기 때문에 메소드 밖으로 던지는 것이다.
  - 회피와의 차이점은, 그대로 던지는것이 아닌, 적절하고 의미있는 예외로 **변환** 해서 던지는 것이다.
- 예외 전환의 목적
  1. 내부에서 발생한 예외가 해당 상황에 대해 적절한 의미를 부여하지 못하는 경우
  2. 예외를 처리하기 쉽고 단순하게 만들기위해 **포장** 하는 것이다.
- 예외 전환의 경우 발생한 예외를 담아 **중첩 예외** 로 만드는 거이 좋다.
  - getCause() 를 통해 처음 발생한 예외가 무엇인지 확인할 수 있다.

```java
try {
    // ..
} catch (SQLException e) {
    throw new DuplicateUserIdException(e);    
}
```

```java
try {
    // ..
} catch (SQLException e) {
    throw new DuplicateUserIdException().initCause(e);    
}
```

## 예외처리 전략
- 런타임 예외를 보편화 하라
- 체크 예외의 활용도와 가치는 점점 떨어지고 있다.
- 대응 불가능한 체크예외라면 빨리 런타임 예외로 전환해 던지는것이 낫다. 

`SonarQube 의 Exception 관련 글`

```java
// Noncompliant - exception is lost
try { /* ... */ } catch (Exception e) { LOGGER.info("context"); }   


// Noncompliant - exception is lost (only message is preserved)       
try { /* ... */ } catch (Exception e) { LOGGER.info(e.getMessage()); }   


// Noncompliant - exception is lost 
try { /* ... */ } catch (Exception e) { throw new RuntimeException("context"); }
```

- 위와 같이 구현하는 경우 Exception 상태가 **유실** 된다.
- SonarQube 에서는 다음과 같은 방식을 권장한다.

```java
try { /* ... */ } catch (Exception e) { LOGGER.info(e); }   


try { /* ... */ } catch (Exception e) { throw new RuntimeException(e); }


try {
  /* ... */
} catch (RuntimeException e) {
  doSomething();
  throw e;
} catch (Exception e) {
  // Conversion into unchecked exception is also allowed
  throw new RuntimeException(e);
}
```

> 예외 처리시 반드시 지켜야할 핵심 원칙 <br/>
> 모든 예외는 복구 되거나 작업을 중단시키고 개발자에게 통보되어야 한다.

`The Practice Of Programming - 예외는 저수준에서 잡고, 고수준에서 처리하라`
- 일반적으로 에러는 낮은 수준에서 잡고, 높은 수준에서 처리해야 한다.
- 대부분의 경우 **호출자** 가 에러를 어떻게 처리할지 결정해야 한다.

`The Practice Of Programming - 예외적인 상황에서만 예외 처리를 하라`
- 몇몇 언어는 비정상적 상황을 감지하고 해당 상황을 벗어나기 위해 예외 매커니즘을 제공한다.
- 이를 이용해 제어 흐름을 다른데로 돌릴 수 있다.
- 문제 해결을 하면서 리턴 값을 처리해야할 떄 예외를 사용해서는 안된다.
- 예외는 제어 흐름을 건들이기 떄문에 쉽게 남용될 수 있으며 버그가 발생하기 쉽게 구조가 꼬일 수 있다.

> 정말 예외적인 경우를 대비해 예외를 아껴야 한다.

## 참고
- https://www.slipp.net/questions/350
- https://joswlv.github.io/2018/10/29/java_exception/
# 지옥 스터디 - 03 템플릿
- 템플릿이란, 바뀌는 성질이 다른 코드 중에 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분을
- 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 기법

## 다시 보는 초난감 DAO
- UserDao 에 남아있는 문제 ? -> 예외상황에 대한 처리

`초난감 DAO 의 심각한 문제`
- 기존의 코드를 살펴보면, 예외상황이 발생할 경우 **자원에 대한 회수** 가 제대로 이뤄지지 못한다.
  - 이는 초난감 DAO 와 같이 실행후 바로종료되는 간단한 프로그램일 경우 문제가 없지만, 엔터프라이즈 애플리케이션의 경우 문제가 된다.
  - 자원 누수로 인해 서버가 다운되고, 이는 서비스 장애로 이어질 수 있다.

```java
class UserDao {
    // ...
    public void deleteAll() throws SQLException {
      Connection conn = dataSource.getConnection();
      PreparedStatement ps = conn.prepareStatement("delete from users");
      ps.executeUpdate(); // 여기서 예외가 발생하면 ?.. 아래의 close 메소드들은 호출되지 못한다..!

      ps.close();
      conn.close();
    }
}
```

`리소스 반환과 close() 메소드`
- Connection 이나 PreparedStatement 에는 close() 메소드가 있다.
- 단순하게 생각하면 생성했던 것을 종료하는 것으로 볼 수 있다.
- 하지만 보통 이는 **리소스 반환** 으로 이해하는 것이 좋다.
- Connection 이나 PreparedStatement 은 보통 Pool 을 이용해서 관리한다.
- 미리 정해진 수의 Connection 을 생성해두고, 이를 필요시 할당하고, 회수하는 식으로 재사용하는 방식으로 운용된다.

`JDBCConnection Pools`
- Commons DBCP
  - JDK 버전에 맞게 Commons DBCP 버전을 선택해야 안정된 동작을 기대할 수 있다.
  - JDBC API 버전이 올라감에 따라 예외가 세밀하게 추가되었다.
  - 이를 드라이버에서 전달할 때 DBCP 가 정교한 처리를 하지 못해 오류 파악이 힘들 수 있음

| Commons DBCP | JDK | JDBC |
| --- | --- | --- |
| DBCP 2 | JDK 7 | JDBC 4.1 |
| DBCP 1.4 | JDK 6 | JDBC 4 |
| DBCP 1.3 | JDK 1.4 ~ 1.5 | JDBC 3 |

- Commons DBCP 1.4.1 버전 기준 메모리 누수 버그가 존재함
  - https://issues.apache.org/jira/browse/DBCP-330
- Commons DBCP 2 는 **하위 호환성을 보장하지 않으므로 설정시 유의** 할것
- 커넥션 풀을 저장할 때, **PoolableConnection** 타입의 커넥션을 생성하고, ConnectionEventListener 를 등록한다.
  - ConnectionEventListener 는 커넥션을 풀로 반환하기 위해 JDBC 드라이버가 호출가능한 콜백메소드가 있음

```java
public interface ConnectionEventListener extends java.util.EventListener {

  /**
   * Notifies this <code>ConnectionEventListener</code> that
   * the application has called the method <code>close</code> on its
   * representation of a pooled connection.
   *
   * @param event an event object describing the source of
   * the event
   */
  void connectionClosed(ConnectionEvent event);

  /**
   * Notifies this <code>ConnectionEventListener</code> that
   * a fatal error has occurred and the pooled connection can
   * no longer be used.  The driver makes this notification just
   * before it throws the application the <code>SQLException</code>
   * contained in the given <code>ConnectionEvent</code> object.
   *
   * @param event an event object describing the source of
   * the event and containing the <code>SQLException</code> that the
   * driver is about to throw
   */
  void connectionErrorOccurred(ConnectionEvent event);

 }
```

```java
private synchronized void allocate() {
    if (isClosed()) return;

    // First use any objects in the pool to clear the queue
    for (;;) {
        if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
            Latch latch = (Latch) _allocationQueue.removeFirst();
            latch.setPair((ObjectTimestampPair) _pool.removeFirst());
            _numInternalProcessing++;
            synchronized (latch) {
                latch.notify();
            }
        } else {
            break;
        }
    }

    // Second utilise any spare capacity to create new objects
    for(;;) {
        if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
            Latch latch = (Latch) _allocationQueue.removeFirst();
            latch.setMayCreate(true);
            _numInternalProcessing++;
            synchronized (latch) {
                latch.notify();
            }
        } else {
            break;
        }
    }
}
```

> synchronized 기반으로 동시성 제어를 한다.. 때문에 퍼포먼스 떨어짐 ㅜ

```java
 private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
        boolean success = true;
        if(_testOnReturn && !(_factory.validateObject(obj))) {
            success = false;
        } else {
            _factory.passivateObject(obj);
        }

        boolean shouldDestroy = !success;

        // Add instance to pool if there is room and it has passed validation
        // (if testOnreturn is set)
        synchronized (this) {
            if (isClosed()) {
                shouldDestroy = true;
            } else {
                if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
                    shouldDestroy = true;
                } else if(success) {
                    // borrowObject always takes the first element from the queue,
                    // so for LIFO, push on top, FIFO add to end
                    if (_lifo) {
                        _pool.addFirst(new ObjectTimestampPair(obj));
                    } else {
                        _pool.addLast(new ObjectTimestampPair(obj));
                    }
                    if (decrementNumActive) {
                        _numActive--;
                    }
                    allocate();
                }
            }
        }

        // Destroy the instance if necessary
        if(shouldDestroy) {
            try {
                _factory.destroyObject(obj);
            } catch(Exception e) {
                // ignored
            }
            // Decrement active count *after* destroy if applicable
            if (decrementNumActive) {
                synchronized(this) {
                    _numActive--;
                    allocate();
                }
            }
        }

    }
```

- Connection Pool 에 반납할때 maxIdle, 확인 후 임계치를 넘어선다면 제거해버림..!
- CursorableLinkedList 에 저장한다. (LIFO 형태)
  - ObjectTimestampPair 타입으로 저장

```java
static class ObjectTimestampPair implements Comparable {

  /** Object instance */
  Object value;

  /** timestamp */
  long tstamp;

  /**
   * Create a new ObjectTimestampPair using the given object and the current system time.
   * @param val object instance
   */
  ObjectTimestampPair(Object val) {
    this(val, System.currentTimeMillis());
  }

  /**
   * Create a new ObjectTimeStampPair using the given object and timestamp value.
   * @param val object instance
   * @param time long representation of timestamp
   */
  ObjectTimestampPair(Object val, long time) {
    value = val;
    tstamp = time;
  }
  // ...
}
```

- 커넥션 풀의 **커넥션들을 관리하는 별도의 쓰레드가 존재**
  - Evictor 쓰레드
  - **synchronized 를 이용한 모니터락을 활용해 동시성 제어** 를 한다.
- Evictor 스레드의 역할을 3가지
  1. 커넥션 풀에 존재하는 유휴 커넥션중 가장 오랫동안 사용되지 않은 커넥션을 제거한다.
    - 설정값에 기반하여 ObjectTimestampPair 에 저장된 타임스탬프와 현재 타임스탬프 값을 비교하여 처리
    - "-1" 로 지정하면 해당 기능 비활성화
  2. 커넥션 에 대해유효성 검사를 수행해 문제가 있다면 해당 커넥션을 제거한다.
  3. 커넥션의 개수가 minIdle 보다 작다면 minIdle 만큼 커넥션을 생성해 유지한다.
- Evictor 쓰레드 가 동작할 때 마다 커넥션 풀에 **락** 을 걸기 때문에 성능저하에 큰 영향이 있다.
  - 이는 서비스에 영향을 줄 수 있음

- Tomcat DBCP
  - Commons JDBC 에 비해 성능이 개선된 버전
  - JDK Concurrent 패키지에 존재하는 클래스들을 사용해 멀티쓰레드 환경에서 성능이 대폭 개선되었다.
- Hikari CP
  - TODO 정리 필요

`HikariCP Connection 누수 감지 옵션`
- datasource.hikari.leak-detection-threshold
  - 기본 값은 0 (누수를 감지하지 않겠다는 의미)
  - 최소값은 2000 ms

`예외 처리기능 적용하기`

```java
class UserDao {
    // ...
    public void deleteAll() throws SQLException {
      Connection conn = null;
      PreparedStatement ps = null;
      try {
        conn = dataSource.getConnection();
        ps = conn.prepareStatement("delete from users");
        ps.executeUpdate();
      } catch (SQLException e) {
        e.printStackTrace();
      } finally {
        if (ps != null) {
          try {
            ps.close();
          } catch (SQLException e) {
            e.printStackTrace();
          }

        }
        if (conn != null) {
          try {
            conn.close();
          } catch (SQLException e) {
            e.printStackTrace();
          }
        }
      }
    }
}
```


## 참고
- https://d2.naver.com/helloworld/5102792
# 지옥 스터디 - 01 오브젝트와 의존관계

## 서론

- 스프링은 **자바를 기반** 으로 한 기술
- 스프링이 자바에서 가장 중요하게 가치를 둔 것은 **객체지향 언어** 라는 점이다.
- 객체지향 기술의 기본으로 돌아가자는 것이 스프링의 핵심철학
- 스프링을 이해하려면 **오브젝트** 에 깊은 관심을 가져야한다.
    - 이는 오브젝트 설계로 이어진다.
- 스프링은 객체지향 설계와 구현에 대한 특정 모델이나 기법을 강요하지 않지만 어떻게 효과적으로 설계할지 명쾌한 기준을 마련해준다.

> 오늘날 스프링은 사실상 자바 표준이라고도 불린다.

## 초난감 DAO
- 사용자 정보를 JDBC API 를 사용해 DB 에 저장 및 조회가능한 DAO 만들어보기

`DAO`
- **DAO (Data Access Object)** 는 DB 를 사용해 데이터를 조회/조작 하는 기능을 전담하도록 만든 오브젝트이다.

`DAO 와 Repository`
- 이를 과연 명쾌하게 설명할 수 있을까 ?..
- **Repository** 는 **DDD (Domain Driven Design)** 의 기본 구성중 하나로 **도메인 레이어** 에 속한다.
- 이는 객체지향적인 **컬렉션 관리 인터페이스** 를 제공하기 위해 사용된다.
    - 컬렉션 관리를 위한 인터페이스가 핵심이다.
- Repository 는 도메인 모델의 일부이며, 유비쿼터스랭기쥐의 한 요소이다.
- 변경에 대한 불변식을 유지하기 위해 하나의 단위로 취급되면서 변경의 빈도가 비슷한 단위 (쉽게 생각하면 라이프 사이클이 동일한 단위) 를 객체의 집합인 **Aggregate**
  으로 묶고, Aggregate 당 하나의 Repository 를 사용한다.
    - ex) Order 와 OrderItem 이 같은 라이프사이클을 지니기 때문에 OrderRepository 를 이용해 Order 와 OrderItem 을
      OrderRepository 를 통해 관리한다.
- Repository 자체는, 퍼시스턴스 기술에 대한 어떤 가정도 하지 않으며, Repository 를 사용할 때에는 모든 Order / OrderItem 객체가 메모리에
  로드되어 있다고 가정하고 이에 접근하기 위해 Repository 를 사용한다.
- Repository 는 도메인 레이어에 속하지만, 내부에서는 Aggregate 을 관리하기 위해 퍼시스턴스 매커니즘을 사용해야한다.
- 하지만 Repository 에서 **직접 퍼시스턴스 기술이 포함된다면 Repository 를 사용하는 도메인 객체 또한 퍼시스턴스 기술에 의존** 하게 된다.
- 이를 위해 Repository 는, **인터페이스와 구현부로 분리한 후 인터페이스는 도메인 레이어에, 구현부는 퍼시스턴스 레이어에 속하게 한다.**
- 이처럼 DIP (Dependency Inversion Principle) 에 기반해 인터페이스와 구현부의 계층을 분리하는 패턴을 **Separated Interface** 라고
  한다.
- DAO 와 Repository 모두 퍼시스턴스 로직에 대한 객체지향 인터페이스를 제공하고 **도메인 로직과 퍼시스턴스 로직을 분리하는 것이 목적** 이다.
    - 하지만 그렇다고 DAO 와 Repository 를 동일한 패턴으로 취급해서는 안된다.
- **DAO (Data Access Object)** 는 본래 퍼시스턴스 로직인 **EntityBean 을 대체하기 위해 만들어진 개념** 이고, **퍼시스턴스 레이어** 에
  속한다.
- DAO 가 Repository 와 동일하게 객체지향 인터페이스를 제공하려는 의도를 가지고 있지만, **DAO 는 하부 퍼시스턴스 기술이 데이터베이스라는 사실을 숨기지
  않는다.**
- DAO 는 데이터베이스의 CRUD 쿼리가 1:1 매칭되는 오퍼레이션을 제공한다.
    - Repository 가 제공하는 오퍼레이션 보다 더 세밀하다.
- DAO 는 CoreJ2EE Patterns 에서 언급하는 것 처럼 DB 뿐 아니라 LDAP 이나 레거시 시스템과 같이 다양한 종류의 시스템과 상호작용하기 위한 **Gateway
  역할** 을 수행하지만, Repository 는 객체 컬렉션 처리에대한 책임만 가지고 있다.
- DAO 는 대부분의 경우 **Table Data Gateway Pattern** 에 따라 테이블 별로 하나의 DAO 가 존재한다.
- DAO 는 **Transaction Script Pattern** 과 함께 사용되지만, Repository 는 **Domain Model Pattern** 과 함께 사용된다.

> 이 둘의 큰 차이를 정리하면, Repository 는 도메인 레이어에 속하며, Domain Model Pattern 과 함께 사용되고 AggregateRoot 를 식별하는 과정에서 도출된다. <br/>
> DAO 는 퍼시스턴스 레이어에 속하며, Transaction Script Pattern 과 함께 사용되고, 테이블당 하나의 DAO 형태로 도출된다. <br/>
> Repository 는 객체를 관리하기 위한 컬렉션 인터페이스를 제공하는 것이 목적이고, DAO 는 외부와 통신을 위한 Gateway 역할을 수행하는 것이 목적이다. <br/>
> Repository 내부에 DAO 가 속할 수 있지만, DAO 가 Repository 를 포함 할 수는 없다. <br/>
> 한줄 요약하자면... Repository 는 추상화, 포괄적인 개념이고, DAO 는 좀 더 세부 기술에 종속되는 개념이다. (썩 만족스러운 요약은 아니다... ㅜ)

`User 객체`

- 사용자 정보를 저장하기 위한 객체이며, 오브젝트 자바빈 규약을 따르도록 설계한다.

```java
/**
 * Java Beans 규약을 따르는 User Object.
 * 최근에는 디폴트 생성자와 프로퍼티 (getter setter) 를 가진 POJO 객체를 JavaBeans 라고 표현한다.
 */
public class User {

    String id;
    String name;
    String password;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

`Java Beans`

- 자바빈즈(JavaBeans)는 자바로 작성된 소프트웨어 컴포넌트이다.
- 자바빈즈의 사양은 썬 마이크로시스템즈에서 다음과 같이 정의되었다. "빌더 형식의 개발도구에서 가시적으로 조작이 가능하고 또한 재사용이 가능한 소프트웨어 컴포넌트이다."
- 많은 측면에서 유사성을 보임에도 불구하고 자바빈즈는 엔터프라이즈 자바빈즈(EJB)와 혼동하지 말아야 한다. EJB는 자바 플랫폼, 엔터프라이즈 에디션(Java EE)의 일부로서 서버 계열의 컴포넌트이다.
- 최근에는 디폴트 생성자와 프로퍼티를 가진 POJO 객체를 JavaBeans 라고 표현한다.

`Java Beans 의 관례`

- 클래스는 직렬화 되어야 한다.
- 클래스는 기본 생성자를 가지고 있어야 한다.
- 클래스의 속성들은 get, set 또는 표준 명명법을 따르는 메소드를 사용해 접근할 수 있어야 한다.
- 클래스는 필요한 이벤트를 처리가능한 메소드들을 포함하고 있어야 한다.

```java
class User implements Serializable {

    private String id;
    private String name;
    private String password;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

`UserTable.sql`

- 사용자의 아이디, 이름, 패스워드를 가지는 간단한 users 테이블
```java
create table users (
    id varchar (10) primary key,
    name varchar (20) not null,
    password varchar (10) not null
);
```

`UserDao`
- UserDAO 는 사용자 정보를 DB 에 넣고 관리하는 클래스이다.
- 우선 새로운 사용자를 등록하고, 아이디를 가지고 사용자 정보를 읽어오는 기능을 만들어본다.

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");

        PreparedStatement ps = conn.prepareStatement(
            "insert into users (id, name, password) values (?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        conn.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");

        PreparedStatement ps = conn.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        conn.close();
        return user;
    }
}
```

`JDBC API 를 사용하는 일반적인 작업 순서`
1. DB 연결을 위한 Connection 을 얻어온다.
2. SQL 을 담은 Statement or PreparedStatement 를 생성한다.
3. 생성된 Statement 를 실행한다.
4. 조회 SQL 이라면 실행 결과를 ResultSet 으로 받아 정보를 저장할 오브젝트에 매핑한다.
5. 작업중 생성된 리소스는 반드시 정리해 주어야한다. (Connection, Statement 등..)
6. JDBC API 가 던지는 예외를 직접 처리하거나, throws 로 처리한다.

`Statement, PreparedStatement`
- Statement, PreparedStatement 의 차이점은 **Prepared (준비된)** 이라는 이름에서도 알 수 있듯이 캐싱 여부의 차이이다.
- 기본적으로 Statement 를 매번 쿼리를 수행할때 마다 3단계를 거쳐 수행한다.
1. 쿼리 분석
2. 컴파일
3. 실행
- 위 단계를 거치는데 PreparedStatement 를 사용하면 매 실행마다 이를 캐싱해서 쿼리 실행시간을 줄여준다.
- PreparedStatement 는 ClientSide 에서 수행할 것인지, ServerSide 에서 수행할 것인지 설정이 가능하다.

`ClientSide/ServerSide`
- ClientSide PreparedStatement
  - 초기 MySQL 서버가 PreparedStatement 를 지원하지 못하던 시절 Client JDBC Driver 에서 PreparedStatement 를 흉내낼 수 있도록(표준 준수) ClientSide PreparedStatement 를 지원하던 방식
- ServerSide PreparedStatement
  - MySQL 서버에서 PreparedStatement 를 지원하게 되면서 실제 ClientSide 에서 PreparedStatement 가 아닌 타 RDBMS 와 동일한 방식의 PreparedStatement 기능을 지원하기 시작

`PrepareStatement deep dive`
- 서버사이드에서 PreparedStatement 를 사용할 것인지 / 클라이언트에서 PreparedStatement 를 사용할 것인지 판단..
- dataSource 설정시 **useServerPrepStmts** property 를 이용해 지정한다. 
  - 서버사이드로 지정할 경우 버그의 영향을 받을 수 있다. (**MySQL 5.7.18** 버전 기준 fix 됨!!)
  - MySQL 5.7.17 이하 버전 / Server-side PreparedStatement 를 사용하고, Statement 기반 Replication 설정일때, Datetime 컬럼에 밀리초 저장시 발생한다.
  - 조금 치명적인 버그다..
  - https://bugs.mysql.com/bug.php?id=74550
  
- [MySQL 에서 권장하는 HikariCP 옵션](https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration)

```java
class ConnectionImpl extends ConnectionPropertiesImpl implements MySQLConnection {
    // ....
  public java.sql.PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
    synchronized (getConnectionMutex()) {
      checkClosed();

      //
      // FIXME: Create warnings if can't create results of the given type or concurrency
      //
      PreparedStatement pStmt = null;

      boolean canServerPrepare = true;

      String nativeSql = getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;

      if (this.useServerPreparedStmts && getEmulateUnsupportedPstmts()) {
        canServerPrepare = canHandleAsServerPreparedStatement(nativeSql);
      }

      if (this.useServerPreparedStmts && canServerPrepare) {
        if (this.getCachePreparedStatements()) {
          synchronized (this.serverSideStatementCache) {
            pStmt = this.serverSideStatementCache.remove(new CompoundCacheKey(this.database, sql));

            if (pStmt != null) {
              ((com.mysql.jdbc.ServerPreparedStatement) pStmt).setClosed(false);
              pStmt.clearParameters();
            }

            if (pStmt == null) {
              try {
                pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, this.database, resultSetType,
                        resultSetConcurrency);
                if (sql.length() < getPreparedStatementCacheSqlLimit()) {
                  ((com.mysql.jdbc.ServerPreparedStatement) pStmt).isCached = true;
                }

                pStmt.setResultSetType(resultSetType);
                pStmt.setResultSetConcurrency(resultSetConcurrency);
              } catch (SQLException sqlEx) {
                // Punt, if necessary
                if (getEmulateUnsupportedPstmts()) {
                  pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, false);

                  if (sql.length() < getPreparedStatementCacheSqlLimit()) {
                    this.serverSideStatementCheckCache.put(sql, Boolean.FALSE);
                  }
                } else {
                  throw sqlEx;
                }
              }
            }
          }
        } else {
          try {
            pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, this.database, resultSetType, resultSetConcurrency);

            pStmt.setResultSetType(resultSetType);
            pStmt.setResultSetConcurrency(resultSetConcurrency);
          } catch (SQLException sqlEx) {
            // Punt, if necessary
            if (getEmulateUnsupportedPstmts()) {
              pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, false);
            } else {
              throw sqlEx;
            }
          }
        }
      } else {
        pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, false);
      }

      return pStmt;
    }
  }

  public java.sql.PreparedStatement clientPrepareStatement(String sql, int resultSetType, int resultSetConcurrency, boolean processEscapeCodesIfNeeded)
          throws SQLException {
    checkClosed();

    String nativeSql = processEscapeCodesIfNeeded && getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;

    PreparedStatement pStmt = null;

    if (getCachePreparedStatements()) {
      PreparedStatement.ParseInfo pStmtInfo = this.cachedPreparedStatementParams.get(nativeSql);

      if (pStmtInfo == null) {
        pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, this.database);

        this.cachedPreparedStatementParams.put(nativeSql, pStmt.getParseInfo());
      } else {
        pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, this.database, pStmtInfo);
      }
    } else {
      pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, this.database);
    }

    pStmt.setResultSetType(resultSetType);
    pStmt.setResultSetConcurrency(resultSetConcurrency);

    return pStmt;
  }
}
```

## 참고
- https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EB%B9%88%EC%A6%88
- http://minsql.com/mysql/MySQL-Bug-when-using-server-side-prepared-statements/
- https://2ssue.github.io/programming/HikariCP-MySQL/
- https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration

# 지옥 스터디 - 01 오브젝트와 의존관계

## 서론

- 스프링은 **자바를 기반** 으로 한 기술
- 스프링이 자바에서 가장 중요하게 가치를 둔 것은 **객체지향 언어** 라는 점이다.
- 객체지향 기술의 기본으로 돌아가자는 것이 스프링의 핵심철학
- 스프링을 이해하려면 **오브젝트** 에 깊은 관심을 가져야한다.
    - 이는 오브젝트 설계로 이어진다.
- 스프링은 객체지향 설계와 구현에 대한 특정 모델이나 기법을 강요하지 않지만 어떻게 효과적으로 설계할지 명쾌한 기준을 마련해준다.

> 오늘날 스프링은 사실상 자바 표준이라고도 불린다.

## 초난감 DAO

- 사용자 정보를 JDBC API 를 사용해 DB 에 저장 및 조회가능한 DAO 만들어보기

`DAO`

- **DAO (Data Access Object)** 는 DB 를 사용해 데이터를 조회/조작 하는 기능을 전담하도록 만든 오브젝트이다.

`DAO 와 Repository`

- 이를 과연 명쾌하게 설명할 수 있을까 ?..
- **Repository** 는 **DDD (Domain Driven Design)** 의 기본 구성중 하나로 **도메인 레이어** 에 속한다.
- 이는 객체지향적인 **컬렉션 관리 인터페이스** 를 제공하기 위해 사용된다.
    - 컬렉션 관리를 위한 인터페이스가 핵심이다.
- Repository 는 도메인 모델의 일부이며, 유비쿼터스랭기쥐의 한 요소이다.
- 변경에 대한 불변식을 유지하기 위해 하나의 단위로 취급되면서 변경의 빈도가 비슷한 단위 (쉽게 생각하면 라이프 사이클이 동일한 단위) 를 객체의 집합인 **Aggregate**
  으로 묶고, Aggregate 당 하나의 Repository 를 사용한다.
    - ex) Order 와 OrderItem 이 같은 라이프사이클을 지니기 때문에 OrderRepository 를 이용해 Order 와 OrderItem 을
      OrderRepository 를 통해 관리한다.
- Repository 자체는, 퍼시스턴스 기술에 대한 어떤 가정도 하지 않으며, Repository 를 사용할 때에는 모든 Order / OrderItem 객체가 메모리에
  로드되어 있다고 가정하고 이에 접근하기 위해 Repository 를 사용한다.
- Repository 는 도메인 레이어에 속하지만, 내부에서는 Aggregate 을 관리하기 위해 퍼시스턴스 매커니즘을 사용해야한다.
- 하지만 Repository 에서 **직접 퍼시스턴스 기술이 포함된다면 Repository 를 사용하는 도메인 객체 또한 퍼시스턴스 기술에 의존** 하게 된다.
- 이를 위해 Repository 는, **인터페이스와 구현부로 분리한 후 인터페이스는 도메인 레이어에, 구현부는 퍼시스턴스 레이어에 속하게 한다.**
- 이처럼 DIP (Dependency Inversion Principle) 에 기반해 인터페이스와 구현부의 계층을 분리하는 패턴을 **Separated Interface** 라고
  한다.
- DAO 와 Repository 모두 퍼시스턴스 로직에 대한 객체지향 인터페이스를 제공하고 **도메인 로직과 퍼시스턴스 로직을 분리하는 것이 목적** 이다.
    - 하지만 그렇다고 DAO 와 Repository 를 동일한 패턴으로 취급해서는 안된다.
- **DAO (Data Access Object)** 는 본래 퍼시스턴스 로직인 **EntityBean 을 대체하기 위해 만들어진 개념** 이고, **퍼시스턴스 레이어** 에
  속한다.
- DAO 가 Repository 와 동일하게 객체지향 인터페이스를 제공하려는 의도를 가지고 있지만, **DAO 는 하부 퍼시스턴스 기술이 데이터베이스라는 사실을 숨기지
  않는다.**
- DAO 는 데이터베이스의 CRUD 쿼리가 1:1 매칭되는 오퍼레이션을 제공한다.
    - Repository 가 제공하는 오퍼레이션 보다 더 세밀하다.
- DAO 는 CoreJ2EE Patterns 에서 언급하는 것 처럼 DB 뿐 아니라 LDAP 이나 레거시 시스템과 같이 다양한 종류의 시스템과 상호작용하기 위한 **Gateway
  역할** 을 수행하지만, Repository 는 객체 컬렉션 처리에대한 책임만 가지고 있다.
- DAO 는 대부분의 경우 **Table Data Gateway Pattern** 에 따라 테이블 별로 하나의 DAO 가 존재한다.
- DAO 는 **Transaction Script Pattern** 과 함께 사용되지만, Repository 는 **Domain Model Pattern** 과 함께 사용된다.

> 이 둘의 큰 차이를 정리하면, Repository 는 도메인 레이어에 속하며, Domain Model Pattern 과 함께 사용되고 AggregateRoot 를 식별하는 과정에서 도출된다. <br/>
> DAO 는 퍼시스턴스 레이어에 속하며, Transaction Script Pattern 과 함께 사용되고, 테이블당 하나의 DAO 형태로 도출된다. <br/>
> Repository 는 객체를 관리하기 위한 컬렉션 인터페이스를 제공하는 것이 목적이고, DAO 는 외부와 통신을 위한 Gateway 역할을 수행하는 것이 목적이다. <br/>
> Repository 내부에 DAO 가 속할 수 있지만, DAO 가 Repository 를 포함 할 수는 없다. <br/>
> 한줄 요약하자면... Repository 는 추상화, 포괄적인 개념이고, DAO 는 좀 더 세부 기술에 종속되는 개념이다. (썩 만족스러운 요약은 아니다... ㅜ)

`User 객체`

- 사용자 정보를 저장하기 위한 객체이며, 오브젝트 자바빈 규약을 따르도록 설계한다.

```java
/**
 * Java Beans 규약을 따르는 User Object.
 * 최근에는 디폴트 생성자와 프로퍼티 (getter setter) 를 가진 POJO 객체를 JavaBeans 라고 표현한다.
 */
public class User {

    String id;
    String name;
    String password;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

`Java Beans`

- 자바빈즈(JavaBeans)는 자바로 작성된 소프트웨어 컴포넌트이다.
- 자바빈즈의 사양은 썬 마이크로시스템즈에서 다음과 같이 정의되었다. "빌더 형식의 개발도구에서 가시적으로 조작이 가능하고 또한 재사용이 가능한 소프트웨어 컴포넌트이다."
- 많은 측면에서 유사성을 보임에도 불구하고 자바빈즈는 엔터프라이즈 자바빈즈(EJB)와 혼동하지 말아야 한다. EJB는 자바 플랫폼, 엔터프라이즈 에디션(Java EE)의 일부로서
  서버 계열의 컴포넌트이다.
- 최근에는 디폴트 생성자와 프로퍼티를 가진 POJO 객체를 JavaBeans 라고 표현한다.

`Java Beans 의 관례`

- 클래스는 직렬화 되어야 한다.
- 클래스는 기본 생성자를 가지고 있어야 한다.
- 클래스의 속성들은 get, set 또는 표준 명명법을 따르는 메소드를 사용해 접근할 수 있어야 한다.
- 클래스는 필요한 이벤트를 처리가능한 메소드들을 포함하고 있어야 한다.

```java
class User implements Serializable {

    private String id;
    private String name;
    private String password;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

`UserTable.sql`

- 사용자의 아이디, 이름, 패스워드를 가지는 간단한 users 테이블

```java
create table users(
    id varchar(10)primary key,
    name varchar(20)not null,
    password varchar(10)not null
    );
```

`UserDao`

- UserDAO 는 사용자 정보를 DB 에 넣고 관리하는 클래스이다.
- 우선 새로운 사용자를 등록하고, 아이디를 가지고 사용자 정보를 읽어오는 기능을 만들어본다.

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");

        PreparedStatement ps = conn.prepareStatement(
            "insert into users (id, name, password) values (?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        conn.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");

        PreparedStatement ps = conn.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        conn.close();
        return user;
    }
}
```

`JDBC API 를 사용하는 일반적인 작업 순서`

1. DB 연결을 위한 Connection 을 얻어온다.
2. SQL 을 담은 Statement or PreparedStatement 를 생성한다.
3. 생성된 Statement 를 실행한다.
4. 조회 SQL 이라면 실행 결과를 ResultSet 으로 받아 정보를 저장할 오브젝트에 매핑한다.
5. 작업중 생성된 리소스는 반드시 정리해 주어야한다. (Connection, Statement 등..)
6. JDBC API 가 던지는 예외를 직접 처리하거나, throws 로 처리한다.

`Statement, PreparedStatement`

- Statement, PreparedStatement 의 차이점은 **Prepared (준비된)** 이라는 이름에서도 알 수 있듯이 캐싱 여부의 차이이다.
- 기본적으로 Statement 를 매번 쿼리를 수행할때 마다 3단계를 거쳐 수행한다.

1. 쿼리 분석
2. 컴파일
3. 실행

- 위 단계를 거치는데 PreparedStatement 를 사용하면 매 실행마다 이를 캐싱해서 쿼리 실행시간을 줄여준다.
- PreparedStatement 는 ClientSide 에서 수행할 것인지, ServerSide 에서 수행할 것인지 설정이 가능하다.

`ClientSide/ServerSide`

- ClientSide PreparedStatement
    - 초기 MySQL 서버가 PreparedStatement 를 지원하지 못하던 시절 Client JDBC Driver 에서 PreparedStatement 를 흉내낼 수
      있도록(표준 준수) ClientSide PreparedStatement 를 지원하던 방식
- ServerSide PreparedStatement
    - MySQL 서버에서 PreparedStatement 를 지원하게 되면서 실제 ClientSide 에서 PreparedStatement 가 아닌 타 RDBMS 와 동일한
      방식의 PreparedStatement 기능을 지원하기 시작

`PrepareStatement deep dive`

- 서버사이드에서 PreparedStatement 를 사용할 것인지 / 클라이언트에서 PreparedStatement 를 사용할 것인지 판단..
- dataSource 설정시 **useServerPrepStmts** property 를 이용해 지정한다.
    - 서버사이드로 지정할 경우 버그의 영향을 받을 수 있다. (**MySQL 5.7.18** 버전 기준 fix 됨!!)
    - MySQL 5.7.17 이하 버전 / Server-side PreparedStatement 를 사용하고, Statement 기반 Replication 설정일때,
      Datetime 컬럼에 밀리초 저장시 발생한다.
    - 조금 치명적인 버그다..
    - https://bugs.mysql.com/bug.php?id=74550

- [MySQL 에서 권장하는 HikariCP 옵션](https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration)

```java
class ConnectionImpl extends ConnectionPropertiesImpl implements MySQLConnection {

    // ....
    public java.sql.PreparedStatement prepareStatement(String sql, int resultSetType,
        int resultSetConcurrency) throws SQLException {
        synchronized (getConnectionMutex()) {
            checkClosed();

            //
            // FIXME: Create warnings if can't create results of the given type or concurrency
            //
            PreparedStatement pStmt = null;

            boolean canServerPrepare = true;

            String nativeSql = getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;

            if (this.useServerPreparedStmts && getEmulateUnsupportedPstmts()) {
                canServerPrepare = canHandleAsServerPreparedStatement(nativeSql);
            }

            if (this.useServerPreparedStmts && canServerPrepare) {
                if (this.getCachePreparedStatements()) {
                    synchronized (this.serverSideStatementCache) {
                        pStmt = this.serverSideStatementCache.remove(
                            new CompoundCacheKey(this.database, sql));

                        if (pStmt != null) {
                            ((com.mysql.jdbc.ServerPreparedStatement) pStmt).setClosed(false);
                            pStmt.clearParameters();
                        }

                        if (pStmt == null) {
                            try {
                                pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(),
                                    nativeSql, this.database, resultSetType,
                                    resultSetConcurrency);
                                if (sql.length() < getPreparedStatementCacheSqlLimit()) {
                                    ((com.mysql.jdbc.ServerPreparedStatement) pStmt).isCached = true;
                                }

                                pStmt.setResultSetType(resultSetType);
                                pStmt.setResultSetConcurrency(resultSetConcurrency);
                            } catch (SQLException sqlEx) {
                                // Punt, if necessary
                                if (getEmulateUnsupportedPstmts()) {
                                    pStmt = (PreparedStatement) clientPrepareStatement(nativeSql,
                                        resultSetType, resultSetConcurrency, false);

                                    if (sql.length() < getPreparedStatementCacheSqlLimit()) {
                                        this.serverSideStatementCheckCache.put(sql, Boolean.FALSE);
                                    }
                                } else {
                                    throw sqlEx;
                                }
                            }
                        }
                    }
                } else {
                    try {
                        pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(),
                            nativeSql, this.database, resultSetType, resultSetConcurrency);

                        pStmt.setResultSetType(resultSetType);
                        pStmt.setResultSetConcurrency(resultSetConcurrency);
                    } catch (SQLException sqlEx) {
                        // Punt, if necessary
                        if (getEmulateUnsupportedPstmts()) {
                            pStmt = (PreparedStatement) clientPrepareStatement(nativeSql,
                                resultSetType, resultSetConcurrency, false);
                        } else {
                            throw sqlEx;
                        }
                    }
                }
            } else {
                pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType,
                    resultSetConcurrency, false);
            }

            return pStmt;
        }
    }

    public java.sql.PreparedStatement clientPrepareStatement(String sql, int resultSetType,
        int resultSetConcurrency, boolean processEscapeCodesIfNeeded)
        throws SQLException {
        checkClosed();

        String nativeSql =
            processEscapeCodesIfNeeded && getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql)
                : sql;

        PreparedStatement pStmt = null;

        if (getCachePreparedStatements()) {
            PreparedStatement.ParseInfo pStmtInfo = this.cachedPreparedStatementParams.get(
                nativeSql);

            if (pStmtInfo == null) {
                pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getMultiHostSafeProxy(),
                    nativeSql, this.database);

                this.cachedPreparedStatementParams.put(nativeSql, pStmt.getParseInfo());
            } else {
                pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getMultiHostSafeProxy(),
                    nativeSql, this.database, pStmtInfo);
            }
        } else {
            pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql,
                this.database);
        }

        pStmt.setResultSetType(resultSetType);
        pStmt.setResultSetConcurrency(resultSetConcurrency);

        return pStmt;
    }
}
```

`UserDAO 테스트`

- 코드의 기능을 검증하기 위한 가장 간단한 방법은 **오브젝트 스스로 자신을 검증** 하는것
- main 메소드를 이용해 셀프 테스트를 만들어보자.

```java
public static void main(String[]args)throws SQLException,ClassNotFoundException{
    UserDao dao=new UserDao();

    User user=new User();
    user.setId("ncucu");
    user.setName("엔꾸꾸");
    user.setPassword("패스워드");

    dao.add(user);

    System.out.println(user.getId()+"등록 성공");

    User findUser=dao.get(user.getId());
    System.out.println(findUser.getName());
    }
```

## DAO 의 분리

`관심사의 분리`

- 객체지향의 세계에선 모든 것이 변한다.
    - 이는 단순 변수나 필드값이 아닌 설계와 구현 코드가 변한다는 의미
- 사용자의 비즈니스와 요구사항은 끊임없이 변한다.
- 개발자가 객체 설계시 가장 염두할 것은 **미래의 변화 에 대비** 가 되어야한다.
    - 가장 중요한 것은 변화에 어떻게 대비할 것인가 ?
    - **변화의 폭을 최소한으로 줄이는 것**
- **모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.**
    - 문제는 이에 따른 작업은 한 곳에 집중되어 있지 않은 경우가 많다.
- 이를 위해 필요한 것은 **관심이 한 군데에 집중되게 하는것** 이다.
    - 프로그래밍 기초 개념중 **관심사의 분리 (Separation of Concerns)**

`UserDao 의 관심사`

1. DB 연결을 위한 커넥션 맺기
2. 사용자 등록을 위한 DB 에 SQL 을 만들어 실행하기
3. 작업이 종료되면 리소스 정리하기

> 현재 가장 문제인 DB 연결을 위한 커넥션 맺기를 관심사 분리를 시도해보자.

`중복 코드 메소드 추출`

- 현재 구현의 가장 큰 문제 ? -> 모든 메서드마다 커넥션을 획득하기 위한 코드가 중복되어 있다.
- 가장 쉬운 STEP 부터 시작 -> 메소드로 추출하기

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection conn = getConnection();

        PreparedStatement ps = conn.prepareStatement(
            "insert into users (id, name, password) values (?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        conn.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection conn = getConnection();

        PreparedStatement ps = conn.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        conn.close();
        return user;
    }

    private Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");
    }

    /**
     * Self-Test 용 Main 메소드
     */
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new UserDao();

        User user = new User();
        user.setId("ncucu");
        user.setName("엔꾸꾸");
        user.setPassword("패스워드");

        dao.add(user);

        System.out.println(user.getId() + "등록 성공");

        User findUser = dao.get(user.getId());
        System.out.println(findUser.getName());
    }
}
```

- 커넥션을 획득하기 위한 코드를 getConnection() 메소드로 추출했다.
- 이로 인해 커넥션을 획득하는 방법 (DB 변경, 접속정보 변경 등..) 이 변경되더라도 getConnection() 메소드 하나만 수정하면 된다.
- 이런 작업을 **리팩토링 (Refactoring)** 이라고 한다.
- 리팩토링은 객체지향 개발자라면 반드시 익혀야하는 기법 중 하나

`리팩토링 (Refactoring)`

- 리팩토링은 기존의 코드를 외부의 동작방식 변화없이 내부 구조를 변경해서 재구성하는 작업
- 코드 내부설계가 개선되어 이해하기 쉽고 변화에 효율적으로 대응할 수 있다.
- 리팩토링이 필요한 코드의 특징을 **나쁜 냄새, 냄새나는 코드** 라고 표현한다.
- 대표적으로 앞서 구현했던 초난감 DAO 의 중복코드가 있다.

`상속을 통한 확장`

- 만약 UserDao 가 업계에서 인기를 끌어 N 사와 D 사에서 구매한다는 요구사항이 생겼다고 가정해보자.
- 하지만 이를 납품하는 과정에서 문제가 발생한다.
    - N 사와 D 사가 서로 다른 DB를 사용하고 있고, DB 커넥션을 가져오는데 독립적인 방법을 사용한다.
    - UserDao 를 구매한 이후에도 DB 커넥션을 가져오는 방식이 종종 변경될 수 있다.
- UseDao 소스를 제공하지 않고도 고객 스스로 원하는 DB 커넥션 생성 방식을 적용할 순 없을까 ?

![UserDao](./images/Inheritance_UserDao.png)

```java
public abstract class UserDao {

    // ...
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {

    @Override
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");
    }
}

public class DUserDao extends UserDao {

    @Override
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");
    }
}
```

- DAO 의 핵심 기능인, **데이터를 어떻게 등록하고 가져올 것** 인가 에 대한 관심을 가진 UserDao
- **DB 연결 방법을 어떻게 할 것인가** 의 관심을 가진 NUserDao, DUserDao 가 클래스로서 분리되어 있다.
- 클래스 계층구조를 통해 **두 개의 관심이 독립적으로 분리** 되면서 변경 작업은 한층 용이해 졌다.
- 이제 UserDao 는 새로운 고객사가 생기더라도 UserDao 에는 변경 없이 확장이 가능해 진것이다.
- 이는 **템플릿 메소드 패턴 (Template Method Pattern)** / **팩토리 메소드 패턴 (Factory Method Pattern)** 을 사용해 개선한
  방식이다.

`템플릿 메소드 패턴 (Template Method Pattern)`

- 템플릿 메소드 패턴을 한 줄로 표현한다면, **상위 클래스의 템플릿 메소드에서 하위 클래스가 오버라이딩한 메소드를 호출하는 패턴** 이다.
- 상위 클래스에는 **공통 로직을 수행하는 템플릿 메소드** 와 **구현을 강제하는 추상 메소드**, 그리고 **선택적 오버라이딩이 가능한 훅 메소드가 존재** 한다.
- 강아지와 고양이가 있다고 가정하고, 각 동물들고 즐거운 시간을 보내는것을 코드로 표현하면 다음과 같을 것이다.

```java
public class Dog {

    public void play() {
        System.out.println("이리온");
        System.out.println("멍멍");
        System.out.println("살랑살랑 ~ ");
        System.out.println("잘했어 ");
    }
}

public class Cat {

    public void play() {
        System.out.println("이리온");
        System.out.println("야옹야옹");
        System.out.println("살랑살랑 ~ ");
        System.out.println("잘했어 ");
    }
}
```

- 강아지와 고양이 클래스를 살펴보면 중복되는 부분이 있다.
- "이리온" 하고 동물을 부르는 행동, 그리고 "살랑살랑 ~" 하고 동물이 행동하는 부분 마지막으로 "잘했어" 하고 칭찬하는 부분
- 여기에 템플릿 메소드패턴을 적용해보자면 다음과 같다.

```java
public abstract class Animal {

    public void play() {
        System.out.println("이리온");
        cry();
        doSomething();
        System.out.println("잘했어 ");
    }

    abstract void cry();

    void doSomething() {
        System.out.println("살랑살랑 ~ ");
    }
}

public class Dog extends Animal {

    @Override
    public void cry() {
        System.out.println("멍멍");
    }
}

public class Cat extends Animal {

    @Override
    public void cry() {
        System.out.println("야옹야옹");
    }
}
```

- 강아지와 고양이의 상위 클래스인 Animal 클래스를 정의하고 play 라는 **템플릿 메소드를 정의** 한다.
- 강아지와 고양이는 울음소리를 내는 방식이 다르기 때문에 구현을 강제하는 **cry 라는 추상메소드** 가 존재한다.
- 살랑살랑 ~ 이라는 동물의 행동은 선택적으로 오버라이딩 할 수 있는 **훅 메소드로 제공** 한다.

`팩토리 메소드 패턴 (Factory Method Pattern)`

- 팩토리는 공장을 의미한다. 객체지향에서의 팩토리는 **객체를 생성** 한다.
- 팩토리 메소드 패턴을 한줄로 표현하자면 **오버라이드한 메소드가 객체를 반환하는 패턴** 이라고 표현할 수 있다.
- 좀 더 쉽게 설명하면, **서브클래스에서 구체적인 오브젝트 생성 방법을 결정하는 패턴** 이라 할 수 있다.

```java
public abstract class Animal {

    // 추상 팩토리 메서드
    abstract AnimalToy getToy();
}

// 팩토리 메서드가 생성할 객체의 상위클래스
public abstract class AnimalToy {

    abstract void identify();
}

public class Dog extends Animal {

    // 팩토리 메서드 오버라이딩 
    @Override
    AnimalToy getToy() {
        return new DogToy();
    }
}

// 팩토리 메서드가 생성할 객체
public class DogToy extends AnimalToy {

    public void identify() {
        //구현부..
    }
}

public class Main {

    public static void main(String[] args) {
        // 팩토리 메서드 객체 생성
        Animal dog = new Dog();

        // 팩토리 메서드를 사용하여 객체 생성
        AnimalToy toy = dog.getToye();

        // 팩토리 메서드로 생성한 객체 사용
        toy.identify();
    }
}
```

> 이 두 디자인패턴은 장점도 있지만 **상속을 사용했다는 단점** 이 존재한다. <br/>
> 상속은 사용하기 편리하지만 많은 한계점이 존재한다. 다중 상속으로 인한 문제와 상속을 통한 상하위 클래스 간의 간계는 밀접하다는 문제..

`디자인 패턴`

- 디자인 패턴은 소프트웨어 설계시 특정 상황에서 자주만나는 문제들을 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
- 이는 **주로 객체지향 설계와 관련된 것** 이다.
- 대부분 객체지향 설계 원칙을 이용해 문제를 해결한다.
- 패턴의 설계 구조를 대부분 비슷한데, 이는 객체지향에서 확장성을 추구하는 방법이 두 가지 구조로 정리되기 때문이다.
- 하나는 클래스 상속이고, 하나는 오브젝트 합성이다.

> 템플릿 메소드 패턴은 스프링에서 애용되는 디자인 패턴이다. 반드시 알아두면 좋다. <br/>
> 이전 회사에서도 디자인 패턴을 적용해서 설계를 개선한 경험이 있는데, 최근에 회사에서 업무를 하면서 상품상세 개편을 진행했는데, 옵션쪽 개편을 하면서 설계를 개선했다.. 토비스프링을 보구나서 그때 구현했던 코드가 생각나서 봤더니 템플릿 메소드 패턴 + 팩토리 + 컴포짓 패턴을 적용 했더라.. <br/>
> 결국 좋은 설계를 향해 고민을 하다보면 이런 디자인 패턴 형태가 된다는게 신기했음 ㅎ

## DAO 의 확장

- 개선한 UserDao 는 썩 괜찮아보이지만, 관심사가 다른 두 개의 클래스가 밀접하게 연관되어 있다.
    - 데이터 처리를 어떻게 할것인가 ? 에 대한 관심사와 DB 연결을 어떻게 할것인가? 의 관심사
- 이 두 관심사는 변화의 성격이 다르다.
    - 이는 변화의 이유/ 시기/ 주기 가 다르다는 의미
    - 각 변화에 따라 영향을 주지 않고 독립적인 변경이 가능하게 되었지만, 상속을 사용했다는 점이 불편하다.

`클래스의 분리`

- 관심사가 다르고 변화의 성격이 다른 두 코드를 확실하게 분리해보자.

```java
public class SimpleConnectionMaker {

    public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection("jdbc:mysql://localhost/spring_batch",
            "root", "password");
    }
}

public class UserDao {

    private SimpleConnectionMaker simpleConnectionMaker;

    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }


    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection conn = simpleConnectionMaker.makeNewConnection();

        PreparedStatement ps = conn.prepareStatement(
            "insert into users (id, name, password) values (?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        conn.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection conn = simpleConnectionMaker.makeNewConnection();

        PreparedStatement ps = conn.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        conn.close();
        return user;
    }
}
```

- 커넥션을 생성하는 관심사를 독립적으로 가진 SimpleConnectionMaker 클래스를 정의하고, UserDao 에서는 이를 사용하도록 변경했다.
- 하지만 이 방식은 N 사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 커넥션을 확장하게 했던게 불가능 해졌다.
- UserDao 가 **SimpleConnectionMaker 클래스에 종속되어 있기 때문에 커넥션 생성 방식을 변경할 방법이 없다.**

`인터페이스의 도입`

- 클래스를 분리하면서도 확장성을 제공하는 방법은 없을까 ?
- 두 개의 클래스가 긴밀하게 연결되어 있지 않도록 **느슨한 관계 (추상화)** 를 형성해 줄 필요가 있다. -> 인터페이스의 도입

![ConnectionMaker](./images/ConnectionMaker.png)

```java
public interface ConnectionMaker {

    Connection makeConnection() throws ClassNotFoundException, SQLException;
}

public class NConnectionMaker implements ConnectionMaker {

    @Override
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        // N 사의 커넥션 생성로직...
        return null;
    }
}

public class DConnectionMaker implements ConnectionMaker {

    @Override
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        // D 사의 커넥션 생성로직...
        return null;
    }
}

public class UserDao {

    private ConnectionMaker connectionMaker;

    public UserDao() {
        this.connectionMaker = new NConnectionMaker();
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection conn = connectionMaker.makeConnection();

        PreparedStatement ps = conn.prepareStatement(
            "insert into users (id, name, password) values (?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        conn.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection conn = connectionMaker.makeConnection();

        PreparedStatement ps = conn.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        conn.close();
        return user;
    }
}
```

- UserDao 는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다 (구체 클래스를 알지 않아도 된다.)
- 단지 ConnectionMaker 라는 인터페이스를 통해 원하는 기능을 사용하기만 하면 된다.
    - 내부 구현을 알 필요가 없다.

`관계설정 책임의 분리`

- UserDao 를 인터페이스를 사용해 느슨한 관계를 형성 했음에도 불구하고 UserDao 는 **어떤 ConnectionMaker 를 사용해야 하는지** 코드에 남아있다.
- UserDao 는 아직 분리되지 않은, 또 다른 관심사가 존재한다.
    - **new 키워드** 가 문제
    - new 키워드는 직접적인 의존성을 포함하고 있다는 신호를 의미한다.
- 이 관심사를 해결하지 못한다면, UserDao 는 **독립적으로 확장가능한 클래스가 될 수 없다.**
- 이를 해결하기 위해서, **어떤 커넥션을 사용할지에 대한 결정** 을 UserDao 에서 분리해야 한다.
- UserDao 와 ConnectionMaker 의 관계 형성을 UserDao 를 사용하는측 (Client), 에서 결정하도록 하자.

```java
public class UserDao {

    private ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection conn = connectionMaker.makeConnection();

        PreparedStatement ps = conn.prepareStatement(
            "insert into users (id, name, password) values (?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        conn.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection conn = connectionMaker.makeConnection();

        PreparedStatement ps = conn.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        conn.close();
        return user;
    }
}
```

- 변경된 UserDao 를 살펴보면 new 키워드가 사라졌다.
    - 이는 클래스 사이의 관계가 사라짐을 의미
- ConnectionMaker 와의 의존성을 갖고 있고, 이는 생성자를 통해 주입받는다.
    - 어떤 ConnectionMaker 가 들어올 지는 UserDao 는 알지 못한다.
- 이는 특정 클래스와 오브젝트와의 관계를 맺게 된 것이다.
    - 오브젝트 간의 다이나믹한 관계 (런타임 의존성 이라고도 한다.)

```java
public class UserDaoTest {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        ConnectionMaker connectionMaker = new NConnectionMaker();
        UserDao dao = new UserDao(connectionMaker);

        User user = new User();
        user.setId("ncucu");
        user.setName("엔꾸꾸");
        user.setPassword("패스워드");

        dao.add(user);

        System.out.println(user.getId() + "등록 성공");

        User findUser = dao.get(user.getId());
        System.out.println(findUser.getName());
    }
}
```

- UserDao 가 어떤 ConnectionMaker 를 사용할지 결정하는 책임 을 UserDao 의 클라이언트 -> UserDaoTest 가 담당하게 되었다.
- 이로인해 UserDao 의 변경 없이도 N 사 와 D 사 그리고 추후에 새로운 고객사들에게도 제공할 수 있는 UserDao 가 완성되었다.
    - 결과적으로 UserDao 는 자신의 관심사이자 책임인 사용자 데이터 액세스 작업에 집중할 수 있게 되었다.

## 원칙과 패턴

`개방 폐쇄 원칙`

- **개방 폐쇄 원칙 (Open-Closed Principle)** 은 깔끔한 설계를 위해 적용가능한 객체지향 설계 원칙 중 하나이다.
- **"클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다."** 라고 할 수 있다.
- UserDao 는 DB 연결 방법이라는 기능을 확장하는데 열려 있고, 자신의 핵심 기능은 변화에 영향을 받지 않기 때문에 변경에는 닫혀있다 라고 할 수 있다.

`걔방 폐쇄 원칙, 한번 더 생각해보기`

- OCP 를 풀어 쓰면 확장에는 열려 있고, 변경에는 닫혀있다.
- 다시 풀어보면 **기능 확장에는 열려있고, 클라이언트 변경 에는 닫혀있다** 라는 해석이 가능하다.
    - 변하는것 (Open), 변경에 영향받지 않는 것들 (Closed) 라는 표현도 좋은 것 같다.
- OCP 에서의 핵심은, 클라이언트 입장에서 사용하는 인터페이스에 기능이 추가되거나 변경이 일어났음에도 클라이언트는 전혀 수정되는 것이 없다. 라는 점이다.

`높은 응집도와 낮은 결합도`

- 개방 폐쇄 원칙은, 높은 응집도와 낮은 결합도 라는 소프트웨어 개발 고전적인 원리로도 설명이 가능하다.
- 응집도가 높다 -> 하나의 책임 또는 관심사에 집중되어 있다라는 의미
- 하나의 공통 관심사는 한 클래스에 모여 있다.
- 높은 응집도는 클래스 레벨뿐 아니라, 패키지/컴포넌트/모듈에 이르기 까지 동일한 원리로 적용될 수 있다.

`높은 응집도`

- 응집도가 높다는 것 -> 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
- 작업은 항상 전체적으로 일어나고, 무엇을 변경할지 명확하다.
- 낮은 응집도를 가지고 있어, 만약 모듈의 일부분에서만 변경이 일어난다면, 해당 변경으로 인해 전체에 영향은 없는지 ? 확인하고 검증을 해야한다.

`낮은 결합도`

- 결합도 -> 하나의 오브젝트가 변경되었을때 그 변화가 다른 오브젝트에 변화를 요구하는 정도
- 책임과 관심사가 다른 오브젝트와 느슨한 결합을 유지하는 것이 바람직 하다.
- 느슨한 결합은 **관계를 유지하는데 반드시 필요한 최소한의 방법으로 제공** 되어야 한다.
- 낮은 결합도를 유지하면 변화에 대응하는 속도가 빨라지고 깔끔한 설계, 확장시 용이하다.
- UserDao 를 보면 높은 응집도를 가지고 있고, ConnectionMaker 와의 낮은 결합도를 형성하고 있기 때문에 UserDao 를 변경하거나,
  ConnectionMaker 를 확장하더라도 서로 영향을 주지 않는다.

`전략 패턴`

- UserDaoTest - UserDao - ConnectionMaker 구조를 보면 **전략 패턴 (Strategy Pattern)** 에 해당한다.
- 전략 패턴은 **디자인 패턴의 꽃** -> 개방 폐쇄의 원칙 실현에도 가장 잘 들어맞는다.
- 전략 패턴의 구성요소 세가지
    - 전략을 가진 전략 객체
    - 전략 객체를 사용하는 컨텍스트
    - 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트
- 이를 UserDao 에 대입해보면..
    - UserDao -> 컨텍스트
    - ConnectionMaker -> 전략 객체
    - UserDaoTest -> 클라이언트

```java
public interface Weapon {

    void attack();
}

public class Gun implements Weapon {

    @Override
    public void attack() {
        System.out.println("총 빵빵 ~");
    }
}

public class Sword implements Weapon {

    @Override
    public void attack() {
        System.out.println("칼 챙챙 ~");
    }
}

public class Character {

    void doFight(Weapon weapon) {
        System.out.println("전투 준비");
        weapon.attack();
        System.out.println("전투 종료");
    }
}

public class Main {

    public static void main(String[] args) {
        Weapon weapon = null;
        Character char =new Character();

        weapon = new Gun();
        char.doFight(weapon);

        weapon = new Sword();
        char.doFight(weapon);
    }
}
```

- 전략 패턴을 한줄로 표현하면 **클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴** 라고 할 수 있다.

## 제어의 역전

- **제어의 역전 (Inversion Of Control)** 은 IoC 라는 약자로 많이 사용되고, 스프링을 통해 많이 알려진 용어이다.
- 제어의 역전이라는 것은 간단히 말하면 **프로그램의 제어 흐름 구조가 뒤바뀌는 것**
- 제어의 역전에서는 **오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.**
- 모든 제어 권한을 다른 대상에게 **위임** 한다.
- 서블릿을 생각해보면 개발자가 직접 서블릿에 대한 제어를 할 수 없다.
- 대산 서블릿에 대한 제어 권한을 가진 컨테이너가 서블릿을 관리하고, 적절한 시점에 이를 호출해준다.
- 이는 **디자인 패턴** 에서도 찾아 볼 수 있다.
- UserDao 에 **템플릿 메소드/ 팩토리 메소드 패턴** 을 적용했을 때
    - UserDao 를 상속한 NUserDao, DUserDao 는 getConnection() 메소드를 구현한다, 하지만 이 **메소드가 언제 어떻게 사용될지 자신은
      모른다.**
    - 서브클래스에서 DB 커넥션 생성 기능만 구현해 둔다면 슈퍼클래스의 템플릿 메소드에서 이를 호출해서 사용한다.
- **프레임워크** 또한 제어의 역전이 적용된 대표적인 기술

`프레임워크와 IoC`

- 프레임워크와 라이브러리는 그저 이름만 다른 것이 아니다.
- **제어권** 에서 차이가 나는것
- 라이브러리는 애플리케이션 코드를 직접 제어하고 동작 도중 필요한 기능이 있을때 라이브러리를 능동적으로 **사용** 한다.
- 프레임워크는 프레임워크가 **흐름을 주도** 하고, 애플리케이션 코드는 프레임워크에 의해 사용된다.

`프레임워크와 디자인 패턴`

- 프레임워크는 애플리케이션 구조와 디자인을 결정짓는 요소이다.
- 디자인 패턴과 마찬가지로 반복적으로 발견되는 문제를 해결하기 위한 솔루션이다.
- 구조적인 디자인패턴과 MVC 패턴 기반 애플리케이션을 손쉽게 만들 수 있도록 설계 된 것 중 오래된 프레임워크 : 스트럿츠 등..
    - 이는 MVC 패턴을 웹 애플리케이션 개발에 적용할 수 있는 특화된 구조적 패턴을 가지고 있다.
- 테스팅 프레임워크의 대표격인 xUnit 프레임워크는 커맨트 패턴 / 콤포짓 패턴으로 설계되어 있다.
- 때문에 프레임워크를 기반으로 만드는 애플리케이션 구조도 자연스럽게 해당 패턴의 영향을 받게 된다.

> 디자인 패턴은, 프레임워크의 핵심적인 특징이다. <br/>
> 디자인 패턴은 애플레이션 설계시 필요한 구조적인 **가이드 라인을 제공** 하지만 구체적으로 구현된 기반 코드를 제공하지는 않는다. <br/>
> 프레임워크는 디자인 패턴과 함께 그것이 적용된 기반 클래스를 제공해 프레임워크를 사용하는 **구조적인 틀과 구현코드를 함께 제공** 한다.

`프레임워크와 라이브러리`

| - | 프레임워크 | 라이브러리 |
| --- | --- | --- |
| 유저코드의 작성 | 프레임워크 클래스를 서브 클래싱해서 작성 | 독립적으로 작성 |
| 호출 흐름 | 프레임워크 코드가 유저 코드를 호출 | 유저 코드가 라이브러리를 호출 |
| 실행 흐름 | 프렝미워크가 제어 | 유저코드가 제어 |
| 객체의 연동 | 구조프레임워크가 정의 | 독자적으로 정의 |

`오브젝트 팩토리`

- UserDaoTest 는 UserDao 를 **테스트** 하기 위해 존재하는 클래스
- 하지만 UserDao 가 어떤 ConnectionMaker 를 사용할지 결정하는 역할까지 책임지고 있다. -> 관심사의 분리 필요

```java
public class UserDaoTest {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        ConnectionMaker connectionMaker = new NUserConnectionMaker();
        UserDao dao = new UserDao(connectionMaker);

        User user = new User();
        user.setId("ncucu");
        user.setName("엔꾸꾸");
        user.setPassword("패스워드");

        dao.add(user);

        System.out.println(user.getId() + "등록 성공");

        User findUser = dao.get(user.getId());
        System.out.println(findUser.getName());
    }
}
```

`팩토리`

- 객체의 생성 방법을 결정하고, 생성된 오브젝트를 돌려주는 역할을 수행하는 객체를 **팩토리 (Factory)** 라고 한다.
- **오브젝트의 생성과 생성된 오브젝트를 사용하는 쪽의 역할 및 책임을 깔끔하게 분리하는 목적** 으로 사용한다.

```java
public class DaoFactory {

    public UserDao userDao() {
        ConnectionMaker connectionMaker = connectionMaker();
        return new UserDao(connectionMaker);
    }

    public AccountDao accountDao() {
        ConnectionMaker connectionMaker = connectionMaker();
        return new AccountDao(connectionMaker);
    }

    public MessageDao messageDao() {
        ConnectionMaker connectionMaker = connectionMaker();
        return new MessageDao(connectionMaker);
    }

    private ConnectionMaker connectionMaker() {
        return new SimpleConnectionMaker();
    }
}
```

```java
public class UserDaoTest {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new DaoFactory().userDao();

        User user = new User();
        user.setId("ncucu");
        user.setName("엔꾸꾸");
        user.setPassword("패스워드");

        dao.add(user);

        System.out.println(user.getId() + "등록 성공");

        User findUser = dao.get(user.getId());
        System.out.println(findUser.getName());
    }
}
```

- UserDao 와 DaoFactory 에도 IoC 가 적용되어 있다.
- ConnectionMaker 의 구체 클래스를 결정하고 오브젝트를 생성하는 제어권이 UserDao 에게 있었지만 DaoFactory 가 가직 ㅗ있따.
- 스프링 없이 IoC 개념을 이미 적용한 셈이다.
- IoC 는 프레임워크만의 기술도 아니고 프레임워크가 꼭 필요한 개념도 아닌 상당히 폭 넓게 사용되는 프로그래밍 모델이다.

## 스프링의 IoC

`애플리케이션 컨텍스트와 설정정보`

- 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 **빈 (bean)** 이라고 한다.
- 스프링 빈은, 스프링 컨테이너가 관리하고 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.
- 빈의 생성및 제어를 담당하는 IoC 오브젝트를 **빈 팩토리 (bean factory)** 라고 한다.
    - 이보다는 좀 더 확장한 **애플리케이션 컨텍스트 (application context)** 를 주로 사용한다.

`애플리케이션 컨텍스트 적용`

```java

@Configuration
public class DaoFactory {

    @Bean
    public UserDao userDao() {
        ConnectionMaker connectionMaker = connectionMaker();
        return new UserDao(connectionMaker);
    }

    @Bean
    public AccountDao accountDao() {
        ConnectionMaker connectionMaker = connectionMaker();
        return new AccountDao(connectionMaker);
    }

    @Bean
    public MessageDao messageDao() {
        ConnectionMaker connectionMaker = connectionMaker();
        return new MessageDao(connectionMaker);
    }

    private ConnectionMaker connectionMaker() {
        return new SimpleConnectionMaker();
    }
}


public class UserDaoTest {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
            DaoFactory.class);
        UserDao dao = context.getBean("userDao", UserDao.class);

        User user = new User();
        user.setId("ncucu");
        user.setName("엔꾸꾸");
        user.setPassword("패스워드");

        dao.add(user);

        System.out.println(user.getId() + "등록 성공");

        User findUser = dao.get(user.getId());
        System.out.println(findUser.getName());
    }
}
```

- ApplicationContext 를 구현한 클래스는 여러가지가 있다.
- 그중 **@Configuration** 애노테이션이 붙은 자바 코드를 설정정보로 사용하려면 **AnnotationConfigApplicationContext** 클래스를
  이용하면 된다.
- getBean() 메소드를 통해 ApplicationContext 에 등록된 UserDao 오브젝트를 가져올 수 있다.
  - AnnotationConfigApplicationContext 를 사용한다면, AbstractApplicationContext 의 getBean() 메소드를 사용하게 된다.


![img.png](images/applicaion_context_hierarchy.png)

`AbstractApplicationContext`

```java
public abstract class AbstractApplicationContext extends DefaultResourceLoader
    implements ConfigurableApplicationContext {

    @Override
    public abstract ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;

    @Override
    public <T> T getBean(String name, Class<T> requiredType) throws BeansException {
        assertBeanFactoryActive(); // 빈 팩토리 동작 여부 확인
        return getBeanFactory().getBean(name, requiredType);
    }
}
```
- AbstractApplicationContext 도 **템플릿 메소드 패턴/ 팩토리메소드 패턴** 을 사용하고 있다.
  - GenericApplicationContext 에 구현된 getBeanFactory() 메소드를 사용한다.

`GenericApplicationContext`

```java
public class GenericApplicationContext extends AbstractApplicationContext implements
    BeanDefinitionRegistry {

    private final DefaultListableBeanFactory beanFactory;

    // ...
    @Override
    public final ConfigurableListableBeanFactory getBeanFactory() {
        return this.beanFactory;
    }
}
```

- GenericApplicationContext 에 구현된 getBeanFactory() 메소드는 **DefaultListableBeanFactory** 를 반환한다.

`DefaultListableBeanFactory`
- BeanFactory 인터페이스를 구현하는 핵심 클래스

```java
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {

    
}
```

`BeanFactory 와 ApplicationContext`
- 이 둘의 가장 큰차이 ? -> **빈의 인스턴스 생성 시점**
- 



## 참고

- https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EB%B9%88%EC%A6%88
- http://minsql.com/mysql/MySQL-Bug-when-using-server-side-prepared-statements/
- https://2ssue.github.io/programming/HikariCP-MySQL/
- https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration
- https://www.slipp.net/wiki/pages/viewpage.action?pageId=25527606
- https://zdnet.co.kr/view/?no=00000039160910
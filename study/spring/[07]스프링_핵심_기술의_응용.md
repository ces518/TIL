# 지옥 스터디 - 07 스프링 핵심 기술의 응용

## SQL 과 DAO 의 분리
- UserDao 는 지속적은 개선을 통해 더 이상 손대지 않아도 될 정도로 만들었다.
- 하지만 마지막으로 한 가지 더 욕심을 내보자면, **SQL 을 DAO 에서 분리하는 것** 이다.
- 반복적인 JDBC 흐름 작업은 템플릿을 통해, 트랜잭션과 예외 처리는 서비스 추상화와 AOP 를 통해 모두 제거했다.
  - 데이터 액세스 작업을 둘러싼 다양한 코드를 **책임과 성격** 에 따라 분리 했다.
- DAO 는 데이터를 가져오고 조작하는 작업의 **인터페이스** 역할을 한다.
- 데이터 엑세스 로직이 바뀌지 않으면 DAO 는 수정될 일이 없다.
  - 하지만 DB 테이블, 필드명, SQL 문이 수정될 수 있따.
  - 이런 이유로 인해 DAO 코드의 수정이 불가피해 진다.
- SQL 을 DAO 에서 분리해 관리할 수 있다면 좋을 것이다.

### XML 을 이용한 분리
- 가장 손 쉽게 생각해볼 수 있는 분리 방법은, SQL 을 XML 설정 파일로 빼내는 것
- 스프링은 설정을 통해 빈에 값을 주입해 줄 수 있다.

`UserDaoJdbc`

```java
class UserDaoJdbc implements UserDao {

    private String userAdd;

    public void setUserAdd(String userAdd) {
        this.userAdd = userAdd;
    }
    
    public void add(User user) {
        jdbcTemplate.update(
            userAdd,
            user.getId(), user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend()
        );
    }
}
```
- userAdd 라는 insert SQL 을 XML 설정으로 분리해 주입한다면, 위와 같은 형태로 사용하게 될 것이다.
- 하지만 이런 방식은 SQL 이 많아 질 수록 DAO 에 프로퍼티가 계속 추가된다는 문제가 있다.
- 이를 개선하기 위해 Map 을 활용해 보자.

`개선된 UserDaoJdbc`

```java
class UserDaoJdbc implements UserDao {

    private Map<String, String> sqlMap;

    public void setSqlMap(Map<String, String> sqlMap) {
        this.sqlMap = sqlMap;
    }

    public void add(User user) {
        jdbcTemplate.update(
            sqlMap.get("add"),
            user.getId(), user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend()
        );
    }
}
```
- sqlMap 이라는 프로퍼티를 선언하고, Map 으로 모든 SQL 문을 주입받아 이를 사용한다.
- SQL 용 프로퍼티를 일일히 추가하는 것 보다 작업량도 적고 코드도 간단하다.
- 대신 SQL 을 가져다 사용할 때 문자열로 된 키를 사용하기 때문에 **휴먼 에러** 에 취약하다는 단점이 있다.

### SQL 제공 서비스
- 스프링 설정파일을 통해 SQL 을 분리 했지만 몇 가지 문제가 있다.
- SQL 과 DI 설정정보가 한데 섞여있어 지저분하기 관리하기 쉽지 않다.
- SQL 을 따로 구분해 둬야 관리 및 리뷰, 튜닝 작업시 수월하다.
- 반드시 XML 로만 읽어오리라는 법도 없다.
  - 경우에 따라 다른 파일 또는 DB, 심지어 HTTP 를 통해 읽어들어야 할 수도 있다.

`SQL Service 인터페이스`
- 가장 먼저할일 ? -> SQL Service 인터페이스 설계
- DAO 는 SQL Service 를 통해서 조회해 사용하기만 하면 된다.
  - SQL 이 어디에 저장되어 있는지, 어떻게 검색하느지에 대한 것은 관심사가 아니다.

```java
interface SqlService {
    String getSql(String key) throws SqlRetrievalFailureException;
}
```
- SqlService 인터페이스를 정의한다.
- 이는 getSql 이라는 하나의 메소드만 가지고 있고, 주어진 키를 기반으로 SQL 을 조회해 온다.
- 만약 키에 해당하는 SQL 이 없다면, SqlRetrievalFailureException 예외가 발생한다.

```java
class UserDaoJdbc implements UserDao {

    private SqlService sqlService;
  
    public void setSqlService(SqlService sqlService) {
      this.sqlService = sqlService;
    }
  
    @Override
    public void add(final User user) throws DuplicateKeyException {
      jdbcTemplate.update(
              sqlService.getSql("userAdd"),
              user.getId(), user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend()
      );
    }
  
    @Override
    public User get(String id) {
      return jdbcTemplate.queryForObject(
              sqlService.getSql("userGet"),
              userMapper,
              id
      );
    }
  
    @Override
    public void deleteAll() {
      jdbcTemplate.update(sqlService.getSql("userDelete"));
    }
  
    @Override
    public int getCount() {
      return jdbcTemplate.queryForObject(sqlService.getSql("userCount"), Integer.class);
    }
  
    @Override
    public void update(User user) {
      jdbcTemplate.update(
              sqlService.getSql("userUpdate"),
              user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend(),
              user.getId()
      );
    }
  
    @Override
    public List<User> getAll() {
      return jdbcTemplate.query(sqlService.getSql("userGetAll"), userMapper);
    }
}
```
- 모든 메소드에서 SqlService 를 통해 해당 SQL 을 가져와 사용하도록 UserDaoJdbc 를 변경했다.
- UserDaoJdbc SqlService 인터페이스에 의존한다.

`스프링 설정 기반 초간단 SQL 서비스`
- SqlService 를 가장 간단한 방법으로 구현해보자.
- 이전에 사용했던 Map/스프링 설정 기반 으로 구현한다.

```java
public class SimpleSqlService implements SqlService {

    private Map<String, String> sqlMap;

    public void setSqlMap(Map<String, String> sqlMap) {
        this.sqlMap = sqlMap;
    }

    @Override
    public String getSql(String key) throws SqlRetrievalFailureException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrievalFailureException(key + "에 대한 SQL 을 찾을 수 없습니다.");
        }
        return sql;
    }
}
```

## 인터페이스 분리와 자기참조 빈

### XML 기반 SQL Service
- 스프링의 XML 설정으로 SQL 정보를 넣는 것은 좋은 방식이 아니다.
- SQL 을 저장해두는 전용 포맷을 가진 **독립적인 파일** 을 사용하는 것이 바람직하다.
- 검색을 위한 KEY 와 SQL 을 담은 간단한 XML 문서를 설계하고, 이를 가져다 사용하는 SQL 서비스를 구현하자.

`Jaxb`
- XML 에 담긴 정보를 가져오는 방법은 다양하다.
- 이중 JAXB (Java Architecture for XML Binding) 를 사용한다.
- 전통적인 **DOM** 방식과 비교했을때 JAXB 의 장점은 **XML 문서정보를 거의 동일한 구조의 오브젝트로 매핑해준다** 는 점이다.
  - DOM 은 XML 정보를 리플렉션 API 로 간접적으로 접근해야 한다.

![jaxb](images/jaxb.png)

`SQL 을 위한 스키마 작성과 컴파일`

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<sqlmap xmlns="http://ncucu.me/sqlmap" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://ncucu.me/sqlmap ../../../../schema.xsd">
  <sql key="userAdd">insert into users(id, name, password, level, login, recommend) values (?, ?, ?, ?, ?, ?)</sql>
  <sql key="userGet">select * from users where id = ?</sql>
  <sql key="userGetAll">select * from users order by id</sql>
  <sql key="userDelete">delete from users</sql>
  <sql key="userCount">select count(*) from users</sql>
  <sql key="userUpdate">update users set name = ?, password = ?, level = ?, login = ?, recommend = ? where id = ?</sql>
</sqlmap>
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<schema xmlns="http://www.w3.org/2001/XMLSchema"
  targetNamespace="http://ncucu.me/sqlmap"
  xmlns:tns="http://ncucu.me/sqlmap" elementFormDefault="qualified">

  <element name="sqlmap">
    <complexType>
      <sequence>
        <element name="sql" maxOccurs="unbounded" type="tns:sqlType"/>
      </sequence>
    </complexType>
  </element>
  <complexType name="sqlType">
    <simpleContent>
      <extension base="string">
        <attribute name="key" use="required" type="string"/>
      </extension>
    </simpleContent>
  </complexType>
</schema>
```
- SQL 을 다룰 XML 과 해당 XML 의 스키마 파일이다.
- XML 의 스키마 파일을 .xsd 포맷으로 저장하고, JAXB 컴파일러를 활용해 컴파일 하면 다음과 같은 파일이 생성된다.
  - `-xjc -p sqlservice.jaxb sqlmap.xsd -d src/main/java`

```java
@XmlRegistry
public class ObjectFactory {


    /**
     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: sqlservice.jaxb
     * 
     */
    public ObjectFactory() {
    }

    /**
     * Create an instance of {@link Sqlmap }
     * 
     */
    public Sqlmap createSqlmap() {
        return new Sqlmap();
    }

    /**
     * Create an instance of {@link SqlType }
     * 
     */
    public SqlType createSqlType() {
        return new SqlType();
    }

}
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
        "sql"
})
@XmlRootElement(name = "sqlmap")
public class Sqlmap {

  @XmlElement(required = true)
  protected List<SqlType> sql;

  /**
   * Gets the value of the sql property.
   *
   * <p>
   * This accessor method returns a reference to the live list,
   * not a snapshot. Therefore any modification you make to the
   * returned list will be present inside the JAXB object.
   * This is why there is not a <CODE>set</CODE> method for the sql property.
   *
   * <p>
   * For example, to add a new item, do as follows:
   * <pre>
   *    getSql().add(newItem);
   * </pre>
   *
   *
   * <p>
   * Objects of the following type(s) are allowed in the list
   * {@link SqlType }
   *
   *
   */
  public List<SqlType> getSql() {
    if (sql == null) {
      sql = new ArrayList<SqlType>();
    }
    return this.sql;
  }

}
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "sqlType", propOrder = {
        "value"
})
public class SqlType {

  @XmlValue
  protected String value;
  @XmlAttribute(name = "key", required = true)
  protected String key;

  /**
   * value 속성의 값을 가져옵니다.
   *
   * @return
   *     possible object is
   *     {@link String }
   *
   */
  public String getValue() {
    return value;
  }

  /**
   * value 속성의 값을 설정합니다.
   *
   * @param value
   *     allowed object is
   *     {@link String }
   *
   */
  public void setValue(String value) {
    this.value = value;
  }

  /**
   * key 속성의 값을 가져옵니다.
   *
   * @return
   *     possible object is
   *     {@link String }
   *
   */
  public String getKey() {
    return key;
  }

  /**
   * key 속성의 값을 설정합니다.
   *
   * @param value
   *     allowed object is
   *     {@link String }
   *
   */
  public void setKey(String value) {
    this.key = value;
  }

}
```
- JAXB 컴파일러가 생성한 파일들을 살펴보면, 스키마 파일을 기반으로 XML 문서를 바인딩할 클래스들을 생성했다.
  - 이는 JavaBeans 스타일의 접근자로 구성되어 있다.
- 때문에 이해는 어렵지 않을 것이다.

### JAXB 학습 테스트
- JAXB API 의 사용법을 익히기 위한 학습 테스트이다.
- 우선 테스트용 XML 을 작성하고 이를 이용해 자바오브젝트로 변환이 되는지 확인해 본다.

`테스트용 xml`

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<sqlmap xmlns="http://ncucu.me/sqlmap" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://ncucu.me/sqlmap ../../../../schema.xsd">
  <sql key="add">insert</sql>
  <sql key="get">select</sql>
  <sql key="delete">delete</sql>
</sqlmap>
```

`JaxbTest`

```java
public class JaxbTest {

    @Test
    void readSqlMap() throws Exception {
        String contextPath = Sqlmap.class.getPackage().getName();
        JAXBContext context = JAXBContext.newInstance(contextPath);
        Unmarshaller unmarshaller = context.createUnmarshaller();

        Sqlmap sqlMap = (Sqlmap) unmarshaller.unmarshal(
            getClass().getResourceAsStream("dao/sqlmap.xml")
        );

        List<SqlType> sqlList = sqlMap.getSql();

        assertThat(sqlList.size()).isEqualTo(3);
        assertThat(sqlList.get(0).getKey()).isEqualTo("add");
        assertThat(sqlList.get(0).getValue()).isEqualTo("insert");

        assertThat(sqlList.get(1).getKey()).isEqualTo("get");
        assertThat(sqlList.get(1).getValue()).isEqualTo("select");

        assertThat(sqlList.get(2).getKey()).isEqualTo("delete");
        assertThat(sqlList.get(2).getValue()).isEqualTo("delete");
    }
}
```
- XML 문서를 읽어, 자바 오브젝트로 변환하는 것을 JAXB 에서는 언마샬링 / 반대로 오브젝트를 XML 로 변환하는 것을 마샬링 이라고 한다.

### XML SQL Service 구현
- JAXB 를 이용해 XML 을 읽는것은 문제가 없다.
- 하지만 **언제 XML 을 읽어올 것인가** 에 대해 고민이 필요하다.
- DAO 가 요청할때 마다 매번 새로 읽어들이는것은 너무 비효율적이다.
- 최초 1회 읽어 들인 뒤 이를 캐싱 (맵에 저장) 한 뒤 재사용 하는 방식이 좋을것 같다.

`XmlSqlService`

```java
public class XmlSqlService implements SqlService {

    private Map<String, String> sqlMap = new HashMap<>();

    public XmlSqlService() {
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream("sqlmap.xml");
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);
            for (SqlType sql : sqlmap.getSql()) {
                sqlMap.put(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String getSql(String key) throws SqlRetrievalFailureException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrievalFailureException(key + " 에 해당하는 SQL 을 찾을 수 없습니다.");
        }
        return sql;
    }
}
```
- XmlSqlService 를 **스프링 빈** 으로 등록해 활용할 것이다.
- 근데 스프링이 언제 이 빈오브젝트를 생성할지 모르기 때문에 SQL 을 최초 1회 읽어오는 작업을 어디서 처리해야할지 가 막막하다.
- 때문에 우선 생성자를 통해 구현을 했다.
- XmlSqlService 오브젝트가 생성되면 JAXB API 를 이용해 sqlmap.xml 파일을 읽고 해당 내용을 sqlMap 이라는 내부 필드에 캐싱한다.
- 그 이후 getSql 요청이 오면 sqlMap 에 저장된 데이터를 서빙하는 구조이다.

### 빈의 초기화 작업
- XmlSqlService 의 기능 구현은 무사히 마쳤다.
- 의도한대로 잘 동작하고 큰 문제는 없어 보인다.
- 하지만 몇 가지 개선했으면 하는 점이 있다.
1. 생성자에서 복잡한 초기화 작업을 수행하고 있다.
   - 생성자에서는 예외가 발생할 수 있는 복잡한 초기화작업은 하지 않는것이 좋다.
   - 오브젝트중 발생하는 예외는 다루기 힘들고, 상속하기 불편하며, 보안에 문제가 발생할 수도 있다.
2. 읽어들일 파일의 위치와 이름이 코드에 고정되어 있다.

`개선된 XmlSqlService`

```java
public class XmlSqlService implements SqlService {

    private Map<String, String> sqlMap = new HashMap<>();
    private String sqlmapFile;

    public XmlSqlService() {

    }

    public void setSqlmapFile(String sqlmapFile) {
        this.sqlmapFile = sqlmapFile;
    }

    /**
     * 스프링이 제공하는 BeanPostProcessor
     * @see InitDestroyAnnotationBeanPostProcessor
     * @see CommonAnnotationBeanPostProcessor
     */
    @PostConstruct
    public void loadSql() {
        // 생성자에 복잡한 초기화 로직을 넣는것은 좋은 방법이 아니다.
        // 별도의 메소드로 추출해 호출해 주는 방식 사용..
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream(sqlmapFile);
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);
            for (SqlType sql : sqlmap.getSql()) {
                sqlMap.put(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String getSql(String key) throws SqlRetrievalFailureException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrievalFailureException(key + " 에 해당하는 SQL 을 찾을 수 없습니다.");
        }
        return sql;
    }
}
```
- 위에서 언급된 문제들을 개선했다.
- 우선 초기화 작업을 loadSql() 이라는 별도의 초기화 메소드를 만들어 옮겼다.
- 그리고 sql 파일명이 고정되어 있기 때문에 DI 받을 수 있도록 변경했다.
- 하지만 한 가지 걸리는 점은 초기화 메소드가 언제 호출되어야 할까 ? 또 어떻게 실행할 수 있을지가 관건이다.
- XmlSqlService 의 **제어권** 은 스프링에게 있다. 때문에 초기화도 스프링에게 맡겨야 한다.
- 스프링은 지정한 초기화 메소드를 호출해주는 기능을 가지고 있다.
- AOP 를 학습할때 잠깐 살펴보았던 **빈 후처리기** 가 그에 대한 해답이다.
- 스프링이 제공하는 빈 후처리기중 애노테이션을 이용한 빈 설정을 지원하는 후처리기가 있다.
  - CommonAnnotationBeanPostProcessor 는 @PostConstruct, @PreDestroy 를 지원한다.
  - java.lang.annotations 에 포함된 공통 애노테이션이다. (JSR-250)
    - JavaEE5 / JDK6 의 표준
- @PostConstruct 를 이용해 스프링 빈 후처리기에 의해 초기화 로직이 실행될 수 있도록 한다.

### 변화를 위한 준비 : 인터페이스 분리
- XmlSqlService 는 현재로서도 큰 문제는 없지만, SQL 서비스 기능에는 확장할 영역이 많이 남아 있다.
- 현재 구조는, 특정 포맷의 XML 에서 SQL 을 읽어오고 이를 HashMap 에 저장해 둔다.
  - SQL 을 읽어옴에 있어 특정 기술에 종속되어 있다.
  - XML 대신 다른 파일로부터 읽는 다거나, DB 혹은 HTTP 로 부터 가져와야 할 수도 있다.
- HashMap 이라는 자료구조가 아닌 다른 방식으로 저장하고 사용 하기위해서도 구현의 변경이 필요하다.
- 두 가지 변화 모두 XmlSqlService 를 수정해야 한다.
- SQL 을 읽어오는 것과 저장하고 사용하는 것은 충분히 독자적인 이유로 변경이 가능하다.

`책임에 따른 인터페이스 정의`
- 가장 먼저 분리가능한 **관심사** 를 구분해 보는 것이다.
1. SQL 을 외부 리소스로 부터 읽어온다.
   - 이는 파일일 수도 있고, DB 일수도 있다.
2. SQL 을 저장하고, 사용한다.
   - SQL 의 양에 따라 다양한 방식의 저장 방법을 사용할 수 있다.
- 여기에 부가적인 책임을 생각한다면, SQL 을 필요에 따라 수정도 할 수 있다.
  - 운영중 서버를 재시작하는 것은 매우 부담되는 일이다.
  - 때문에 경우에 따라 운영중 SQL 을 수정해야 하는 일이 발생할 수 있다.
- 관심사에 다른 인터페이스를 도출하고, SqlService 가 해당 인터페이스에 의존하는 형태로 구현해 본다.

![sqlservice_structure](images/sqlservice_structure.png)

- 한가지 생각해볼 점은 SqlReader 가 읽어온 내용을 SqlRegistry 에 전달해 등록해야 한다.
- 전달하는 과정과 형식은 어떻게 할 것인가 ? -> Map 으로 처리할까 ?..
  - SqlService 가 중간에서 단순히 전달해주는 역할만 한다면 SqlService 가 중간에서 빠지면 어떨까 ?
  - SqlReader 가 SqlRegistry 를 받아 직접 저장해주는 것이다.

![sqlreader_sqlregistry](images/sqlreader_sqlregistry.png)

`SqlReader`

```java
public interface SqlReader {

    void read(SqlRegistry registry);
}
```
- SQL 을 읽어 들여 SqlRegistry 에 전달하는 역할을 한다.
- 이는 SqlRegistry 에 의존하고 있다.

`SqlRegistry`

```java
public interface SqlRegistry {

    void registerSql(String key, String sql);

    String findSql(String key) throws SqlNotFoundException;
}
```
- SQL 을 제공받아 키로 검색한 결과를 돌려주는 역할을 담당한다.
- 등록/검색 두가지 기능을 정의하고 있다.
- SqlNotFoundException 는 Runtime 예외지만 해당 예외가 발생할 수 있음을 선언해 준다.

### 자기 참조 빈으로 시작

`다중 인터페이스 구현과 간접 참조`
- SqlService 구현 클래스는 SqlReader 와 SqlRegistry 두 개의 인터페이스에 의존한다.
- 기존에 만들었던 XmlSqlService 를 해당 구조에 맞게 변경한다.
  - 기존에는 세가지 관심과 책임을 하나의 클래스에 구현 했던 것이다.
- 책임에 따라 분리되지 않았던 XmlSqlService 를, 세분화된 책임을 정의한 인터페이스를 구현하도록 만든다.
- 동일한 클래스의 코드지만, 책임이 다른 코드는 직접 접근하지 않고 인터페이스를 통해 간접적으로 접근하도록 한다.

`인터페이스를 이용한 분리`
- XmlSqlService 는 SqlService 인터페이스만 구현한 독립적인 클래스라 가정한다.
  - SqlReader, SqlRegistry 인터페이스에 의존하는 구조가 되어야한다.

```java
public class XmlSqlService implements SqlService, SqlRegistry, SqlReader {

    private SqlReader reader;
    private SqlRegistry registry;

    private Map<String, String> sqlMap = new HashMap<>();
    private String sqlmapFile;

    public XmlSqlService() {

    }

    public void setSqlmapFile(String sqlmapFile) {
        this.sqlmapFile = sqlmapFile;
    }

    public void setReader(SqlReader reader) {
        this.reader = reader;
    }

    public void setRegistry(SqlRegistry registry) {
        this.registry = registry;
    }

    /**
     * 스프링이 제공하는 BeanPostProcessor
     * @see InitDestroyAnnotationBeanPostProcessor
     * @see CommonAnnotationBeanPostProcessor
     */
    @PostConstruct
    public void loadSql() {
        reader.read(registry);
    }

    @Override
    public String getSql(String key) throws SqlRetrievalFailureException {
        try {
            return registry.findSql(key);
        } catch (SqlNotFoundException e) {
            throw new SqlRetrievalFailureException(e);
        }
    }

    @Override
    public void registerSql(String key, String sql) {
        sqlMap.put(key,sql);
    }

    @Override
    public String findSql(String key) throws SqlNotFoundException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrievalFailureException(key + " 에 해당하는 SQL 을 찾을 수 없습니다.");
        }
        return sql;
    }

    @Override
    public void read(SqlRegistry registry) {
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream(sqlmapFile);
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);
            for (SqlType sql : sqlmap.getSql()) {
                registry.registerSql(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }
}
```

`자기참조 빈 설정`
- XmlSqlService 에 혼재되어 있던 성격이 다른 코드를, 세 가지 인터페이스를 구현하는 방법을 통해 서로 깔끔하게 분리했다.
- 같은 클래스내에 구현된 내용이지만, SQL 을 읽을때는 SqlReader / 저장하고 사용할때는 SqlRegistry 인터페이스에 의존한다.

```java
@Configuration
class Factory {
    
    @Bean
    public SqlService sqlService() {
      XmlSqlService sqlService = new XmlSqlService();
      sqlService.setSqlmapFile("sqlmap.xml");
      // Self 참조 빈
      sqlService.setReader(sqlService);
      sqlService.setRegistry(sqlService);
      return sqlService;
    }
}
```
- 자기 참조 빈은 흔히 쓰이는 방법은 아니다.
- 책임이 다르다면 클래스를 구분하고 각기 다른 오브젝트로 만드는것이 자연스럽다.
- 자기 참조 빈을 만들어보는 것은, 책임과 관심사가 복잡하게 얽혀 있어 확장이 힘들고 변경에 취약한 구조의 클래스를 유연한 구조로 만들려고 할 때 시도해볼 수 있는 방법이다.
- 당장 확장 구조를 통해 구현을 바꾸지 않더라도 확장 구조를 만들어두는 것이 좋다고 생각할때 가장 간단히 접근 가능한 방법이다.
  - 실제로 스프링이 제공하는 클래스 중에는 자기참조 빈이 많다.

### 디폴트 의존관계

`확장 가능한 기반 클래스`
- SqlRegistry / SqlReader 를 이용하는 가장 간단한 SqlService 를 만들어 보자.
- 자기 참조빈 으로 구현한 XmlSqlService 코드에서 의존 인터페이스와 구현 코드를 제거하기만 하면 된다.

```java
public class BaseSqlService implements SqlService {

    protected SqlReader reader;
    protected SqlRegistry registry;

    public BaseSqlService() {

    }


    public void setReader(SqlReader reader) {
        this.reader = reader;
    }

    public void setRegistry(SqlRegistry registry) {
        this.registry = registry;
    }

    /**
     * 스프링이 제공하는 BeanPostProcessor
     *
     * @see InitDestroyAnnotationBeanPostProcessor
     * @see CommonAnnotationBeanPostProcessor
     */
    @PostConstruct
    public void loadSql() {
        reader.read(registry);
    }

    @Override
    public String getSql(String key) throws SqlRetrievalFailureException {
        try {
            return registry.findSql(key);
        } catch (SqlNotFoundException e) {
            throw new SqlRetrievalFailureException(e);
        }
    }
}
```

`HashMapSqlRegistry`

```java
public class HashMapSqlRegistry implements SqlRegistry {

    private Map<String, String> sqlMap = new HashMap<>();

    @Override
    public void registerSql(String key, String sql) {
        sqlMap.put(key, sql);
    }

    @Override
    public String findSql(String key) throws SqlNotFoundException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlNotFoundException(key + " 에 해당하는 SQL 을 찾을 수 없습니다.");
        }
        return sql;
    }
}
```

`JaxbXmlSqlReader`

```java
public class JaxbXmlSqlReader implements SqlReader {

    private String sqlmapFile;

    public void setSqlmapFile(String sqlmapFile) {
        this.sqlmapFile = sqlmapFile;
    }

    @Override
    public void read(SqlRegistry registry) {
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream(sqlmapFile);
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);
            for (SqlType sql : sqlmap.getSql()) {
                registry.registerSql(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }
}
```
- 세 가지 인터페이스를 구현하던 XmlSqlService 를 SqlService 만 구현하도록 변경하고, 각 인터페이스를 구현하는 구현체를 만들었다.
- 이제 BaseSqlService 라는 이름으로 기반이 되는 SqlService 클래스가 되었다.

```java
@Configuration
class Factory {
    
    @Bean
    public SqlService sqlService() {
      BaseSqlService sqlService = new BaseSqlService();
      sqlService.setReader(sqlReader());
      sqlService.setRegistry(sqlRegistry());
      return sqlService;
    }
  
    @Bean
    public SqlReader sqlReader() {
      JaxbXmlSqlReader sqlReader = new JaxbXmlSqlReader();
      sqlReader.setSqlmapFile("sqlmap.xml");
      return sqlReader;
    }
  
    @Bean
    public SqlRegistry sqlRegistry() {
      return new HashMapSqlRegistry();
    }
}
```

### 디폴트 의존관계를 갖는 빈 만들기
- BaseSqlService 는 sqlReader / sqlRegistry 를 DI 로 의존관계를 자유롭게 변경하며 기능을 확장할 수 있다.
- 유연성을 보장하려면 이런 구조가 필요하지만, 3개의 빈을 등록해야 한다는 점도 있다.
- 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는걸 고려해볼 수 있다.

```java
public class DefaultSqlService extends BaseSqlService {

    // DefaultSqlService 에 프로퍼티를 두고 JaxbXmlSqlReader 에 기본값을 주는것은 좋은 방식 이 아니다.
    // 이름 그대로 디폴트 의존관계일 뿐이지, 그 이상의 역할을 하게 됨.

    /**
     * 디폴트 의존관계
     */
    public DefaultSqlService() {
        setReader(new JaxbXmlSqlReader());
        setRegistry(new HashMapSqlRegistry());
    }
}
```
- 생성자를 보면 디폴트 의존관계를 갖는 빈을 스스로 DI 해주는 형태로 구현되어 있다.
- 하지만 현재 상태로 테스트를 돌려보면 테스트는 **실패** 한다.
  - JaxbXmlSqlReader 의 sqlmapFile 프로퍼티가 비어있기 때문...
  - SQL 읽어올 파일을 알 수 없다.
- 이를 해결하기 위해 sqlmapFile 을 프로퍼티로 저장하는 방법이 있는데, 이는 좋은 방식이 아니다.
- DefaultSqlService 는 디폴트 의존관계 일 뿐이지, 그 이상의 역할을 수행하게 된다.
- 따라서 이 방법보다는 sqlmapFile 의 기본 값을 JaxbXmlSqlReader 을 가지게 하는 방법을 사용해 보자.

```java
public class JaxbXmlSqlReader implements SqlReader {

    private static final String DEFAULT_SQLMAP_FILE = "sqlmap.xml";

    private String sqlmapFile = DEFAULT_SQLMAP_FILE;

    public void setSqlmapFile(String sqlmapFile) {
        this.sqlmapFile = sqlmapFile;
    }

    @Override
    public void read(SqlRegistry registry) {
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream(sqlmapFile);
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);
            for (SqlType sql : sqlmap.getSql()) {
                registry.registerSql(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }
}
```
- JaxbXmlSqlReader 는 필요시 DI 를 통해 대상이 되는 파일을 변경할 수도 있고, 지정하지 않았다면 기본 값으로 정해진 파일을 사용하게 된다.

> DefaultSqlService 는 BaseSqlService 를 상속했다는 점이 중요하다. <br/>
> BaseSqlService 의 sqlReader / sqlRegistry 를 모두 가지고 있고, 원한다면 프로퍼티 변경도 가능하다.

## 참고
- https://en.wikipedia.org/wiki/JSR_250















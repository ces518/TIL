# 지옥 스터디 - 12 유령 파일

## 목표 : 이미지 또는 벌크 미디어 저장
- 대부분 애플리케이션에서 이미지나 다른 미디어를 사용한다.
- 이는 데이터베이스에 저장된 엔티티와 연관되기도 한다.
  - 사용자 댓글과 함께 표시될 사진 또는 아바타 등..
- 목표는 이미지를 젖아하고 이를 사용자 계정/버그 와 같은 데이터베이스 엔티티와 연고나을 갖게 하는 것이다.
- 데이터베이스에서 엔티티 쿼리시 관련 이미지도 함께 얻을 수 있어야 한다.

## 안티패턴 : 파일을 사용해야 한다고 가정한다.
- 개념적으로 이미지는 **테이블의 속성** 이다.
- `Accounts` 테이블은 `portrait_image` 컬럼을 가질 수 있다.

```sql
CREATE TABLE Accounts (
    account_id SERIAL PRIMARY KEY,
    account_name VARCHAR (20),
    portrait_image BLOB
);
```
- 종속 테이블을 사용해 여러 이미지를 저장할 수도 있다.

```sql
CREATE TABLE Screenshots (
    bug_id BIGINT NOT NULL,
    image_id SERIAL NOT NULL,
    screenshot_image BLOB,
    caption VARCHAR (100)
);
```
- 이정도 까지 설계는 쉬운편이지만, 이미지에 대한 **데이터 타입 선정** 은 논란이 있는 주제임.
- 이미지의 바이너리 데이터를 `BLOB` 데이터로 저장할 수 있지만, 많은 사람들이 이미지를 파일 시스템에 파일로 저장한 후 파일에 대한 경로만 VARCHAR 로 저장한다.

```sql
CREATE TABLE Screenshots (
    bug_id BIGINT NOT NULL,
    image_id SERIAL NOT NULL,
    screenshot_path VARCHAR (100),
    caption VARCHAR (100)    
);
```
- 두 방법 모두 나름의 이유가 있지만, 개발자들은 일반적으로 파일을 항상 데이터베이스 외부에 저장해야 한다는 생각에 의심도 하지 않는다.
- 파일을 별도로 저장하는 방식에는 몇 가지 위험이 있다.

### DELETE 문제
- 첫 번째는 가비지 컬렉션과 관련된 문제이다.
- 이미지가 데이터베이스 외부에 저장된다면 해당 경로를 가지고있는 행을 지웠을때 파일을 자동으로 삭제하는 방법이 없다.

```sql
DELETE FROM Screenshots WHERE bug_id = 1234 and image_id = 1;
```
- 데이터베이스에서 이미지를 참조하는 행을 삭제할 때 이미지 파일도 함께 삭제하도록 애플리케이션을 설계하지 않는 한 고아가 된 이미지 파일은 계속 쌓일 것이다.

### 트랜잭션 문제
- 보통 데이터 업데이트/삭제 시 COMMIT 으로 트랜잭션을 끝내기 전 까지는 변경사항이 다른 클라이언트에게 보이지 않는다.
- 하지만 데이터베이스 밖에 있는 파일을 변경하는 경우에는 트랜잭션을 지원하지 못한다.
- 파일을 삭제하면 그 즉시 다른 클라이언트도 접근하지 못하게 된다.

### ROLLBACK 문제
- 에러가 발생한 경우 or 애플리케이션 로직이 변경사항을 취소해야 하는 경우 트랜잭션을 롤백해야 한다.
- DELETE 로 스크린샷을 삭제하면서 해당 행에 대응되는 파일을 삭제했다고 하면, 롤백시 삭제가 취소되어 행을 되살아나지만 지워진 파일을 되살아나지 않는다.

### 백업 문제
- 대부분 데이터베이스 제품은 백업을 위한 도구를 제공한다.
- 하지만 외부 이미지 파일은 이런 도구의 도움을 받지 못한다.
- 데이터베이스 백업시 데이터베이스 백업 도구 사용 후 외부이미지 백업을 위한 파일시스템 백업도구를 추가적으로 사용해야 한다.
- 하지만 이 또한 100% 동기화되었다고 단정지을 수 없다.
  - 백업 시작 직후에도 이미지를 추가/변경 할 수 있기 때문이다.

### SQL 접근 권한 문제
- 외부에 저장한 파일은 GRANT, REVOKE 등으로 할당한 접근 권한을 우회한다.
- SQL 접근 권한으로 이를 제어할 수 없다.

### SQL 데이터 타입 문제
- 해당 컬럼에 저장된 경로는 문자열일 뿐이다.
- 이 경로가 유효한지 검증하지 않으며 실제로 존재하지는지 검증할 수도 없다.
- 파일 이름이 변경되거나 삭제되어도 칼럼의 값이 자동으로 업데이트 되지 않는다.
- 이는 애플리케이션 로직에 의존할 수 밖에 없다.

> 데이터베이스를 사용했을때 장점은 **데이터 정합성** 유지에 도움이 된다. <br/>
> 외부 파일로 저장하는 경우 이런 장점을 누릴 수 없게 된다.

## 안티패턴 인식 방법
- 데이터 백업과 복원 절차는 어떻게 되는가 ?
  - 백업을 어떻게 검증할 수 있는가 ?
  - 백업을 만든 서버 이외에 다른 서버에서 데이터 복원 테스트를 해 본적이 있는가 ?
- 이미지가 계속 쌓이는가, 아니면 더 이상 필요하지 않으면 시스템에서 삭제되는가 ?
  - 이미지를 삭제하는 절차는 어떻게 되는가 ?
  - 자동화된 절차인가, 수작업 절차인가 ?
- 애플리케이션의 어떤 사용자가 이미지를 볼 수 있는 권한이 있는가 ?
  - 권한은 어떻게 확인하는가 ?
  - 권한이 없는 이미지를 요청하면 사용자가 뭘 보게 되는가 ?
- 이미지에 대한 변경을 취소할 수 있는가 ?
  - 그렇다면, 애플리케이션이 이전 상태의 이미지로 복원해야 하는가 ?

> 프로젝트에서 위 질문들에 대해 생각해보아야 한다.

## 안티패턴 사용이 합당한 경우
- 이미지가 다른 대형 객체를 데이터베이스 외부에 파일로 저장하는 것이 좋은 이유도 있다.
1. 이미지가 없다면 데이터베이스가 가벼워 진다.
2. 이미지를 제외하면 데이터베이스 백업이 빨라지고 결과도 작다.
3. 이미지가 데이터베이스 외부 파일로 되어 있다면 일반적인 이미지 미리보기나 편집이 쉽다.
   1. 모든 이미지에 대해 배치 편집을 적용해야 한다면 이미지를 데이터베이스 밖에 보관하는 것이 좋다.
- 이미지를 파일로 저장할때의 장점이 중요하다고 느껴진다면 해당 프로젝ㅌ츠에서는 이미지를 데이터베이스 외부에 저장하는 것이 올바르다고 결정할 수 있다.
- 일부 데이터베이스는 좀 더 투명하게 외부 파일을 참조하는 SQL 데이터 타입을 지원한다.
  - Oracle 에서는 `BFILE` SQL Server 2008 에서는 `FILESTREAM` 이라고 불린다.

> 이미지를 외부 파일로 저장하는 것이 항상 제일 좋은 방법이 아니며, 제대로 알고 결정을 해야 한다.

## 해법 : 필요한 경우 BLOB 데이터 타입을 사용하라.
- 앞에서 설명한 이슈중 하나라도 해당된다면 이미지를 데이터베이스 내부에 저장하는 것을 고려해야 한다.

```sql
CREATE TABLE Screenshots (
    bug_id BIGINT NOT NULL,
    image_id BIGINT NOT NULL,
    screenshot_image BLOB,
    caption VARCHAR (100)
);
```
- 이미지를 이 와같이 `BLOB` 칼럼에 저장한다면 모든 이슈가 해결된다.
  - 이미지 데이터가 데이터베이스에 저장되기 때문에 이미지를 로드하기 위한 별도 단계가 필요하지 않다. 파일 경로가 잘못될 일 도 없다.
  - 행은 삭제하면 이미지도 자동으로 삭제된다.
  - 커밋하기 전 까지는 이미지 변경이 다른 클라이언트에 보이지 않는다.
  - 트랜잭션 롤백시 이미지도 이전 상태로 복원된다.
  - 행을 업데이트할 때 잠금이 설정되므로 동시에 이미지를 업데이트 할 수 없다.
  - 데이터베이스 백업에 모든 이미지가 포함된다.
  - SQL 권한은 행뿐 아니라 이미지에 대한 접근도 제어한다.
- `BLOB` 의 최대 크기는 대부분 이미지를 저장하는데 충분하다.
- 몇몇 데이터베이스는 외부 파일을 로드하는 함수를 제공한다.
  - MySQL 의 경우 `LOAD_FILE()` 함수 제공

```sql
UPDATE Screenshots 
SET screentshot_image = LOAD_FILE('images/screenshot1234-1.jpg')
```

> 데이터베이스 밖의 리소스는 데이터베이스가 관리하지 않는다. 
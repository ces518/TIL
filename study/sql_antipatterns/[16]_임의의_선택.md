# 지옥 스터디 - 16 임의의 선택

## 목표 : 샘플행 가져오기
- 얼마나 자주 임의의 결과를 리턴하는 SQL 쿼리가 필요한지 놀랄 정도.
- 이는 반복성과 결정론적 프로그래밍 원리에 배치되는 것으로 보임
- 대량의 데이터 집합에 샘플 데이터를 요청하는 것은 평범한 일이다.
  - 광고나 강조하고 싶은 뉴스 스토리와 같은 순환 컨텐츠를 표시할 때
  - 레코드의 부분 집합을 조사할 때
  - 걸려오는 전화를 가용한 오퍼레이터에 할당할 때
  - 테스트 데이터를 생성할 때
- 전체 데이터집합을 요청하는 것 보단 데이터베이스에 샘플을 요청하는 것이 낫다.
> 목표 : 임의의 샘플 데이터만 리턴하는 효율적인 쿼리를 작성하기

## 안티패턴 : 데이터를 임의로 정렬하기
- 쿼리에서 임의의 행을 고르는 가장 흔한 기법 
- 데이터를 임의로 정렬한 뒤 첫 행으로 고르는 것이다.

```sql
SELECT * FROM Bugs ORDER BY RAND() LIMIT 1;
```
- 가장 쉽지만 약점이 금방 드러난다.
- 이 약점을 이해하기 위해 일반적인 정렬을 알아야 한다.
- 일반적인 정렬은 **칼럼의 값** 을 비교해 어느 행이 큰 값을 가졌고 작은 값을 가진지에 따라 순서를 매긴다.
- 이는 반복적이기 때문에 여러번 실행해도 결과가 같으며 인덱스를 활용할 수도 있다.
- 인덱스는 본질적으로 특정 칼럼 값으로 **미리 정렬한 집합** 이기 때문이다.

```sql
SELECT * FROM Bugs ORDER BY date_reported;
```
- 정렬 조건이 각 행마다 임의의 수를 리턴하는 함수라면, 어떤 행이 달느 행보다 큰지 작은지도 임의가 되며 순서도 각 행의 값과면 무관해 진다.
- 하지만 이는 인덱스를 활용할 수 없게 되며 쿼리 성능 고려시 문제가 된다.
- 데이터가 많다면 임시테이블을 이용하게 될 것이다.
- 또 다른 약점은 이 작업 결과의 대부분이 낭비라는 점이다.
- 첫 행을 제외한 대부분의 데이터는 바로 버리기 때문이다.
- 데이터베이스 크기가 커질수록 이런 약점은 점점 치명적이다.

## 안티패턴 인식 방법
- 다음과 같은 말이 들리면 안티패턴을 사용하고 있을 확률이 높다.
  - SQL 에서 임의의 행을 리턴하는 건 정말 느려
  - 애플리케이션에서 사용할 메모리를 어떻게 늘릴수 있지 ? 모든 행을 가져와 그중 임의로 한 개를 선택해야 해
  - 어떤 항목이 다른 것보다 좀더 자주 나오는 것 같아 보이지 않니 ? 랜덤이 별도 랜덤같지 않은데

## 안티패턴 사용이 합당한 경우
- 임의로 정렬하는 방법의 비효율성은 데이터 집합이 적을 때는 참을만하다.
- 주어진 버그를 수정할 프로그래머를 할당할때 이런 방법을 사용할 수 있다.
- 목록의 크기도 적당하고 데이터가 늘어날 일이 거의 없는 경우라면 괜찮다.

## 해법 : 테이블 전체 정렬 피하기
- 임의로 정렬하는 방법은 테이블 스캔과 비용이 많이 드는 수동정렬을 수반한다
- SQL 작성시 이러한 비효율적인 쿼리를 경계해야 한다.
- 최적화할 수 없는 쿼리를 최적화하려고 노력하기 보단 새로운 접근 방법을 생각하는 것이 낫다.

### 1 과 MAX 사이에서 임의의 키 값 고르기
- 테이블 정렬을 피하는 방법 중 하나는 1 과 PK 최대값 사이에서 임의의 값을 선택하는 것

```sql
SELECT b1.*
FROM Bugs AS b1
JOIN (
    SELECT CEIL (RAND() * (SELECT MAX (bug_id) FROM Bugs) AS rand_id ) As b2
  )
ON b1.bug_id = b2.rand_id;
```
- 이 방법은 PK 값이 1부터 시작해 연속으로 존재한다고 가정한다.

### 다음으로 큰 키값 고르기
- 앞서 본 방법과 비슷하지만, 1과 최댓값 사이에 빈틈이 있는 경우에도 사용할 수 있다.
- 다음 쿼리는 임의의 값으로 처음 찾아내는 키 값과 매치된다.

```sql
SELECT b1.*
FROM Bugs As b1
JOIN (
    SELECT CEIL (RAND() * (SELECT MAX (bug_id) FROM Bugs)) AS bug_id
  ) AS b2
WHERE b1.bug_id >= b2.bug_id
ORDER BY b1.bug_id
LIMIT 1;
```
- 이 방법은 임의의 수가 키 값과 대응되지 않는 경우에 대한 문제를 해결하지만, 빈틈 바로 앞에 있는 키 값이 더 자주 선택된다는 단점이 있다.
- 빈틈이 드물게 존재하고 모든 키 값이 동일한 빈도로 선택되는 것이 중요하지 않을때 이 방법을 사용할 수 있다.

### 모든 키 값의 목록을 구한 다음, 임의로 하나 고르기
- 결과 집합의 PK 값 하나를 고르는 애플리케이션 코드를 사용할 수 있다.
- 그런 뒤 이 PK 값을 이용해 데이터베이스에서 전체 행을 조회한다.
- 이 기법은 테이블 정렬을 피하고, 각 키값을 거의 같은 확률로 선택하지만 다른 비용이 든다.
  - 데이터베이스로부터 모든 bug_id 값을 불러올 때 리스트 크기가 엄청나게 클 수 있다.
  - 심지어 애플리케이션 메모리 자원을 넘어서 다른과 같은 에러가 발생할 수 있다.
    - Allow memory size of 16777216 bytes exhausted
  - 쿼리를 두번해야 한다. 한 번은 PK 의 목록을 생성하기 위해, 두 번째는 임의의 행을 가져오기 위해서다.
  - 쿼리가 지나치게 복잡하게 비용이 많이 든다면 문제가 될 수 있다.

> 결과 집합의 크기가 적당하고 단순한 쿼리로 임의의 행을 선택하는 경우에 이 기법을 사용할 수 있다. <br/>
> 이 방법은 불연속적인 목록에서 값을 선택할 때 좋다.

### 오프셋을 이용해 임의로 고르기
- 앞서 살펴본 방법에 존재하는 문제를 피하는 다른 방법이 있다.
- 데이터 집합에서 행의 개수를 세고 0과 행의 개수 사이의 임의의 수를 고른 뒤 데이터 집합을 쿼리할 때 이 수를 오프셋으로 사용한다.
- 키 값이 연속적이라고 확신할 수 없고, 각 행이 선택될 확률을 같게 해야 하는 경우 이 방법을 사용할 수 있다.

### 벤더 종속적인 방법
- 어떤 데이터베이스 제품이든 이런 종류의 처리를 위한 각자의 방법이 있다.
- SQL Server 2005 에는 `TABLESAMPLE` 절이 있다.

```sql
SELECT * FROM Bugs TABLESAMPLE (1 ROWS);
```
- Oracle 은 조금 다르게 SAMPLE 절을 사용한다.
- 예를 들어 다음 쿼리는 테이블에서 1%의 행을 가져온 뒤 임의의 순서로 정렬한 후 한 행만 가져온다.

```sql
SELECT * FROM (
    SELECT * FROM Bugs SAMPLE (1) ORDER BY dbms_random.value
) WHERE ROWNUM = 1;
```
> 어떤 쿼리는 최적화 할 수 없다. 이 경우 다른 접근방법을 취해야 한다.
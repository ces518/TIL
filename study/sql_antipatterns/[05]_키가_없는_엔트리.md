# 지옥 스터디 - 05 키가 없는 엔트리

## 목표 : 데이터베이스 아키텍쳐 단순화
- 참조 정합성은 데이터베이스를 적절히 설계하고 운영하는데 있어 중요한 부분.
- 하지만 어떤 소프트웨어 개발자는 **참조 정합성 제약조건을 사용하지 말라** 고 권고하기 도한다.
- 그 이유는 다음과 같다.
  - 데이터 변경시 제약조건과 충돌할 수 있음
  - 참조 정합성 제약조건을 지원할 수 없는 매우 용통성 있는 데이터베이스 설계를 사용 중
  - FK 에 데이터베이스가 자동 생성하는 인덱스 때문에 성능 문제가 발생한다고 믿음
  - FK 를 지원하지 않는 데이터베이스를 사용하고 있음
  - FK 선언을 위해 문법을 찾아야 함

## 안티패턴 : 제약 조건 무시
- FK 제약조건을 생략하는 것은, 데이터베이스 설계를 단순하고 유연하고 빠르게 하는 것 처럼 보이지만, 다른 방식으로 대가를 치뤄야 한다.
- 참조 정합성을 봊아하기 위한 코드를 직접 작성해야만 함.

### 무결점 코드
- 많은 사람들이 참조 정합성을 위해 **애플리케이션 코드** 를 통해 이를 만족시키려고 한다.
- 행 삽입시 마다 FK 값이 테이블에 존재하는지, 삭제시 마다 자식 테이블이 적절히 업데이트 되는지 확인한다.
  - 실수를 하지 말아야 한다는 의미
- FK 제약 조건을 사용하지 않는다면 참조 정합성을 만족하기 위해 변경전 SELECT 쿼리를 통해 검증을 해야 한다.

### 오류 확인
- 깨진 참조를 확인하는 것을 얼마나 자주 해야하는가 ?
- 매일 수백번, 수천번 이상 자주 확인한다면 그보다 더한 잡일도 없을 것이다.
- 깨진참조를 발견하면 올바르게 정정할 수 있는가 ?
- 바로 잡을수 있다면 다행이지만, 그러지 못한 경우도 분명히 생기기 마련이다.
- 예를 들어 Bugs 테이블의 reported_by 컬럼에 사용자 계정을 참조해야 하지만 해당 사용자가 유효하지 않는다면 어떤식으로 처리해야 하는가 ?

### 내 잘못이 아냐 !
- 만약 코드를 수정하는 경우 모든 경우에 대해 문제가 없도록 변경을 적용했는지 어떻게 확신할 수 있는가 ?
- 일반적인 SQL 을 사용하면 깨진 참조를 만들어내기도 쉽다.
- 데이터베이스는 일관성을 유지해야 한다.
- 데이터베이스 내 참조가 항상 유효해야 한다.
- 하지만 데이터베이스에 접근하는 모든 애플리케이션과 스크립트가 올바르게 변경을 가하는지 확신할 수 없다.

### 진퇴양난 업데이트
- 많은 개발자가 여러 테이블의 관련 컬럼을 업데이트할 때 불편하기 때문에 FK 제약 조건 사용을 꺼린다.
- 다른 행이 의존하는 어떤 행을 삭제하기 위해 FK 제약조건을 위반하지 않으려고 자식 행을 먼저 삭제해야 한다.

```sql
DELETE FROM BugStatus WHERE status = 'BOGUS'; -- 에러
DELETE FROM Bugs WHERE status = 'BOGUS';
DELETE FROM BugStatus WHERE status = 'BOGUS'; -- 재시도 성공
```
- 자식 테이블마다 한번 씩 여러 문장을 손수 실행해야 한다.

## 안티패턴 인식 방법
- 사람들이 다른과 같은 말을 한다면 안티패턴을 사용하고 있을 가느성이 크다.
  - 어떤 값이 한 테이블에는 있고 다른 테이블에는 없는것을 확인하려면 쿼리를 어떻게 작성해야 하지 ?
  - 테이블에 삽입하면서 다른 테이블에 어떤 값이 있는지를 확인하는 빠른 방법이 없을까 ?
  - FK 는 DB 를 느리게 만들기 때문에 사용하지 말라고 하던데 ?

## 안티패턴 사용이 합당한 경우
- FK 를 지원하지 않는 데이터베이스를 사용한다면 어쩔수 없는 부분이기도 하다.
- 관계를 모델링할때 FK 를 사용할 수 없는 극단적으로 유연한 데이터베이스 설계도 존재한다.

## 해법 : 제약조건 선언하기 
- 일본어에는 **포카요케 (poka-yoke)** 라는 표현이 있다.
  - 이는 오류 검증 이라는 뜻이다.
- 이 용어는 오류를 방지하거나 바로 잡거나 또는 발생 즉시 관심을 가져 제품의 결함을 제거하는데 도움이 되는 생성 공정을 뜻한다.
- 데이터베이스 설계에서도 참조 정합성을 강제하기 위해 FK 를 사용하는 방법으로 포카요케 원리를 적용할 수 있다.
- 정합성 오류를 찾아 정정하는 대신 처음부터 잘못된 데이터가 입력되지 않도록 하는 것

```sql
CREATE TABLE Bugs (
    ...
    reported_by BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'NEW',
    FOREIGN KEY (reported_by) REFERENCES Accounts(account_id),
    FOREIGN KEY (status) REFERENCES BugStatus (status)
);
```
- FK 를 사용하면 불필요한 코드를 작성하지 않아도 되고, 데이터베이스 변경시 모든 코드가 동일한 제약조건을 따른다는 것을 확신할 수 있다.

### 여러 테이블 변경 지원
- FK 는 애플리케이션 코드로 흉내 낼 수 없는 다른 기능이 있다.
  - 단계적 업데이트 (cascading update)

```sql
CREATE TABLE Bugs (
    ...
    reported_by BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'NEW',
    FOREIGN KEY (reported_by) REFERENCES Accounts(account_id)
                ON UPDATE CASCADE
                ON DELETE RESTRICT,
    FOREIGN KEY (status) REFERENCES BugStatus (status)
                ON UPDATE CASCADE
                ON DELETE SET DEFAULT  
);
```
- 이 방식을 사용하면 부모 행을 업데이트 하거나 삭제하는 경우 데이터베이스가 해당 부모를 참조하는 자식행을 알아서 처리해 준다.
- ON UPDATE/ON DELETE 절을 선언하는 방식에 따라 단계적 작업의 결과를 제어할 수 있다.

### 오버헤드 ? 그닥 ~
- FK 제약조건이 약간의 오버헤드가 있는 것은 사실이다.
- 하지만 다른 대안과 비교했을 때 FK 훨씬 효율적이라고 입증되었다.
- INSERT, UPDATE, DELETE 전 데이터 확인을 위해 SELECT 를 할 필요가 없다.
- 여러 테이블을 변경하기 위해 테이블 잠금을 사용할 필요가 없다.
- 불가피하게 생기는 고아데이터를 정정하기 위해 품질 제어 스크립트를 주기적으로 돌릴 필요가 없다.

## 생각 정리
- 이번장은 조금 반감이 드는 내용들이 많았음.
- FK 가 이론상 정합성을 보장해주고 좋은 도구 인것은 맞다.
- 정합성이 정말 중요한 경우 (결제, 은행권 등등)... 이런 곳이라면 FK 제약조건 까지 사용해서 정합성을 최대한 보장하게끔 최후방 (DB 레벨) 까지 걸어주는게 맞다고 생각함.
- 하지만 그외 대부분의 시스템 에서는 굳이 .... 라는 생각을 가지고 있다.
- 정합성을 위해 DB 에 의존한다 라는 것부터 애플리케이션을 그저 SQL Mapper 와 같은 형태로 개발하고 있을 확률이 크다고 생각함.
  - 애플리케이션 레벨에서 여러 유효성 검사를 충분히 거친 뒤에서야 DB 로 쿼리하는게 맞는 서순인데...
- FK 를 사용하지 않는 이유는 사실 시스템이 점점 커질수록... 데이터가 점점 많아질수록 운영 및 개발에 있어서 어려움을 겪기 때문에 Trade-Off 한것이라고 생각함..

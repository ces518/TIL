# 지옥 스터디 - 10 반올림 오류
- 프로젝트에서 버그 수정에 들어간 작업 시간에 기초해 프로그래머 비용을 계산한 보고서를 만들어야 한다.
- `Accounts` 테이블에 있는 각 프로그래머는 시간당 비용이 다르다.
- `Bugs` 테이블에 있는 버그를 수정하는데 각각 몇시간이 필요한지 기록하고, 여기에 해당 버그에 할당된 프로그래머의 `hourly_rate` 를 곱해야 한다.

```sql
SELECT b.bug_id, b.hours, * a.hourly_rate AS cost_per_bug
FROM Bugs AS b
JOIN Accounts AS a ON (b.assigned_to = a.account_id);
```
- 이 쿼리를 처리하기 위해 새로운 칼럼을 추가한다.
- 비용을 정확하게 추적하기 위해 `소수` 를 지원해야 하며 `FLOAT` 데이터 타입을 사용하기로 결정했다.
- 하지만 프로젝트 비용 보고서에서는 몇달러 정도 차이가 났다.

## 목표 : 정수 대신 소수 사용
- 정수는 유용한 타입이지만 정수만 저장할 수 있다.
- 2.5 와 같은 소수 값을 표현하지 못한다.
- 목표는 정수가 아닌 수를 저장하고, 산술 연산의 결과가 **정확** 해야 한다.

## 안티패턴 : FLOAT 데이터 타입 사용
- 대부분의 프로그래밍 언어는 `flaot` `double` 과 같은 실수를 표현하기 위한 데이터 타입을 지원한다.
- SQL 에서도 이와 비슷한 데이터 타입을 지원한다.
- 많은 개발자는 자연스럽게 SQL 에서도 `FLOAT` 을 사용한다.
- SQL 의 `FLOAT` 은 다른 프로그래밍 언어와 마찬가지로 IEEE 754 표준에 따라 실수를 이진 형식으로 부호화 한다.

### 필요에 의한 반올림
- 진짜 값을 정확히 표현하려면 무한대의 자리수가 필요하기에 십진수 소수로는 표현할 수 없다.
- 자릿수는 수의 정도 (precision) 이므로 순환 소수는 무한대가 필요하다.
- 타협안은 유한소수를 사용하고 0.333 과 같이 **원래 값에 가능한 가까운 값을 사용하는 것** 이다.
- IEEE 754 는 부동 소수점 수를 밑수가 2인 형식으료 표현한다.
- 데이터베이스에 `FLOAT` 타입으로 오차없이 표현되는 값만 저장되어 있다고 할 수는 없으므로 애플리케이션에서는 어떤 값이든 **반올림** 되었다고 가정해야 한다.
- 일부 데이터베이스는 `DOUBLE PRECISION` 과 `REAL` 이라 불리는 데이터 타입을 지원한다.
- 유한한 수의 이진수 자리로 부동 소수점 수를 표현하기에 `FLOAT` 과 비슷한 반올림 동작을 가진다.

### SQL 에서 FLOAT 사용
- 어떤 데이터베이스는 부정확한 값을 보정해 의도한 값을 표현해 준다.

```sql
SELECT hourly_rate FROM Accounts WHERE account_id = 123;
```
- 위 쿼리 결과는 59.95 를 리턴하지만 실제 저장된 값은 이 값과 정확하게 일치하지 않는다.
- 10억을 곱해보면 59950000762.939 를 리턴한다. 이 경우 오차범위는 천만분의 일 수준이므로 많은 계산에서 무시해도 될 정도이다.
- 하지만 **동등 비교** 에서는 문제가 된다.

```sql
SELECT * FROM Accounts WHERE hourly_rate = 59.95;
```
- 위 쿼리결과는 0건이다.
- 이 문제를 회피하는 흖나 방법은 일정 이상 수준으로 충분히 가까우면 **사실상 같은 값으로 다루는것** 이다.
- 두 값의 차를 구한 뒤 `ABS()` 함수를 이용해 절대값을 만들어 결과가 0이라면 두 값을 같은것으로 다룬다.

```sql
SELECT * FROM Accounts WHERE ABS(hourly_rate - 59.95) < 0.000001;
```
- 많은 값을 집계해 계산할 때도 `FLOAT` 의 부정확한 특성으로 인한 정확성 문제가 발생한다.
- `SUM()` 을 사용한다면 **반올림으로 인한 오차도 축적** 된다.
- 돈관련 계산을 한다면 **정확한 값** 을 사용하는 것이 중요하다.

## 안티패턴 인식 방법
- `FLAOT`, `REAL` `DOUBLE PRECISION` 타입이 사용중이라면 어디든 의심이 간다.
- 부동 소수점을 사용하는 대부분의 애플리케이션에서는 IEEE 754 에서 제공하는 넓은 범위의 값이 필요하지 않다.

## 안티패턴 사용이 합당한 경우
- `INTEGER` 또는 `NUMBERIC` 타입이 지원하는 것보다 큰 범위의 실수 값을 사용해하는 경우 `FLOAT` 을 사용하는 것이 좋다.
- 가장 적절한 예는 과학 계산용 애플리케이션

## 해법 : NUMERIC 데이터 타입 사용
- 고정 소수점 수에는 `FLOAT` 이나 이와 비슷한 타입 보다 `NUMERIC` 또는 `DECIMAL` 을 사용해야 한다.

```sql
ALTER TABLE Bugs ADD COLUMN hours NUMERIC (9, 2);
```
- 이런 데이터 타입은 칼럼 정의에서 지정한 정도까지 수치를 정확하게 표현한다.
- 두번째 인수로 **스케일** 을 지정할 수 있다.
- 스케일은 소수점 오른쪽 자리 수
- 칼럼에 지정한 정도와 스케일은 테이블의 모든 행에 적용된다.
- `NUMERIC` 과 `DECIMAL` 의 장점은 유리수가 `FLOAT` 타입에서와 같이 반올림 되지 않고 저장된다는 것이다.
- 59.95 로 지정하면 정확하게 59.95 로 저장된다고 확신할 수 있다.
- `NUMERIC` 과 `DECIMAL` 은 동일하게 동작하며 `DEC` 는 `DECIMAL` 의 동의어 이다.
- 1/3 과 같이 무한 정도를 필요롤 하는 수는 저장하지 못한다.
- 정확한 십진수 값이 필요하다면 `NUMERIC` 을 사용해야 한다.

> 가능한 FLOAT 을 사용하지 말라.

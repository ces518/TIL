# 지옥 스터디 - 13 인덱스 샷건

## 목표 : 성능 최적화
- 데이터베이스의 성능을 향상시키는 가장 좋은방법 ? => 인덱스를 사용하는 것
- 인덱스란 데이터베이스가 사용하는 데이터구조. 값과 이 값을 가지는행을 서로 연관시켜 놓은 것이다.

## 안티패턴 : 무계획하게 인덱스 사용하기
- 인덱스를 언제 사용해야하는지 오해하고 있다면 다음 셋 중 하나의 실수를 하게 된다.
  - 인덱스를 불충반하게 정의하거나 아에 정의하지 않는다.
  - 너무 많은 인덱스를 정의하거나 도움이 되지 않는 인덱스를 정의한다.
  - 어떤 인덱스도 도움이 될 수 없는 쿼리를 실행한다.

### 없는 인덱스
- 보통 인덱스를 최신으로 유지하는데 **오버헤드** 가 있다는 글을 많이 본다.
  - INSERT/UPDATE/DELETE 시 마다 인덱스 구조를 변경해야 한다.
- 하지만 인덱스는 오버헤드를 상쇄할 정도로 이득이 있다는 사실을 모른다.
- 일반적인 애플리케이션이라면 한번 업데이트할때 조회는 수백 수천번 이상 할 것이다.
- 이는 인덱스 유지시 오버헤드를 상쇄하고도 남는다.
- 또한 UPDATE/DELETE 문에도 도움이 된다.

```sql
UPDATE Bugs SET status = 'FIXED' WHERE bug_id = 1234;
```
- 인덱스가 없는 컬럼이라면 테이블 풀 스캔이 발생할 것이다.

### 너무 많은 인덱스
- 인덱스를 사용하는는 쿼리를 실행해야만 인덱스로 부터 이득을 얻을 수 있다.
- 사용되지 않는 인덱스를 생성하면 아무런 이득이 없다.
- 어떤 사람은 모든 칼럼에 인덱스를 만들기도 한다.
- 어떤 인덱스가 어떤 쿼리에 도움을 주는지 모르기 때문이다.

### 인덱스가 도움이 되지 않을 때
- 실수의 또 다른 형태는 아무런 인덱스도 사용할 수 없는 쿼리를 실행하는 것이다.
- 다음과 같은 인덱스가 있다고 가정해보자.

```sql
CREATE INDEX TelephoneBook ON Accounts (last_name, first_name);
```
- 다음은 위 인덱스를 사용하지 못하는 쿼리의 예 이다.

```sql
-- last_name, first_name 으로 인덱스를 생성했기에 인덱스를 사용하지 못함.
SELECT * FROM Accounts ORDER BY first_name, last_name;
```

## 안티패턴 인식 방법
- 다음은 **인덱스 샷건** 안티패턴의 징후 이다.
  - 이게 내 쿼리인데 어떻게 빠르게 할 수 있을까 ?
  - 모든 필드에 인덱스를 걸었는데 왜 빠르지 않은 거지 ?
  - 인덱스가 데이터베이스를 느리게 만든다고 들었어. 그래서 난 인덱스를 사용하지 않지 ㅎ

## 안티패턴 사용이 합당한 경우
- 어떤 쿼리를 최적화 해야 하는지 알지 못하는 상태에서 데이터베이스를 설계해야 한다면 어떤 인덱스를 잡아야 할지 확신할 수 없다.
- 불필요한 것으로 밝혀질 인덱스를 생성하게 될 수도 있다.
- 가능한 최적의 추측을 해야 한다.

## 해법 : 인덱스를 MENTOR 하라
- 인덱스 샷건은 적절한 이유 없이 인덱스를 생성하거나 삭제하는 것에 대한 안티패턴이다.
- 데이터베이스를 분석해 인덱스를 만드는것이 좋은지, 만들지 않는 것이 좋을지 판단하는 방법을 살펴보자.
- 좋은 인덱스를 선정하기 위핸 체크리스크를 기억하기 위해 **MENTOR** 를 사용할 것이다.
  - Measure
  - Explain
  - Nominate
  - Test
  - Optimize
  - Rebuild

### 측정 (Measure)
- 정보 없이는 제대로된 결정을 내릴 수 없다.
- 대부분의 데이터베이스는 SQL 쿼리가 실행된 시간을 로그로 남기는 방법을 제공한다.
- 이를 이용해 가장 만이 들어간 작업을 식별할 수 있다.
  - MySQL 의 `slow query log` 를 이용 하는 등...
- 애플리케이션에서 **가장 많은 시간을 잡아먹는 쿼리** 가 **가장 많은 비용** 이 드는 부분이 아닐 수 있다.
  - 이 쿼리가 아주 가끔 실행되는 경우..
- 오히려 단순한 쿼리가 매우 자주 실행되어 전체적으로 많은 비용을 소모하고 있을 수도 있다.
- 이러한 쿼리에 관심을 갖고 최적화를 한다면 높은 투자대비 효과를 얻을 수 있다.
- 쿼리 성능 측정시에는 **쿼리 결과 캐싱 기능** 을 비활성화 시켜야 정확한 측정을 할 수 있다.
- 실제 애플리케이션을 디플로이 한 이후 프로파일링 한다면 더 정확한 정보를 얻을 수 있다.

### 실행 계획 확인 (Explain)
- 비용이 많이 드는 쿼리를 확인했다는 그 이유를 찾아야 한다.
- 데이터베이스 **옵티마이저 (Optimizer)** 를 쿼리가 사용할 인덱스를 고른다.
- 이런 분석 결과를 리포트로 볼 수 있는데 이를 쿼리 실행 계획 이라고 한다.
- 쿼리 실행 계획에 포함되는 정보나 리포트 형식에 대한 표준은 없다.
- 보통 쿼리 실행계획은 쿼리가 어떤 테이블이 연관되어 있는지, 옵티마이저가 사용할 인덱스를 어떻게 선택하는지, 테이블에 어떤 순서로 접급하는지를 보여준다.

```sql
EXPLAIN SELECT Bugs.*
FROM Bugs
JOIN BugProducts JOIN Products USING (product_id)
USING (bug_id)
WHERE summary LIKE '%crash$'
AND product_name = 'Open RoundFile'
ORDER BY date_reported DESC;
```

### 지명 (Nominate)
- 옵티마이저의 실행 계획을 가지고 있으므로 쿼리에서 인덱스를 사용하지 않고 테이블에 접근하는 부분을 살펴볼 차례이다.
- 데이터베이스에서 이런 작업을 대신해주는 도구들이 있다.
  - IBM DB2 Design Advisor
  - SQL Server Database Engine Tuning Advisor
  - MySQL Enterprise Query Analyzer
  - Oracle Automatic SQL Tuning Advisor

### 테스트 (Test)
- 인덱스를 생성한 후 쿼리를 다시 프로파일링 해야한다.
- 변경으로 인해 차이가 생겼고 작업이 제대로 처리되었음을 확인하는 것이 중요하다.

### 최적화 (Optimize)
- 인덱스는 빈번하게 사용되는 데이터 구조로, 캐시 메모리에 보관할 좋은 후보이다.
- 캐시에 얼마나 많은 메모리를 할당해야 하는가 ? 이에 대한 답은 없다.
- 데이터베이스 크기와 가용한 시스템 메모리양에 따라 다르기 때문이다.

### 재구성 (Rebuild)
- 인덱스는 균형이 잡혀있을 때 가장 효율이 ㅈㅎ다.
- 시간이 지나면서 데이터를 업데이트하고 삭제함에 따라 인덱스도 점점 균형을 잃는다.
- 인덱스를 최대한 활용하고 싶다면 주기적으로 인덱스를 정비해줄만한 가치가 있다.
- 인덱스 재구성을 **얼마나 자주** 해야 하는가 ?
- 일주일에 한번 ? 과 같은 일반적인 대답을 들었을테지만 모든 애플리케이션에 해당하는 답은 없다.
- 가장 중요한 규칙은 **인덱스에 대한 맹목적인 추측은 좋은 전략이 아니다**

> 데이터를 알고, 쿼리를 알고, 인덱스를 MENTOR 하라.


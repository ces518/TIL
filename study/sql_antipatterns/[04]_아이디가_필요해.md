# 지옥 스터디 - 04 아이디가 필요해
- 컨텐트 관리 데이터베이스에 웹 사이트에 공개할 기사를 저장한다.
- 기사 테이블가 태그 테이블 사이의 다대다 관계를 위한 **교차 테이블** 을 사용한다.

```sql
CREATE TABLE ArticleTags(
    id SERIAL PRIMARY KEY,
    article_id BIGINT NOT NULL,
    tag_id BIGINT NOT NULL,
    FOREIGN KEY (article_id) REFERENCES Articles(id),
    FOREIGN KEY (tag_id) REFERENCES Tags(id)
);
```
- 특정 태그를 검색하는 쿼리를 날리면 잘못된 결과가 출력되었다.
- 이 테이블은 PK 를 가지고 있었지만, 중요 칼럼의 중복을 막지 못했다.
- 유니크 제약조건을 사용하면 해결이 되겠지만, 그렇다면 **id 컬럼은 왜 필요한 것인가 ?**

## 목표 : PK 관계 확립
- 모든 테이블이 PK 를 갖도록 하는 것이 목표지만, PK 의 본질을 혼동하면 안티패턴을 초래할 수 있다.
- PK 는 좋은 데이터베이스 설계에 정말 중요하다.
- PK 는 테이블 내 모든 행에대해 유일함을 보장하기 때문에 각 행에 접근하는 논리적인 메커니즘이 되고 중복 행 저장을 방지한다.
- 또한 관계 형성시 FK 로 부터 참조되가도 한다.
- **까다로운 부분** 은 PK 로 사용할 컬럼을 선정하는 일이다.

`정말 PK 가 필요할까 ?`
- UNIQUE 인덱스를 유지하는데 오버헤드가 많을 것이라 추측해 이를 피하는 경향도 있다.
- 다음 3가지 목적이 있따면 PK 제약 조건은 중요하다.
  - 테이블 중복 로우 저장 방지
  - 쿼리에서 각 행을 참조
  - FK 참조 지원
  
- 이런 테이블에는 테이블로 모델링한 영역에서는 아무런 의미도 가지지 않는 **인위적인 값을 저장할 컬럼** 이 필요하다.
- 이런 형태의 PK 를 **가상키 (pseudokey)** 또는 **대체키 (surrogate key)** 라고 한다.
- 여러 클라이언트가 동시에 새로운 행을 삽입하는 경우에도 가상키 값이 유일하게 할당되는 것을 보장하기 위해 대부분의 DBMS 에서 트랜잭션 격리 범위 밖에서 유일한 정수 값을 생성하는 메커니즘을 제공한다.

| 기능 | DBMS |
| --- | --- |
| AutoIncrement | MySQL |
| GENERATOR | Firebird, InterBase |
| IDENTITY | DB2, Derby, Microsoft SQL Server, Sybase |
| ROWID | SQLite |
| SEQUENCE | DB2, Firebird, Informix, Ingres, Oracle, PostgreSQL |
| SERIAL | MySQL, PostgreSQL |

## 안티패턴 : 만능 키
- 책이나 프로그래밍 프레임워크는 데이터베이스 내 모든 테이블이 다음과 같은 특성을 가지는 PK 를 가지도록 하는 관례를 만들었다.
  - PK 컬럼명은 id
  - PK 컬럼의 데이터 타입은 32/64 비트 정수
  - 유일한 값은 자동 생성 된다

```sql
CREATE TABLE Bugs (
    id SERIAL PRIMARY KEY,
    description VARCHAR (1000)
);
```
- 모든 테이블에 id 컬럼을 추가하는 것은 그 사용을 이상하게 만드는 몇 가지 효과를 초래한다.

### 중복 키 생성
- 테이블 내 다른 컬럼이 **자연키** 로 사용될 수 있음에도 통념에 따라 id 컬럼을 PK 로 정의한 것을 흔히 볼 수 있다.
- 다른 컬럼에 유니크 제약조건이 걸려있는 경우도 있다.
- 예를 들어 다음 테이블에서는 프로젝트 코드를 앞에 붙여 bug_id 를 만들 수 있을 것이다.

```sql
CREATE TABLE Bugs (
    id SERIAL PRIMARY KEY,
    bug_id VARCHAR (10) UNIQUE,
    description VARCHAR (1000)
);

INSERT INTO Bugs (bug_id, description, ...)
VALUES ('VIS-078', 'crashes on save', ....);
```
- 위 예제에서는 bug_id 칼럼이 각행을 유일하게 식별하게 해준다는 점에서 id 와 목적이 동일하다.

### 중복 행 허용
- 복잡키는 여러 칼럼을 포함한다.
- 복합키가 사용되는 전형적인 예는 Bugs Products 와 같은 교차 테이블안에서 잉다.
- PK 는 특정한 bug_id / product_id 값의 조합이 유일함을 보장해야 한다.
- 하지만 id 컬럼을 PK 로 사용한다면 유일해야 하는 두 컬럼에 제약조건을 적용하지 않는다.
- 중복 방지를 위해 id 뿐만이 아닌 다른 두 컬럼에도 유니크 제약조건을 걸어야 한다.

### 모호한 키의 의미
- 코드란 단어는 여러 가지 정의를 가진다.
- 그중 하나 -> **간결하거나 비밀스럽게 메세지를 주고받는 방법**
- 프로그래밍에서 코드 -> **의미를 명확하게 한다** 는 반대 목표를 가져야 한다.
- id 는 너무 일반적이기 때문에 아무런 의미를 갖지 못한다.
- PK 컬럼이 동일한 테이블을 조인할 때 문제가 된다.

```sql
SELECT b.id, a.id
FROM Bugs b
JOIN Accounts a ON (b.assigned_to = a.id)
WHERE b.status = 'OPEN';
```
- PHP 와 같은 동적 언어에서는 이는 문제가 될 수 있다.
- 쿼리 결과가 연관 배열에 반환되기 때문에 쿼리 컬럼 알리아스를 지정하지 않으면 다른 컬럼을 덮어써 버린다.
- 우리는 테이블의 개별 행에 접근시 PK 를 사용하기 때문에 PK 칼럼의 이름이 테이블의 엔티티 타입에 대한 실마리를 주어야 한다.

### USING 사용
- JOIN 과 ON 키워드를 사용하는 SQL 조인 문법에 익숙할 것이다.
- SQL 은 두 테이블에 대한 조인을 표현하는 간략한 문법도 지원한다.

```sql
SELECT * FROM Bugs JOIN BugsProducts USING (bug_id);
```
- 하지만 모든 테이블에 id 라는 이름의 가상 키를 PK 로 정의한다면 종속된 테이블에서 FK 컬럼이 참조하는 테이블의 PK 칼럼과 동일할 수 없게 된다.
- 때문에 항상 ON 문법을 사용해야만 한다.

### 어려운 복합키
- 어떤 개발자는 사용하기 어렵단 이유로 복합키를 꺼린다.
- 키 비교시 모든 컬럼을 비교해야 한다.
- 복합 PK 를 참조하는 FK 는 자신도 복합 FK 가 되어야 한다.

`시퀀스의 특별한 범위`
- 어떤 사람을 최대값 + 1 을 키 값으로 사용한다.
- 두 개의 클라이언트가 동시에 쿼리를 실행한다면 이런 방식은 안전하지 않다.
- 두 클라이언트에서 같은 값을 사용하게 될 수도 있기 때문이다.
- 이런 경우 경쟁 상태를 피하기위해 전체 테이블 잠금을 사용해야 한다.
- 이는 병목의 원인이 된다.
- 시퀀스는 **트랜잭션 범위 밖** 에서 동작하기에 이 문제를 해결한다.

## 안티패턴 인식 방법
- 이 안티패턴의 징후는 쉽게 인식이 가능하다.
- 테이블에서 PK 칼럼 이름으로 id 가 사용된다면 이 안티패턴의 징후로 볼 수 있다.
- 다음과 같은 말은 안티패턴의 증거가 될 수 있다.
  - 이 테이블에는 PK 가 없어도 될 것 같은데...
  - 다대다 연결에서 왜 중복이 발생했지 ?
  - 나는 데이터베이스 이론에서 값은 색인 테이블로 옮기고 ID 로 참조해야 한다는 걸 읽었다. 하지만 매번 조인해야하기 때문에 싫다.
    - 이는 정규화에 대한 흔한 오해이다.
    - 정규화는 가상키와 아무런 관련이 없다.
    
## 안티패턴 사용이 합당한 경우
- 일부 객체-관계 프레임 워크에서는 CoC (Convention over Configuration) 를 통해 개발을 단순화 한다.
- 이런 프레임워크에서는 모든 테이블이 동일한 방식으로 PK 를 정의한다고 가정한다.
- 가상키를 사용하는 것은 잘못이 아니다. 하지만 모든 테이블에 가상키가 필요한 것은 아니며 모든 가상키 컬럼을 id 로 해야할 이유도 없다.
- 가상키는 지나치게 긴 자연키를 대체하기 위한 적절한 선택이다.

## 해법 : 상황에 맞추기
- PK 는 **제약 조건이지 데이터 타입이 아니다**
- 데이터 타입이 인덱스를 지원하기만 하면, 어느 칼럼 또는 칼럼의 묶음에 대해서도 PK 를 선언할 수 있다.
- 테이블의 특정 컬럼을 PK 로 잡지않아도 자동증가 정수값을 사용할 수 있다. 이 두개념은 서로 독립적이다.
- 좋은 설계 방법에 경직된 관례가 끼어드는 것을 허용하지 말라.

### 있는 그대로 말하기
- PK 에 의미 있는 이름을 선택해야 한다.
- 이 이름은 PK 가 식별하는 엔티티의 타입을 나타내야 한다.
- Bugs 테이블이라면 bug_id 가 되어야 한다.
- FK 에서도 가능하다면 동일한 이름을 사용해야 한다.

### 관례에서 벗어나기
- 객체-관계 프레임워크는 id 란 이름의 가상키가 사용될 것을 기대하지만 다른 이름을 사용하도록 재설정 하는것도 가능하다.

### 자연키와 복합키 포용
- 유일함이 보장되고 NULL 을 가지는 경우가 없고 행을 식별하는 용도로 사용할수 있는 속성이 테이블에 있다면, 단지 통념을 따르기 위한 가상키를 추가해야 한다는 의무감을 느낄 필요는 없다.
- 테이블에 각 속성은 변하기 마련이고, 유일하지 않알 수도 있다.
- 자연키로 손색 없어보이던 값도 나중에 알고보니 중복을 허용한다거나 하는 일이 발생할 수 있다. 이런경우 가상키를 사용할 수 있다.
- 복합키가 적절한 경우라면 복합키를 사용해야 한다.

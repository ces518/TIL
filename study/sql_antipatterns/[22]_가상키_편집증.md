# 지옥 스터디 - 22 가상키 편집증

[22.1 목표 - 데이터 정돈하기](#221-목표:-데이터-정돈하기)

[22.2 안티패턴 - 모든 틈 메우기](#222-안티패턴:-모든-틈-메우기)

[22.3 안티패턴 인식 방법](#223-안티패턴-인식-방법)

[22.4 안티패턴 사용이 합당한 경우](#224-안티패턴-사용이-합당한-경우)

[22.5 해법 - 극복하라](#225-해법:-극복하라)

---

## 22.1 목표: 데이터 정돈하기

수열 중간에 숫자 몇 개 빠지면 매우 불편한 사람들이 있다.

| bug_id | status | product_name |
| --- | --- | --- |
| 1 | OPEN | Open RoundFile |
| 2 | FIXED | ReConsider |
| 4 | OPEN | ReConsider |

bug_id 가 3인 행에 어떤 일이 발생했는지 알 수 없기 때문에 신경이 쓰인다. <br/>
**가상키 편집증 안티패턴** 을 사용하는 사람의 목표는 위와 같은 문제를 해소하는 것이다.

## 22.2 안티패턴: 모든 틈 메우기

틈을 발견했을 때 대다수 사람들은 그 틈을 메우고 싶어 한다. <br/>
틈을 메우는 방법은 **두 가지가 있다.**

### 시퀀스에서 벗어난 번호 할당하기

새로운 행 에 키 값 할당시, 자동 생성 메커니즘 대신 PK 값 중 사용되지 않은 첫 번째 값을 사용하는 방법

| bug_id | status | product_name |
| --- | --- | --- |
| 1 | OPEN | Open RoundFile |
| 2 | FIXED | ReConsider |
| 4 | OPEN | ReConsider |
| 3 | OPEN | ReConsider |

하지만 이 방법을 사용하려면 불필요한 셀프 조인을 이용해야 한다. <br/>
SELECT MAX + 1 과 같은 형태의 쿼리는 동시성 문제가 있으며 이 방법도 동일한 문제가 있다.
```sql
SELECT b1.bug_id + 1
FROM Bugs b1
LEFT JOIN Bugs AS b2 ON b1.bug_id + 1 = b2.bug_id
WHERE b2.bug_id IS NULL
ORDER BY b1.bug_id LIMIT 1;
```

### 기존 행의 번호를 다시 매기기

PK 값을 연속적으로 만드는 것에 정신이 팔려 기존 행에 대한 키 값을 업데이트 하는 방법을 사용할 수도 있다.

```sql
UPDATE Bugs SET bug_id = 3 WHERE bug_id = 4;
```

| bug_id | status | product_name |
| --- | --- | --- |
| 1 | OPEN | Open RoundFile |
| 2 | FIXED | ReConsider |
| 3 | OPEN | ReConsider |
| 4 | OPEN | ReConsider |

이 방법을 사용하기 위해서는 앞서 살펴본 방법과 비슷한 방법으로 사용되지 않은 키 값을 찾아야 한다. <br/>
그리고 마찬가지로 동시성 문제가 발생할 가능성이 있으며 틈이 많다면 이를 여러번 수행해야 한다.

### 데이터 불일치 만들기

PK 값을 재사용하는 것은 좋은 생각이 아니다. <br/>
적절한 이유로 행을 삭제했다거나 롤백의 결과일 수도 있기 때문이다. <br/>
가상 값에 빈 값이 있다고 해서 키를 재할당하면 안된다.

## 22.3 안티패턴 인식 방법

다음과 같은 말이 나온다면 **가상키 편집증 안티패턴** 을  사용하고 있음을 암시한다.
- INSERT 를 롤백햇을 때 자동 생성된 아이디 값을 어떻게 재사용 가능할까 ?
- bug_id 4 에 무슨일이 일어난 거지 ?
- 사용되지 않은 첫 번째 아이디 값을 어떻게 조회할 수 있을까 ?
- 번호가 넘치면 어떻게 되지 ?

## 22.4 안티패턴 사용이 합당한 경우

가상키 값은 아무런 의미를 가지지 말아야 하기 때문에 가상 키 값을 바꿀 이유는 없다. <br/>
PK 칼럼이 어떤 의미를 가진다면 그건 자연키 이다.

## 22.5 해법: 극복하라

PK 는 유일해야 하고 NULL 이 아니어서 각 행을 참조하는데 사용할 수 있어야 한다. <br/>
행을 식별하는데 연속적인 숫자일 필요가 없다.

### 행에 번호 매기기

대부분의 가상키 생성기는 **행번호** 처럼 보이는 번호를 반환한다. <br/>
유일성을 보장하는 편리한 방법이기 때문에 단조 증가 값형태로 구현되어 있다.

### GUID 사용하기

일부 데이터베이스는 한 번이상 사용하지 않으면서 랜덤한 가상키 생성 방법인 **GUID (Global Unique Identifier)** 를 지원한다. <br/>
GUID 는 128비트 의사난수 (pseudorandom number) 로 보통 32자리 16진수로 표현한다. <br/>
GUID 는 유일하기 때문에 가상키에 GUID 를 생성해 사용할 수 있다. <br/>
GUID 를 사용하면 일반적인 가상키 생성기 사용시 보다 최소 두 가지 좋은 점이 있다.
- 중복을 걱정하지 않고 여러 데이터베이스 서버에서 동시에 가상키 생성이 가능하다.
- PK 값으로 16진수를 32자리를 입력해야 하기 때문에 틈에 대해 불평하지 않는다.
GUID 사용시 다음과 같은 단점도 존재한다.
- 값이 너무 길고 입력하기 나쁘다.
- 값이 랜덤하기 때문에, 어떤 패턴을 추론할 수 없고 큰 값이 최근 행을 나타낸다고 생각할 수도 없다.
- GUID 를 저장하는 데는 16바이트가 필요하다. 공간차지도 많이 하고 속도도 느리다.

### 가장 중요한 문제

가상키 번호를 다시 매길경우 발생하는 문제와 대안을 살펴보았다. <br/>
하지만 가장 큰 문제가 남아있는데, 바로 상사를 설득하는 것이다. <br/>
이는 커뮤니케이션 문제이지 기술적 문제가 아니다.

> 가상키를 행의 식별자로 사용한다. 가상키는 행 번호가 아니다.





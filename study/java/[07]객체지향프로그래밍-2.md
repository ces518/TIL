# 지옥자바 스터디 - 07 객체지향 프로그래밍 - 2

## 상속 (Inheritance)

`상속 이란?`
- **상속** 은, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 코드를 공통적으로 관리할 수 있기 때문에 ~~코드의 추가 및 변경이 매우 용이하다.~~
  - 이론상으론 그렇지만... 현실적으로 봤을땐 상속으로 인해 얻는 장점보다 단점이 더 많기 때문에 공감하기 힘들다.
  - 중복 제거 / 코드 재사용을 목적으로 상속을 사용하는 것은 좋은 방법이 아니다.
  - is a 관계를 모델링 해야한다면 **상속** 이 옳은 선택.
- **extends** 키워드를 사용해서 구현한다.
  - 자손 클래스는, 조상 클래스의 모든 멤버를 상속받는다. <br/>
    때문에 항상 조상클래스보다 같거나 많은 멤버를 갖고 있다. <br/>
    상속을 받는다는 것은 조상 클래스는 **확장** 한다는 의미로 해석이 가능한데, 때문에 extends 라는 키워드를 사용한다. 
`올바르지 않은 상속의 예`

```java
class Document {
}

interface Importer {
	Document importFile(File file);
}

class LetterImporter implements Importer {

	@Override
	public Document importFile(File file) {
		// ...
	}
}

class ReportImporter implements Importer {

	@Override
	public Document importFile(File file) {
		// ...
	}
}

class InvoiceImporter implements Importer {

	@Override
	public Document importFile(File file) {
		// ...
	}
}
```
- 각 Importer 들의 공통기능을 TextImporter 라는 클래스를 만들어서 모아두고, Letter, Report, Invoice Importer 에서 이를 상속받아 재사용한다고 가정
- TextImporter 는 **LSP** 를 준수하지만, 실제 관계가 반영 되어 있지 않아 상속은 쉽게 깨질 수 있다.
- 각 Importer 의 구현체들이 변경될 여지가 있을때 **변화를 추상화** 하는것이 좋은 방법

> LSP 와 같은 원칙을 준수하더라도, **실제 관계가 반영되어 있지 않다면 상속은 쉽게 깨질 수 있다.**

`리스코프 치환원칙 LSP`

1. 하위 타입에서 선행 조건을 더 할 수 없다. (부모가 지정한 것 보다 더 많은 선행조건을 요구할 수 없다.)
   - 선행 조건이란, 어떤 코드가 동작하기 위한 전재 조건
   - 위에서 살펴본 Importer 라는 구현은 읽을 파일이 존재하고, 읽을 수 있어야 한다는 **선행 조건** 을 가지고 있다.
   - Importer 를 통해 import 하기 전 검증을 수행하는 작업이 필요
2. 하위 타입에서 후행 조건을 약화할 수 없다. (부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 반드시 그래야한다.)
   - 후행 조건이란, 코드를 실행한 뒤 만족해야 하는 조건
   - Importer 를 통해 importFile 을 수행했다면, 반환하는 문서 목록에 해당 파일이 포함되어 있어야 한다.
3. 부모 타입의 불변자는 하위 타입에서도 보존되어야 한다.
   - 상속 관계의 부모와 자식 클래스인 경우 부모 클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 한다.

`상속 관계의 클래스`
- 조상 클래스
  - 부모 클래스, 상위 클래스, 기반 클래스
- 자손 클래스
  - 자식 클래스, 하위 클래스, 파생된 클래스

`상속 보다는 컴포지션`
- 상속을 통해 클래스 간에 관계를 맺어주고, 클래스를 재사용하는 방법이 외에도, **포함 (Composition)** 관계를 맺어 주는것도 가능하다.
- 클래스의 멤버 변수로 다른 클래스 타입의 참조 변수를 선언하는 방법
- 
```java
class Point {
	int x;
	int y;
}
class Circle {
	Point c = new Point();
	int r;
}
```

> 하나의 거대한 클래스 (갓-클래스 라고도 한다.) 를 사용하는것 보다 여러 개의 클래스를 작성하고 이를 포함관계로 재사용 하는 것이 더 좋은 방식

`클래스간의 관계 결정`
- 클래스 작성시 상속 관계를 맺을 것이냐, 포홤 관계를 맺을 것이냐 결정하기 힘들 때가 많다.
- 이런 경우 SOLID 와 같은 객체지향 설계 원칙 을 따르면서도, **실제 관계를 반영하는 것이 좋은 설계** 이다.
    - 원 (Circle) 은 점 (Point) 이다. -> is a 관계 (상속)
    - 원 (Circle) 은 점 (Point) 을 가지고 있다. -> has a 관계 (포함)

> 만약 객체지향 설계 원칙을 준수하더라도, 실제 관계가 반영되어 있지 않다면, 그 관계는 쉽게 깨질 가능성이 높다.

`단일 상속`
- 자바는 단일 상속만을 허용 하기 때문에 하나 이상의 클래스로부터 상속을 받을 수 없다.
- 다중 상속의 장점은 여러 클래스를 상속받음으로 인해 **복합적인 기능을 쉽게 작성** 할 수 있지만 단점 또한 명확하다.
- 다중 상속을 허용한 경우 부모클래스들에게 **동일한 시그니쳐를 가지는 메소드가 있을 경우 이를 구분할 방법** 이 없다.
- 자바는 이런 문제때문에 다중상속의 장점을 포기하고, 단일 상속만을 허용했다.

> 단일 상속만을 허용함으로 인해 보다 관계가 명확해진다.

`Object 클래스`
- Object 클래스는 모든 클래스 상속 계층의 최상위에 존재하는 조상 클래스이다.
- 부모 클래스를 가지지 않는 클래스는 암묵적으로 Object 클래스를 상속받는다.
  - 이는 컴파일러가 자동으로 작성을 해준다.

## 오버라이딩 (overriding)

`오버라이딩 이란?`
- 오버라이딩은, 조상으로 부터 상속 받은 메소드의 구현을 자식에서 변경하는 것을 의미한다.
- 상속 받은 메소드를 그대로 사용할 때도 있지만, 필요에 따라 자식에서 해당 구현을 변경해야 하는 경우가 있다.

`오버라이딩의 조건`
- 오버라이딩은 메소드의 구현만 변경하는 것이기 때문에 메소드 시그니쳐는 부모와 100% 일치해야한다.
- 즉 메소드명 / 매개변수 / 반환 타입 모두 일치해야한다.

> JDK 1.5 버전 부터 **공변 반환 타입 (covariant return type)** 이 추가되어, **반환 타입을 해당 클래스의 자식 클래스 타입으로 변경** 할 수 있다.

- 접근 제어자와 예외는 제한된 조건하에 변경이 가능하다.
1. 접근 제어자는 조상 클래스의 메소드 보다 좁은 범위로 변경 할 수 없다.
   - protected 라면, override 하더라도, protected 보다 높은 레벨의 제한을 걸 수 없다. (protected 또는 public 이어야 한다.)
2. 조상 클래스의 메소드 보다 많은 수의 예외를 선언할 수 없다.
    - 단순히 선언된 예외의 개수 문제가 아니고, 더 넓은 범위의 예외에도 적용이 된다.
    - IOException -> Exception 으로 변경하는 등...
3. 인스턴스 메소드를 스태틱으로, 또는 그 반대의 경우도 변경할 수 없다.

> static 메소드는 오버라이딩 할 수 없다. static 멤버들은 클래스를 로드하는 시점에 이미 결정되어 있기 때문에 애초에 성립이 되지 않는다.

`오버로딩 과 오버라이딩`
- 오버로딩과 오버라이딩을 헷갈려하는 경우가 많은데 사실 그 차이는 명확하다.
- **오버로딩** 은 새로운 메소드를 추가하는것
- **오버라이딩** 은 기존 메소드를 재구현 하는것

`super`
- super 라는 키워드는 자손 클래스에서 조상 클래스의 멤버를 참조할때 사용하는 변수이다.
- 상속받은 멤버 또한 본인의 멤버이기 때문에 this 로 접근이 가능하고, 상속 받은 멤버와 본인 의 멤버명이 같을 경우 super 를 통해 구별할 수 있다. 

`super() - 부모 클래스의 생성자`
- super() 역시 생성자이고, this() 가 같은 클래스의 다른 생성자를 호출했다면, **super() 는 부모 클래스의 생성자를 호출** 한다.
- 상속 관계의 경우 조상 클래스의 멤버에 대한 초기화가 먼저 수행되어야 하기 때문에 자식 클래스의 생성자 첫 라인에는 **반드시 부모 클래스의 생성자가 호출** 되어야 한다.

> Object 클래스를 제외한 모든 클래스의 생성자의 첫 라인에는 this() 혹은 super() 를 호출해야한다. <br/>
> 만약 해당 코드가 존재하지 않는다면 컴파일러가 super() 호출을 자동으로 넣어준다.

- 부모의 멤버 변수는 부모의 생성자에 의해 초기화 되도록 해야 한다.

```java
Point3D (int x, int y, int z) {
	super(x, y);
	this.z = z;
}
```

## 메소드 디스패치
- 자바의 테크닉 중 하나, 런타임에 실행할 메소드를 결정하는 방법
- 정적 디스패치, 동적 디스패치, 더블 디스패치
- 자바는 메소드 호출시 암묵적으로 참조를 넘긴다.

`정적 디스패치 (static dispatch)`
- 컴파일 시점에 컴파일러가 어떤 클래스의 메소드를 호출해야 하는지 알고 있고, 바이트코드에 기록된다.
- 추상클래스, 인터페이스를 구현하고 있지 않은 클래스의 인스턴스 메소드를 호출하거나, static 메소드를 호출하는 경우

```java
class StaticDispatch {
	
	void run() {
		
    }
}
```

`동적 디스패치 (dynamic dispatch)`
- 컴파일 시점에 컴파일러가 어떤 메소드를 호출해야 하는지 알 수없다.
- 특정 타입의 메소드를 호출한다는 정보만 존재한다.
- 런타임 시점에 할당된 객체의 정보를 확인해 해당 메소드를 호출한다.

```java
interface Dispatch {
	void run();
}

class DynamicDispatch {
	
	@Override
    void run() {
		
    }
}
```

`더블 디스패치 (double dispatch)`
- Dynamic Dispatch 를 두번 수행하는것

```java
interface Post {
	void postOn(Sns sns);
}

class Text implements Post {
	@Override
	public void postOn(Sns sns) {
		sns.post(this);
	}
}

class Picture implements Post {
	@Override
	public void postOn(Sns sns) {
		sns.post(this);
	}
}

interface Sns {
	void post(Text text);

	void post(Picture picture);
}

class Facebook implements Sns {
	@Override
	public void post(Text text) {

	}

	@Override
	public void post(Picture picture) {
        
	}
}

class Twitter implements Sns {
	@Override
	public void post(Text text) {

	}

	@Override
	public void post(Picture picture) {

	}
}

// 실행
public static void main(String[] args) {
    List<Post> posts = Arrays.asList(new Text(), new Picture());
    List<SNS> sns = Arrays.asList(new Facebook(), new Twitter());

    posts.forEach(p -> sns.forEach(s -> p.postOn(s)));
}
```
- Post 인터페이스의 구현체중 어떤 구현체의 postOn 를 호출할지 동적 디스패치 1회 발생
- postOn 메소드 중 어떤 SNS 구현체를 받는 post 메소드를 호출할지 동적 디스패치 1회 추가 발생

> Visitor Pattern

## package 와 import

`패키지 (package)`
- 패키지는, 클래스의 묶음
  - 클래스 혹은 인터페이스를 포함할 수 있다.
- 관련된 클래스 끼리 그루핑 함으로 인해 클래스를 효율적으로 관리할 수 있다.
- 동일한 클래스명을 가지더라도 패키지가 다르다면 공존이 가능하다.
  - 이로 인해 다른 개발자가 개발한 라이브러리와 클래스명이 충돌하는것을 막을 수 있다.
- 패키지도 다른 패키지를 포함할 수 있으며, 점 (.) 으로 구분한다.

> 클래스가 물리적으로 하나의 클래스 파일인것 처럼, 패키지는 물리적을 하나의 디렉토리 이다.


`패키지 관련 규칙`
1. 하나의 소스 파일에는 첫 문장으로 **단 한번의 패키지 선언만 허용**
2. 모든 클래스는 반드시 하나의 패키지에 속해야 함
3. 패키지는 점 (.) 을 구분자로 사용하여 계층 구성이 가능하다.
4. 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디레토리

> kotlin 의 경우 실제 파일의 위치와 패키지 명을 다르게 지정할 수 있지만, 일반적으로 동일하게 해주는것을 권고

`패키지의 선언`
- 패키지 선언문은 소스파일에 주석, 공백을 제외한 첫 번째 라인에 위치해야 한다.
- 하나의 소스파일에 한번만 선언을 허용한다.
- **대소문자를 모두 허용하지만 클래스명과 구분하기 위해 소문자로 사용 하는것을 원칙** 으로 한다.
- 패키지를 선언하지 않고도 클래스 작성이 가능한데, 이는 자바에서 제공하는 **이름 없는 패키지 (unnamed package)** 때문이다.

```java
package 패키지명;
```

`import 문`
- 소스코드 작성시 다른 패키지의 클래스를 사용하기 위한 방식
- 컴파일러에게 소스파일에 사용된 클래스의 패키지 정보를 제공하는 것

> import 문 자체는 프로그램 성능에 영향을 미치지않는다. <br/>
> 컴파일 타임에 영향을 준다.

`import 문의 선언`
- import 문은 package 선언문 과 클래스 선언문 사이에 위치해야 하낟.
- 또한 동일한 소스파일에 여러번 선언할 수 있다.

```java
import 패키지명.클래스명;
import 패키지명.*;
```

> 와일드카드 (*) 임포트 사용은 되도록 지양해야 한다. <br/>
> 만약 클래스명이 중복되는 경우 로컬 네임스페이스를 혼란스럽게 한다.

`static import 문`
- static import 문은 static 멤버 호출시 클래스 명을 생략할 수 있다.
- 특정 클래스의 static 멤버 호출시 편리하고, 코드가 간결해진다.

```java
import static java.lang.Integer.*
```

## 제어자 (modifier)

`제어자 란?`
- 클래스, 변수 혹은 메소드의 선부에 함께 사용되어 부가적인 의미를 부여한다.
- 제어자는 **접근 제어자** 와 그외의 제어자로 나눌 수 있다.
- 접근 제어자
  - 한번에 대상에 대해 하나의 제어자만 사용 가능
  - public, protected, default, private
- 그 외
  - 클래스나 멤버변수 메소드에 주로 사용된다. 
  - static, final, abstract, native, transient, synchronized, volatile, strictfp

`static`
- 클래스 혹은 공통적인 의미를 담고 있다.
- 멤버변수, 메소드, 초기화 블록에 사용이 가능하다.

<table>
    <tr>
        <th>제어자</th>
        <th>대상</th>
        <th>의미</th>
    </tr>
    <tr>
        <td rowspan="3">static</td>
    </tr>
    <tr>
        <td>멤버변수</td>
        <td>모든 인스턴스에 공통적으로 사용되는 클래스변수가 됨 <br/> 클래스변수는 인스턴스르 생성하지 않고도 사용 가능하다. <br/> 클래스가 메모리에 로드될 때 생성된다.</td>
    </tr>    
    <tr>
        <td>메소드</td>
        <td>인스턴스를 생성하지 않고 호출 가능한 static 메소드가 됨 <br/> static 메소드 내에는 인스턴스 멤버들을 직접 사용할 수 없다. </td>
    </tr>
</table>


`final`
- 마지막의, 변경될 수 없는 의미를 가지고 있다.
- 거의 모든 대상에 사용이 가능하다.

<table>
    <tr>
        <th>제어자</th>
        <th>대상</th>
        <th>의미</th>
    </tr>
    <tr>
        <td rowspan="5">final</td>
    </tr>
    <tr>
        <td>클래스</td>
        <td>변경, 확장할 수 없는 클래스가 됨. 다른 클래스의 조상이 될 수 없다.</td>
    </tr>    
    <tr>
        <td>메소드</td>
        <td>변경, 될 수 없는 메소드가 됨. 오버라이딩 할 수 없다.</td>
    </tr>
    <tr>
        <td>지역변수</td>
        <td rowspan="2">변경 할 수 없는 상수가 된다.</td>
    </tr>
    <tr>
        <td>멤버변수</td>
    </tr>
</table>

- final 키워드가 붙은 변수는 상수이기 때문에 선언 및 초기화를 하지 않아도 **인스턴스 변수인 경우 생성자에서 초기화** 가 가능하다.

> 코틀린은 기본적으로 모든것이 final 이다.

`abstract`
- 미완성의 의미를 가지고 있다.
- 클래스, 메소드에 사용이 가능하다.
- 메소드 선언만 작성하고 실제 구현부는 존재하지 않는 추상 메소드 선언시 주로 사용한다.

<table>
    <tr>
        <th>제어자</th>
        <th>대상</th>
        <th>의미</th>
    </tr>
    <tr>
        <td rowspan="3">abstract</td>
    </tr>
    <tr>
        <td>클래스</td>
        <td>클래스 내에 추상메소드가 선언되어 있음을 명시</td>
    </tr>    
    <tr>
        <td>메소드</td>
        <td>선언부만 존재하고 구현이 존재하지 않는 추상 메소드 선언시 사용</td>
    </tr>
</table>

`접근 제어자 (access modifier)`
- 접근 제어자는 클래스에 사용되며, 해당 멤버 혹은 클래스를 외부에서 접근 하지 하도록 제한하는 역할을 수행한다.
- 기본 접근 제어자는 default 이며, 접근 제어자가 명시되어 있지 않다면 default 접근 제어자이다.
- 클래스, 멤버변수, 메소드, 생성자에 사용할 수 있다.
- public > protected > default > private 순으로 접근 레벨이 높아진다.

| 제어자 | 설명 |
| --- | --- | 
| public | 모두 접근 가능 |
| protected | 같은 패키지, 다른 패키지의 자손 클래스에서 접근 가능 |
| default | 같은 패키지에서만 접근 가능 |
| private | 같은 클래스 내에서만 접근 가능 |

`접근 제어자를 이용한 캡슐화`
- 접근 제어자를 사용하는 주 목적은 클래스 내부의 데이터를 보호하기 위함
- 이는 객체지향의 개념 중 하나인 **캡슐화 (encapsulation)** 에 해당한다.

> 관습처럼 private 필드를 선언하고, getter setter 를 통해 접근을 허용 방식을 많이 사용한다. <br/>
> 하지만 이런 무분별한 getter setter 의 사용이 private 필드로 선언했다고 해서 캡슐화를 했다고 할 수 있을까 ?

```java
class Product {
	private Long id;
	private String name;

	public Long getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setName(String name) {
		this.name = name;
	}
}
```
- 위 코드는 과연 캡슐화를 했다고 자신 있게 말할 수 있는가 ?
- 그저 getter setter 라는 메소드를 통해서 접근할 뿐 캡슐화가 되어있지 않다.

> 정말 필요한 부분에 있어서 public 한 메소드를 제공하는 것이 올바른 설계라고 생각ㅎ나다.

`접근 제어자 조합 규칙`
1. 메소드는 static 과 abstract 를 함께 사용할 수 없다.
   - static 메소드는 구현이 존재하는 (메소드 바디) 메소드에만 사용할 수 있다.
   - static 메소드는 정적 메소드 디스패치의 대상이기 때문에 추상메소드가 될 수 없다. (클래스에 종속된다.)
2. 클래스에 static 과 abstract 를 함께 사용할 수 없다.
   - 클래스에 사용되는 final 은 학장 할 수 없다는 의미
   - abstract 는 상속을 통해 확장되어야 한다는 의미인데 서로 모순된다.
3. abstract 메소드의 접근 제어자는 private 일 수 없다.
   - 접근제어자가 private 이라면 자손 클래스에서 구현할 수 없다.
4. 메소드가 private, final 이 공존할 필요가 없다.
   - private 메소드는 오버라이딩 할 수없기 때문에 둘중 하나만 사용해도 의미가 충분하다.


## 참고
- https://dbbymoon.tistory.com/9
- http://daplus.net/java-java-import-%EB%AC%B8%EC%97%90-%EC%99%80%EC%9D%BC%EB%93%9C-%EC%B9%B4%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%99%9C-%EC%A2%8B%EC%A7%80-%EC%95%8A%EC%8A%B5/
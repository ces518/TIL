# 지옥자바 스터디 - 14 람다와 스트림

## 람다식 (Lambda expression)
- 람다식은 메소드를 하나의 **식 (expression)** 으로 표현한 것이다.
- 함수를 간략하면서도 명확한 식으로 표현할 수 있다.
- 메소드를 람다식으로 표현한다면 메소드명과 반환값이 사라지기 때문에 **익명 함수** 라고도 한다.

```java
Arrays.setAll(arr, (i) -> (int)(Math.random() * 5) + 1);
```
- 기존 방식대로라면, 모든 메소드는 클래스에 포함되어야 하기 때문에 클래스를 생성하고 객체를 생성해야만 메소드 호출이 가능하다.
- 람다식을 사용하면 이 모든 과정없이 오로지 람다식 하나만으로 표현이 가능하다.
- 람다식은 메소드 매개변수로 전달도 가능하고, 메소드의 결과 및 변수처럼 다루는것도 가능해진다.


### 함수형 인터페이스
- 자바의 모든 메소드는 클래스내에 포함되어야 한다. (람다식도 예외는 아니다)
- 사실 람다식은 익명 클래스의 객체와 동등하다.

```java
interface MyInterface {
	int max(int a, int b);
}
new MyInterface() {
    int max(int a, int b) {
		return a > b ? a : b;
    }
}

(int a, int b) -> a > b ? a : b
```
- 위 처럼 MyInterface 를 구현한 익명 객체를 람다식으로 대체가 가능한 이유는 람다식도 실제로는 익명 객체이며 해당 인터페이스를 구혆나 익명 객체의 메소드와 시그니쳐가 동일하기 때문이다.
- 하나의 메소드가 선언된 인터페이스를 정의해 람다식을 다루는 것은 기존 자바의 규칙을 어기지않으면서 자연스러운 방법
- 때문에 인터페이스를 통해 람다식을 다루기로 결정되었으며, 람다식을 다루기 위한 인터페이스를 **함수형 인터페이스 (Functional Interface)** 라고 한다.

### 함수형 인터페이스 타입의 매개변수와 반환타입

```java
@FunctionalInterface
interface MyFunction {
	void myMethod();
}
```
- 메소드 매개변수가 MyFunction 과 같은 함수형 인터페이스 타입이라면, 메소드 호출시 람다식을 참조하는 참조변수를 매개변수로 지정해야 한다.

```java
void aMethod(MyFunction f) {
    f.myMethod();
}

MyFunction f = () -> System.out.println();
aMethod(f);

// 또는 다음과 같이사용
aMethod(() -> System.out.println());
```
- 람다식을 참조변수로 다룰수 있기 때문에 변수와 동일하게 메소드간에 주고받는것이 가능해진다.

> 사실상 메소드가 아닌 객체를 주고받게 되는것이기 때문에 근본적으로 달라진 것은 없다.

### 람다식의 타입과 형변환
- 함수형 인터페이스로 람다식을 참조할 수 있지만 **람다식의 타입이 함수형 인터페이스 타입과 일치하는 것은 아니다.**
- 정확히는 타입은 있지만 컴파일러가 임의로 이름을 지정하기 때문에 알 수 없다.
- 대입 연산자의 양변의 타입을 일치시키기위해 형변환이 필요하다.

```text
MyFunction f = (MyFunction) (() -> {});
```
- 람다식은 함수형 인터페이스를 직접 구현하진 않았지만 이를 구현한 객체와 동일하기 때문에 위와같은 형변환을 허용하며, 생략이 가능하다.
- 하지만 주의할 것은 **Object 타입** 으로 형변환은 허용하지 않는다.
- 오로지 함수형 인터페이스로만 형변환이 가능하다.
- 만약 Object 타입으로 변환을 해야한다면 함수형 인터페이스로 먼저 변환을 한후 Object 타입으로 변환을 시도해야 한다.

> 람다식의 타입은 {외부클래스명}$$Lambda${번호} 와 같은 형식으로 되어 있다.

### 람다 캡쳐링과 final
- 람다식에서도 외부에 선언된 변수에 접근이 가능하다.
- 람다식의 파라미터로 넘겨진 변수가 아닌 외부에 정의된 변수를 **자유 변수** 라고 하는데, 람다식에서 자유 변수를 참조하는 행위 **람다 캡쳐링** 이라고 한다.
    - 클로저라고도 하며 이는 close over 라는 의미를 가지고 있다.
  
`람다 캡쳐링의 제약조건`
- final 로 선언되어 있거나 final 처럼 동작 (effectively final) 해야 한다.
  - 값의 재할당이 일어나선 안된다.

`Kotlin 은 되는데 왜 Java 는 안될까`
- 일반적으로 inner -> outer 를 참조하는 것은 메모리 릭이 발생할 수 있다.
- java 는 익명 클래스에서 외부 변수를 참조할 때 외부 변수의 값을 생성자로 받아와 **capture** 방식으로 사용한다.
    - 따라서 메모리 릭이 발생할 수 있으며, 데이터 변경도 불가능 하다.
- kotlin 의 람다는 **static** 으로 외부 변수값에 접근하도록 구현되어 있다.
    - 따라서 메모리릭도 발생하지 않으며 외부 변수에 접근이 가능하다.

`Effective Java 저자의 말`
```
이미 익명 클래스로 할 수 있는 일을 더 쉽게 하고, 불필요하게 장황해지지 않게 하는 것이 가장 중요하다고 생각합니다. 
람다 표현식에서 변하는(mutable) 변수에 접근해 값을 덮어 쓸 수 있는 것은 좋기도 하고 나쁘기도 한것이 아니라 더 나쁜 것이라고 봅니다.
```

> 자바는 이전 익명클래스의 방식을 그대로 이어받아 람다에서도 참조는 가능하지만 변경은 불가능하도록 구현된 것이다.

### java.util.function
- java.util.function 패키지에는 일반적으로 자주 사용되는 형식의 메소드를 **함수형 인터페이스**로 정의해 두었다.
- 가능하면 해당 패키지의 인터페이스를 활용하는 것이 좋다.
  - 재사용성 / 유지보수성 측면에서 좋음

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| java.lang.Runnable | void run() | 매개변수 X 반환값 X |
| Supplier<T> | T get() | 매개변수 X 반환값 O |
| Consumer <T> | void accept(T t) | 매개변수 O 반환값 X |
| Function<T, R> | R apply(T t) | 매개변수 O 반환값 O |
| Predicate<T> | boolean test(T t) | 매개변수 O 논리값 반환 |

`Predicate<T>`
- 반환값이 boolean 이며 조건식을 람다로 표현할때 사용 한다.

```java
Predicate<String> isEmptyStr = s -> s.length() == 0;

if (isEmptyStr.test("A")) {
	
}
```

`매개변수가 두 개인 함수형 인터페이스`
- 매개변수가 두개인 함수형 인터페이스는 접수가 *Bi* 가 붙는다.

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| BiConsumer <T, U> | void accept(T t, U u) | 매개변수 O 반환값 X |
| BiFunction<T, U, R> | R apply(T t, U u) | 매개변수 O 반환값 O |
| BiPredicate<T, U> | boolean test(T t, U u) | 매개변수 O 논리값 반환 |

> Supplier 의 경우 반환값만 존재하는데 메소드는 하나의 값만 반환할 수 있기 때문에 BiSupplier 가 존재하지 않는것이다. <br/>
> 만약 2개 이상의 매개변수를 갖는 함수형 인터페이스가 필요하다면, 다음과 같이 직접 선언해서 사용해야 한다.

```java
@FunctionalInterface
interface TriFunction<T, U, V, R> {
	R apply(T t, U u, V v);
}
```

`UnaryOperator 와 BinaryOperator`
- Function 의 변형으로 매개변수와 반환타입이 모두 일치하는 점만 제외하고 Function 과 동일하다

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| UnaryOperator<T> | T apply(T t) | 매개변수와 결과 타입이 동일 |
| BinaryOperator<T> | T apply(T t, T t) | 매개변수와 결과 타입이 동일 |

`컬렉션 프레임워크와 함수형 인터페이스`
- 컬렉션 프레임워크의 인터페이스에는 다수의 디폴트 메소드가 추가되었다.
- 그중 일부는 함수형 인터페이스이며 다음과 같다.

| 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| Collection | boolean removeIf(Predicate<E> filter) | 조건에 맞는 요소 제거 |
| List | void replaceAll(UnaryOperator<E> operator) | 모든 요소를 변환하여 대체 |
| Iterable | void forEach(Consumer<T> action) | 모든 요소에 작업 수행 |
| Map | V compute(K key, BiFunction<K, V, V> f) | 지정된 키의 값에 작업 f 를 수행 |
| Map | V computeIfAbsent(K key, Function<K, V> f) | 키가 없다면 작업 f 를 수행후 맵에 추가 |
| Map | V computeIfPresent(K key, BiFunction<K, V, V> f) | 키가 있다면 작업 f 를 수행 |
| Map | V merge(K key, V value, BiFunction<V, V, V> f) | 모든 요소에 병합작업 f 를 수행 |
| Map | void forEach(BiConsumer<K, V> action) | 모든 요소에 작업 수행 |
| Map | void replaceAll(BiFunction<K, V, V> f) | 모든 요소에 치환작업 f 를 수행 |

`기본형을 사용하는 함수형 인터페이스`
- 지금까지 살펴본 함수형 인터페이스는 모두 제네릭 타입을 사용한다
  - 기본형 타입을 처리하려면 래퍼타입을 사용해야함
- 때문에 보다 효율적으로 처리가능한 기본형을 사용하는 함수형 인터페이스도 제공된다.
  - 오토박싱/언박싱 과정이 사라진다.    

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| DoubleIntFunction | int applyAsInt(double d) | **A**to**B**Function 은 A 입력을 B 로 출력한다 |
| ToIntFunction<T> | int applyAsInt(T value) | To**B**Function 은 출력이 B이다 |
| IntFunction<R> | R apply(T, U u) | **A**Function 은 A 입력을 제네릭으로 출력한다 |
| ObjIntConsumer<T> | void accept(T t, U u) | Obj**A**Function 은 입력이 T, A 이고 출력은 없다 | 

### Function 합성과 Predicate 결합
- java.util.function 패키지의 함수형 인터페이스에는 디폴트 메소드와 static 메소드들이 추가로 정의되어 있다.
- 합성 및 결합을 제공하는 메소드들이다.

```java
interface Function<T, R> {
	
	default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
		Objects.requireNonNull(before);
		return (V v) -> apply(before.apply(v));
	}
	
	default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
		Objects.requireNonNull(after);
		return (T t) -> after.apply(apply(t));
	}
	
	static <T> Function<T, T> identity() {
		return t -> t;
	}
}

interface Predicate<T> {
	
	default Predicate<T> and(Predicate<? super T> other) {
		Objects.requireNonNull(other);
		return (t) -> test(t) && other.test(t);
	}

	default Predicate<T> negate() {
		return (t) -> !test(t);
	}

	default Predicate<T> or(Predicate<? super T> other) {
		Objects.requireNonNull(other);
		return (t) -> test(t) || other.test(t);
	}

	static <T> Predicate<T> isEqual(Object targetRef) {
		return (null == targetRef)
			? Objects::isNull
			: object -> targetRef.equals(object);
	}

	@SuppressWarnings("unchecked")
	static <T> Predicate<T> not(Predicate<? super T> target) {
		Objects.requireNonNull(target);
		return (Predicate<T>)target.negate();
	}
}
```

`Function 합성`
- 두 람다식을 합성해 새로운 람담식을 만들 수 있다.
- 함수 f, g 가 있을때 f.andThen(g) 는 f 를 먼저 적용한 뒤 g 를 적용한다.
- f.compose(g) 는 g 를 먼저 적용한 뒤 f 를 적용하게 된다.

`Predicate 결합`
- 여러 조건식을 논리연산자로 연결하는 것 처럼 하나의 새로운 predicate 로 결합이 가능하다.
- static 메소드인 isEqual() 은 두 대상을 비교하는 Predicate 를 만들때 사용한다.

```java
Predicate<String> p = Predicate.isEqual(string1);
boolean result = p.test(string2);
```
- string1 과 string2 가 동일한지 비교하여 결과를 반환하는 Predicate

### 메소드 참조
- 람다식을 보다 간결하게 표현가능한 방법
- 람다식이 하나의 메소드만 호출하는 경우 메소드 참조 라는 방법으로 람다식을 간결하게 사용할 수 있다.
- 생성자의 경우도 동일하게 사용할 수 있다.

```java
BiFunction<String, String, Boolean> f = String::equals;
Supplier<MyClass> s = MyClass::new;
```

## 참고
- https://softwareengineering.stackexchange.com/questions/277473/is-there-a-performance-benefit-to-using-the-method-reference-syntax-instead-of-l
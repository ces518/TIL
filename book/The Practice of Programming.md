# The Practice of Programming

## 1. 스타일
- 스타일의 목적은 읽기 좋은 코드를 만드는 것이다.
- 좋은 스타일은 좋은 프로그래밍에 결정적인 역할을 한다.
- 예전에 비해 최근의 프로그래밍을 잘한다는 기준은 많이 변화되었다.
- 이전에는 복잡하고 남들이 알아보기 힘들게 만들수록 잘한다 라는 느낌을 받았지만 요즘은 그렇지 않다.
- 읽기 쉬운 코드, 알아보기 쉬운 코드를 짜는 것이 프로그래밍을 잘한다의 기준이 되었다.

### 1-1. 네이밍
- 변수나 함수의 이름은 각 객체들을 구분 짓고 목적에 관한 정보를 전달한다.
- 이는 정보 면에서 유익함과 동시에 간결해야 하며 기억하기 쉬워야 한다.
- 문맥과 유효범위 (scope) 에서 많은 정보를 얻을 수 있고, 유효범위가 높을수록 이름은 더 많은 정보를 전달해야 한다.

`전역변수는 서술적인 이름을, 지역변수는 간결한 이름을 사용하라`
- **전역 변수** 는 유효범위가 크기 때문에 어디서든 사용될 여지가 있다.
- 가능하다면 해당 의미를 서술적으로 전달하는 것이 좋다.
- 필요에 따라 간단한 주석을 달아주는 것도 좋다.
- **지역 변수** 는 짧은 이름을 써도 충분하다.
- 관례로 많이 사용하는 경우에는 축약어를 사용해 주어도 좋다.
- 하지만 지나치게 축약어를 남용하는 경우에는 오히려 역효과를 부른다.

> 명명규칙과 지역적 관례는 다양하다.
> 
> 명명규칙을 준수하면 본인의 코드 또는 다른 사람의 코드도 쉽게 이해할 수 있다.

`일관성을 지켜라`
- 서로 관련이 있는 것들에는 연관된 이름을 붙여 상관관계를 보여줌과 동시에 차이점이 눈에 띄도록 해야한다.

```java
class UserQueue {
    int noOfItemInQ;
    int frontOfTheQueue;
    int queueCapacity;
    // ...
}
```
- 위와 같은 코드의 경우 queue 라는 이름이 불필요하게 중복되고 있다.
- 해당 지역변수는 userQueue 인스턴스를 통해서만 접근이 가능한데, 만약 사용한다면 다음과 같을 것이다.

```java
queue.queueCapacity;

// 개선된 버전
queue.capacity;
```

> 추가적으로 1명이 작성한 코드인데 파일마다 작성하는 방식이 다르다거나, 심한경우 각 함수마다 스타일이 전혀 다른 경우가 있다.
> 
> 이는 코드를 읽는 이로 하여금 혼란을 줄 수 있다.

`함수 명은 능동형을 사용하라`
- 함수 명에는 **능동형 동사** 를 써야하며 명사가 따라올 수 있다.
- 예를 들어 특정 조건을 만족하는지 확인한 후 논리값을 반환하는 함수의 경우 check~~ 보단 is~~~ 로 명확하게 논리값을 반환함을 알려주는 것이 좋다.

`정확한 이름을 사용하라`
- 잘못된 이름을 사용한다면 코드를 보는사람에게 잘못된 정보를 전달할뿐 아니라 예상치 못한 버그를 만들 수 있다.
- 함수의 이름과 동작이 일치해야한다.

### 1-2. 표현식과 문장
- 표현식과 문장도 의미를 최대한 드러내야 한다.
- 제대로 동작하는 가장 명료한 코드를 작성하라.
- 연산 단위가 눈에 잘 띄도록 연산자 주변에는 공백을 주어야 한다.

`들여쓰기로 구조를 알아보기 쉽게 하라`
- 일관성 있는 들여쓰기로 알아보기 쉽게 해야한다.
- IDE 에서 들여쓰기는 일반적으로 4 space(1 tab) 를 많이 사용한다.

`표현식을 자연스럽게 사용하라`
- 표현식을 말하는것 처럼 자연스럽게 사용해야 한다.
- 부정을 포함하는 조건식은 이해하기 힘들게 만든다.
- 가능하다면 부정문을 제거하라

`괄호를 사용해 애매함을 해소하라`
- 괄호는 연산에서 의미 단위를 명확하게 해준다.
- 의도를 분명히 하게 위해 사용해주면 도움이 된다.
- 연산자 우선순위와 상관없이 가독성을 위해 필요하다면 괄호를 사용하라.

`복잡한 표현을 잘게 쪼개라`
- C, C++, 자바는 표현식을 사용하는 문법과 연산자가 많아 한 문장안에 지나치게 많은 것을 집어넣는 일이 많다.
- 코드라인 줄이는것이 중요한게 아니다.
- 오히려 짧은 코드가 가독성을 해친다면 여러줄로 쪼개어야 한다.

`명료하게 사용하라`
- 간결하고 멋진 코드를 작성하는게 중요한게 아니다. **명료한 코드**를 사용하는 것이다.
- 명료성과 간결성을 동일하지 않다.
- 명료한 코드는 대게 짧은 편이지만, 조건식을 if-else 문을 사용해 풀어 쓰는 것 처럼 오히려 긴 코드가 명료한 경우도 존재한다.

> 코드 라인 수가 아닌 얼마나 이해하기 쉬운지가 기준이 되어야 한다.

`부수효과를 조심하라`
- ++ 와 같은 연산자는 값을 반환하는것 외에도 변수값 자체를 바꾸는 부수효과가 있다.
- 이런 부수효과는 편리하지만 예상치못한 문제를 일으킬 수 있다.
- 해결책은 대개 그렇듯이 코드를 여러 라인으로 쪼개는 것이다.

### 1-3. 일관성과 관용 표현
- 일관성을 유지하는 것은 좋은 프로그램을 만드는 길이다.
- 코드 스타일이 예측할 수 없이 달라지는 경우 동작하기 알아보기 힘들다.

`들여쓰기와 중괄호를 사용하는 스타일은 일관성을 지켜라`
- 들여쓰기와 중고라호는 구조를 쉽게 알 수 있게 한다.
- 중괄호를 꼭 쓸 필요없을 때도 사용 해야할까 ?
    - 이부분은 논쟁이 많다.
    - 가능하다면 중괄호는 반드시 써주는게 일관적이다.

> 본인이 작성하지 않은 코드를 수정할 때는 기존 코드 스타일을 유지하는 것이 좋다. \n
> 코드 수정시 자신의 스타일을 사용하지 않는 것이 좋다. \n
> 코드의 일관성은 개발자 본인의 스타일 보다 더 중요하다.

`일관성을 위해 관용 표현을 사용하라`
- 프로그래밍언어도 관용 표현과 일반적으로 사용하는 상용 표현들이 있다.
- 어떤 언어를 배우더라도 핵심은 이런 관용적인 표현에 익숙해지는 것이다.

`다중결정이 필요한 경우 else-if 를 사용하라`
- 다중 결정이 필요한 경우 보통 if-else if-else 를 엮어 사용한다.
- 중첩된 if 문은 오히려 가독성을 떨어뜨린다.

> 코드를 재활용 하려고 하다 보면 지나치게 꽉 짜인 프로그램이 될 수 있다.

### 1-4. 매크로 함수를 멀리하라.

### 1-5. 매직 넘버
- 매직 넘버란 프로그램 넹서 쓰이는 상수, 배열의 크기 등 여러 특정한 리터럴 값들을 말한다.

`매직 넘버에 이름을 달아라`
- 소스코드에서 0, 1 과 같은 숫자들은 어떤 것을 의미하는지 작성자 외에는 알기 힘들다.
- 각 값들이 어떤 의미를 갖는지 이름을 달아 주어야 한다.

`숫자는 상수로 정의하라`
- C 개발자들은 보통 매직넘버 값을 관리하기 위해 #define 을 사용했다.
- 이런 숫자값들은 const 또는 enum 을 이용한 상수를 선언하라.

`아스키 문자는 숫자 코드 말고 문자 상수로 사용하라`
- 아스키 코드는 숫자 혹은 문자로 사용할 수 있는데, 65 라는 값보다는 'A' 라는 값이 이해하기 더 쉽다.
- 가장 좋은 방법은 표준 라이브러리를 사용하는 것이다.

`언어에서 제공하는 함수를 이용해 객체의 크기를 계산하라`
- 어떤 자료에도 크기를 명시적인 숫자로 사용하지 말고 언어에서 제공하는 함수를 이용해야 한다.
- 자바의 length, size 와 같은 함수가 이런 예이다.
- 이런 객체의 크기도 명시적인 숫자로 사용한다면 매직넘버이다.

### 1-6. 주석
- 주석이 코드만으로 충분히 설명된 것을 반복해서 얘기하거나, 코드 내용과 모순되는 경우 도움이 되지 않는다.
- 좋은 주석은 핵심적인 세부 사항을 간결하게 지적해 이해를 도와야 한다.

`명확한 코드에는 주석을 달지 말라`
- 이런 주석은 모두 삭제해야 한다.
- 잘 지은 변수명과 같이 이미 충분한 정보를 전달하는 경우 의미가 없다.

`함수와 전역 데이터에 주석을 달아라`
- 주석은 유용한 경우가 많다.
- 함수, 정겨변수, 상수 와같이 짤막한 설명이 도움을 주는 곳이라면 어디든 주석을 붙인다.
- 주석이 전역변수에 사용된다면 필요한 경우 역할을 상기시켜줄 수 있다.

`나쁜코드에 대해 설명하지 말고 코드를 새로 짜라`
- 유별난 코드나 헷갈릴수 있는 코드에는 주석을 달아야 한다.
- 하지만 주석이 코드보다 긴 경우 코드를 고칠 필요야 있다는 생각을 해야 한다.

`주석과 코드가 모순되게 하지 말라`
- 대부분의 주석은 코드 작성 당시에는 제대로 맞지만, 프로그램이 변화하며, 주석이 그대로라면 코드와 맞지 않게 된다.
- 불일치 이유가 무엇이든, 주석이 코드와 맞지 않는다면 혼란 스럽고 디버깅이 오래 걸리게 된다.
- 코드를 변경하면 반드시 주석이 정확한지 확인해야 한다.

> 주석은 코드에 일치하는 것이 아닌 코드를 보충하는 것이 되어야 한다.

`혼란스럽게 하지 말고, 명확하게 하라`
- 주석은 도움을 주려고 하는것이 목적이지 방해하는 것이 아니다.
- 코드만으로 이해를 할수 있게, 즉 주석이 필요 없는 코드를 짜는것이 1차적인 목표이다.
- 좋은 코드는 나쁜 코드보다 주석이 적게 필요하다.

### 1-7. 왜 그렇게 귀찮게 구는가 ?
- 잘 짠 코드는 대충 던져놓고 한 번도 정리하지 않은 코드보다 읽기 쉽고 문제도 없다.
- 지저분한 코드는 나쁜 코드다. 읽기 힘든것뿐만이 아닌 잘 망가진다.
- 좋은 스타일이 습관이 되어야 한다.

## 2. 알고리즘과 데이터 구조
- 모든 프로그램은 알고리즘과 데이터 구조에 의지하지만, 새로운 알고리즘이나 데이터 구조를 발명해서 써야하는 일은 매우 드물다.
- 컴파일러 / 웹 브라우저등 과 같은 경우에도 내부 데이터 구조는 대부분 배열, 리스트, 트리, 해시 테이블을 사용한다.
- 대다수의 개발자들이 할일은 어떤 알고리즘과 어떤 데이터 구조를 사용할지 이를 파악하고 여러 대안중 하나를 선택하는 방법을 이해하는 것이다.

### 2-1. 검색
- 정적 테이블 형태의 데이터를 저장하는 데는 배열이 최선의 선택이다.
- 컴파일 시점에 초기화 되므로 비용도 적게 든다. (자바의 경우 실행 시점에 초기화)

`순차 검색 (sequential search)`
- 가장 단순한 검색 알고리즘
- 원하는 원소가 나올 떄 까지 모든 원소를 순차적으로 찾는 방식
- 데이터 개수가 적을 경우 순차 검색의 속도는 빠르다.
- 데이터 전체의 크기와 작업량이 정비레 한다는 단점이 있다.

> 실행 시간과 데이터 크기가 일차 함수 관계기 때문에 이를 선형 관계 라고 도 부르며, 선형 검색이라고 부르기도 한다.

`이진 탐색 (binary search)`
- 우리가 사전에서 단어를 찾아보는 방법을 규칙적으로 만들어놓은 방식
- 배열의 가운데 원소를 찾고, 해당 값의 크고 작음에 따라 검색 범위를 절반씩 줄여 나가는 것이다.
- 이러한 방식 때문에 **이진 탐색** 라고 부른다.
- 이진 탐색의 경우 배열이 **반드시 정렬** 되어 있어야 한다.

> 이진 탐색은 매 단계마다 검색 범위를 절반씩 줄여나가기 때문에 소수 이하를 무시한다면 log2n 이다. \n
> 선형 검색이 천번을 검색해야 한다면 이진 탐색은 10번이면 충분하다.

### 2-2. 정렬

`퀵 정렬`
- 1960년 C. A. R 호어가 고안해낸 정렬 알고리즘
- 어떤 상황에서 무난한 최고의 정렬 알고리즘 중 하나
- 이는 불필요한 계싼을 피하는 방법을 제시하는 좋은 예 이기도 하다.
- 배열의 모든 원소를 기준 값보다 작거나 큰 부분으로 나누는 방식으로 동작한다.
  - 배열 원소중 기준 (pivot) 을 선택
  - 다른 원소들을 두 집단으로 분할
    - 기준 보다 작은 값
    - 기준 보다 큰 값
  - 각 집단을 이런식으로 반복하여 정렬한다.

> 퀵 정렬이 빠른 이유는 pivot 보다 작다고 판단되면 해당 원소를 기준 값 보다 큰 원소들과 비교하지 않아도 되기 때문
> 일반 적으로 nlogn 에 비례한다.
> 하지만 퀵 정렬이 모든 경우에 최선인 경우는 아니다. \n
> 만약 데이터 분포가 일정하지않아 균등한 분할이 되지 않는다면 최악의 경우 n2 에 가까워 진다.

### 2-3. 라이브러리
- 라이브러리 루틴은 어떤 데이터 타입도 정렬할 수 있게 만들어 져 있지만 우리가 그 루틴의 인터페이스에 적응 해야 한다.

### 2-4. 자바의 퀵 정렬
- 자바의 초기 에는 표준 정렬 함수가 없어 직접 정렬 을 구현해야 했다.
- 비교적 최근에는 Comparable 인터페이스를 구현하는 클래스를 대상으로 sort 함수를 제공된다.

```java
interface Cmp {
    int cmp(Object x, Object y);
}

class Icmp implements Cmp {
    
    @Override
    public int cmp(Object o1, Object o2) {
      int i1 = ((Integer) o1).intValue();
      int i2 = ((Integer) o2).intValue();
      if (i1 < i2) {
          return -1;
      } else if (i1 == i2) {
          return 0;
      } else {
          return 1;
      }
    }
}

class QuickSort {
    static Random random = new Random();
    
    static void sort(Object[] v, int left, int right, Cmp cmp) {
        int i;
        int last;
        
        if (left >= right) { // 할일 없음 종료
            return;
        }
        swap(v, left, rand(left, right)); // 기준 원소를 v[left] 로 이동
        last = left;
        for (i = left + 1; i <= right; i++) { // 분할
            if (cmp.cmp(v[i], v[left]) < 0) {
                swap(v, ++last, i);
            }
        }
        swap(v, left, last); // 기준 복원
        sort(v, left, last - 1, cmp); // 각 부분을 재귀적으로 정렬
        sort(v, last + 1, right, cmp);
    }
    
    static void swap(Object[] v, int i, int j) {
        Object temp;
        temp = v[i];
        v[i] = v[j];
        v[j] = temp;
    }
    
    static int rand(int left, int right) {
        // 자바 난수 생성기는 음수도 생성하기 때문에 Math.abs 로 절대값을 생성한다.
        return left + Math.abs(rgen.nextInt()) % (right - left + 1);
    }
}
```

### 2-5. 빅오 표기법
- 어떤 특정 알고리즘이 수행하는 작업량을 좀 더 정확하게 표현하면서 하드웨어 혹은 그 외적인 요소들을 제외한 표현이 필요한 경우가 많다.
- 그 결과 탄생 한것이 빅오 표기법 이다.
- 기본 인자는 n (문제 인스턴스의 크기)
- 알고리즘의 복잡도나 실행시간은 n의 함수로 표현된다.

| 표기법 | 이름 | 예 |
| --- | --- | --- |
| O(1) | 상수 | 배열을 인덱스로 참조 |
| O(logn) | 로그 | 이진 탐색 |
| O(n) | 선형 | 문자열 비교 |
| O(nlogn) | nlogn | 퀵정렬 |
| O(n2) | 제곱 | 단순한 정렬 방법들 |
| O(n3) | 세제곱 | 행렬 곱셈 |
| O(2n) | 지수 | 집합 분할 |

> 여행하는 영업사원 문제 와 같이 지수알고리즘만으로 해결 가능한 문제들이 매우 많다. \n
> 이런 경우 해답의 근사치를 찾아내는 알고리즘으로 대체하는 경우가 많다.

### 2-6. 크기가 커지는 배열들
- 만약 배열에 들어갈 단어나 HTML 글자 테이블이 런타임 시점에 변경된다면 해시 테이블이 더 적절한 데이터 구조일 것이다.
- 정렬된 배열에 원소를 넣을때마다 배열의 크기가 커지는 연산은 O(n2) 연산이다.

### 2-7. 리스트
- 배열 다음으로 자주 사용되는 자료구조이다.
- 리스트 타입을 언어 레벨에서 제공하는 언어도 많고, Lisp 같은 언어들은 아에 언어 자체가 리스트 기반인 경우도 있다.

`단일 연결 리스트`
- 단일 연결 리스트는 각 데이터와 다음 노드를 가리키는 포인터를 가지는 아이템들의 집합이다.
- 리스트의 헤드는 첫 번째 노드를 가리키는 포인터 이고, 리스트의 마지막은 null 포인터로 표시한다.

> 배열과 리스트의 가장 큰 차이점은 배열은 크기가 고정되어 있지만, 리스트는 필요한 만큼만 메모리 공간을 사용한다는 점이다. \n
> 또 한가지는 배열은 메모리를 블록 단위로 옮겨야 하지만, 리스트는 포인터 몇 개만 바꾸면 순서 변경이 가능해 진다.

- 변경이 자주 일어나고, 임의 접근 방식도 필요하다면 트리 혹은 해시 테이블을 사용하는 것이 좋다.

### 2-8. 트리
- 트리는 노드 마다 어떤 값을 가지고 있고, 0 혹은 그 이상의 다른 아이템을 가진 계층형 데이터 구조이다.
- 트리의 루트는 조금 특별한데, 루트를 가리키는 노드는 없다.
- 트리는 종류가 여러가지가 있다.
- 문장 혹은 프로그램의 문법을 담아내는 **파스 트리 (parse tree)**, 족보 등도 트리로 표현이 가능하다.

`이진 검색 트리 (binary search tree)`
- 이진 검색 트리는 노드 마다 두 링크를 가진다.
- 또한 만들기도 쉽고, 트리의 중요한 특징을 모두 가지고 있다.
- 노드는 값 하나와 자식을 가지는 두개의 포인터를 가진다.
- 노드의 자식이 두개보다 적을 경우 포인터가 널 일 수 있다.
- 이진 검색 트리는 노드가 가진 값이 트리의 모양을 결정한다.
- 노드의 왼쪽에 있는 모든 자식은 해당 노드보다 값이 적어야 하며 오른쪽은 반대로 값이 커야 한다.

> 이러한 특성 때문에 리스트나 배열에서 O(n) 연산들이 트리에서는 O(logn) 만큼 걸린다.

루트 부터 모든 리프 노드 까지 길이가 거의 비슷한 트리를 **균형 트리 (balanced tree)** 라고도 한다.

> 트리의 균형을 보장해주는 트리를 만드는 것은 어렵기 때문에 트리의 종류가 많은 것이다.

`트리를 순회하는 방법`
- 중위 순회법
  - 왼쪽 하위 트리를 방문 한 뒤 해당 노드에 대한 연산을 수행한 뒤 오른쪽 하위 트리를 방문하는 방식
- 후위 순회법
  - 자식들을 모두 방문한 뒤 현재 노드에 대한 연산을 수행하는 방식
- 전위 순회법
  - 거의 사용되지 않음..

### 2-9 해시 테이블
- 해시 테이블은 컴퓨터 과학의 위대한 발명품 중 하나이다.
- 배열, 리스트, 수학 지식을 합쳐 만들었으며 동적인 데이터를 저장 / 넣고 빼기에 효과적인 데이터 구조
- 일반적으로 심벌 테이블을 관리할때 사용한다.
- 심벌 테이블은 동적인 키와 어떤 값을 연결해둔 테이블이다.
- 해시 테이블의 핵심은 **해시 함수** 를 사용해 적절하게 균등하게 분포되는 해시 값를 만드는 것이다.
  - 이는 결정적(deterministic) 이어야 하고, 빠르고 균일하게 분산되어야 한다.

### 2-10. 정리
- 알고리즘을 선택할 때는 여러단계를 거쳐야 한다.
- 알고리즘과 데이터 구조들을 평가 한뒤 처리해야할 데이터 양이 얼마나 많을지 예측해야 한다.
- 데이터양이 크지 않다면 간단한 기법을 사용하는 것이 좋다.
- 가능하다면 라이브러리 혹은 언어에서 기본적으로 제공하는 기능을 사용해야 한다.

## 3. 설계와 구현
- 프로그램을 만들 때 가장 중요한 것은 데이터 구조의 설계이다.
- 데이터 구조를 만들었다면, 알고리즘은 바로 결정이 가능하고 그에 따른 코드 작성도 비교적 쉽다.

### 3-1. 마르코프 체인 알고리즘
- 이 알고리즘은 각 어구를 여러 단어로 된 **접두사** 와 한 단어로 이뤄진 접미사로 나눈다.
- 또한 주어진 접두사에 대해 통계적 특성에 따라 선택한 접미사를 만들어 낸다.

### 3-2. 데이터 구조 후보들
- 일반적으로 책 한권 정도 분량을 입력한다면 십만 단어 이상의 입력을 처리할 수 있도록 만들어야 한다.
- 또한 초단위 수준에서 프로그램 실행이 완료되어야 한다.
- 마로코프 알고리즘은 출력을 만들기전 입력 데이터를 모두 검토하기 때문에 **전체 입력을 모두 저장** 해야 한다.
- 한 접두사와 여기에 딸린 여러 접미사를 표현할 데이터 구조가 필요하다.
  - 접두사를 **키** 로 사용하고, 접미사 목록을 **값** 으로 사용하는 해시 테이블이 필요하다.

### 3-3. C 에서 구현하기

### 3-4. 자바에서 구현하기
- 객체지향 언어를 사용할 때는 컴포넌트 사이의 인터페이스에 관심을 기울여야 한다.
- 자바는 C 보다 라이브러리가 풍부해서 여러 오브젝트들을 다양한 방법으로 관리할 **컨테이너 클래스** 들을 제공한다.
- 자바로 작성한 프로그램은 C 보다 크기가 작으며 신경쓸 부분도 적다.
- 하지만 모든것을 알아서 다 해주는것은 아니라는 것을 명심해야 한다.

### 3-5. C++

### 3-6. Awk 와 펄

### 3-7. 성능

### 3-8. 교훈
- 고수준 언어로 만들 프로그램이 저수준 언어보다 만들것 보다 느린 경향이 있다.
    - 이는 절대적인 것은 아니고 항상 그렇지도 않다.
- C++ STL 처럼 큰 컴포넌트나 스크립트 언어가 제공하는 결합 배열과 문자열 처리는 코드길이를 줄여주고 개발 시간도 단축시켜 준다.
    - 물론 성능이 떨어지는 대가를 치러야 한다.
- 단순한 알고리즘과 데이터 구조 선택이 중요하다.
- 사용할 알고리즘에 대한 지식을 토대로 데이터 구조를 상세하게 설계하는 것이 가장 좋다.

## 4. 인터페이스
- 설계의 핵심은 서로 대립하는 목표와 제약 사이에서 균형을 잡는 것이다.
- 설계 단계에서 다뤄야할 문제
  - 인터페이스
      - 서비스 제공자와 서비스 사용자 사이의 계약
      - 일관성이 있으며 편리하면서도 무겁지 않으며 쉽게 사용할 수 있어야 한다.
  - 정보 은닉
      - 각 컴포넌트에 이르는 분명한 접근 경로를 제공해야 한다.
      - 세부 구현에 대한 정보는 숨겨야 한다.
  - 자원 관리
      - 메모리 공간 할당 및 해제나 공유 정보들의 관리 문제
  - 에러 처리
      - 누가 에러를 감지하고 누가 보고할 것인가 ?

### 4-1. 콤마 구분값
- **CSV (Comma-Separated-Values)** 는 표 형식의 자료를 표현하기 위하 자연스럽게 널리 쓰이는 표현 방식을 가리키는 용어
- 각 열은 텍스트 한줄이 되며, 각 필드는 콤마로 구분한다.

### 4-2. 프로토타입 라이브러리
- 좋은 라이브러리 설계 또는 좋은 인터페이스 설계는 한번에 이뤄지지 않는다.
- 프레드 브룩스의 말을 빌리면 "한 번은 버릴 마음을 먹어라." 라는 말이 있다.
- 예전에는 오랜시간 충분한 설계를 한뒤 개발을 진행하는 방식이 전통적인 개발 방식 이었다.
- 하지만 요즘은 **애자일 (Agile)** 방법론을 따른다.
- 빠른 피드백 사이클을 통해 점진적으로 더 좋은 소프트웨어를 만든다.

### 4-3. 다른 사람이 쓸 수 있는 라이브러리
- 다른 사람이 쓸 수 있는 라이브러리를 만들려면 인터페이스, 정보 은닉, 자원 관리, 에러 처리를 고려해야 한다.

`인터페이스`
- csvgetline (csv 파일 한줄을 읽는 함수) 는 어떤 값을 리턴해야 하는가 ?
  - 필드의 개수가 될 수도 있고, 입력 줄의 길이가 될 수도 있다.
- 원 입력줄을 가리키는 포인터를 리턴하고, 파일의 끝에 다다랐을 경우에는 NULL 을 리턴한다.
- csvfield (csv 의 필드를 가져오는 함수) 가 존재하지 않는 필드를 요청할 경우 어떤 값을 리턴해야 하는가 ?
  - 빈 문자열을 리턴할 수도 있다.
  - 하지만 이경우 필드가 빈 경우인지, 존재하지 않는 필드인지 구분할 방법이 없다.
  - 에러 메세지를 출력하거나 중단 시키는 방법도 존재하지만 바람직한 방법이 아니다.
- NULL 을 리턴하기로 한다. (C 언어에서 관습적으로 사용하는 값)

`정보 은닉`
- 우리가 만든 라이브러리는 입력줄의 길이나 필드 개수에 대해 제한을 두지 않는다.
- 호출자 혹은 피호출자중 하나가 메모리를 할당해서 제공해야 한다.
- 만약 피호출자가 관리하게끔 결정했다면 오직 csvgetline 함수 만이 메모리 관리에 대해 알아야 한다.
- 이 함수가 메모리를 어떻게 사용하는지 밖에서는 간섭할 수 없다.

`자원 관리`
- 누가 공유 정보를 책임질지 정해야 한다.
- 원본 데이터를 리턴할지, 복사본을 만들지 말이다.
- 누가 입력 파일을 열고 닫을지도 정해야 한다.
- 파일을 여느놋이 어디든 열었으면 반드시 닫아야 하며, 한쌍으로 같은 작업수준, 같은 위치에서 이루어 져야 한다.
- 파일을 피호출자에서 열고 닫는것은 호출자에서 이뤄지거나 하는 이런 일이 발생해서는 안된다.

`에러 처리`
- 원칙적으로 라이브러리 루틴은 에러가 났을때 그냥 죽어버리면 안된다.
- 호출자가 적절한 동작을 취할 수 있도록 에러 상태를 리턴해야 한다.

`명세서`
- 앞에서 내린 결정을 모아 서비스 목록과 사용법을 설명한 명세서를 만들어야 한다.
- 대규모 프로젝트의 경우 명세서 작성이 궇녀보다 먼저 이루어 진다.
- 하지만 현장에서 병렬적으로 진행되고 명세서와 코드가 같이 개발된다.
- 가장 좋은 방식은 명세서를 일찍 작성한 뒤, 구현하면서 변경되는 사항들을 게속 갱신하는 것이다.
- 더 정확하고 더 신중할수록 프로그램 완성도가 높아질 가능성이 높다.

### 4-4. 인터페이스 원칙
- 인터페이스는 서비스를 제공하는 코드와 서비스를 이용하는 코드 사이의 정교한 경계선이 된다.
- 인터페이스가 널리 사용되기 위해서는 그 목표에 잘 어울려야 한다.
- 단순하고, 범용적이며 규칙적이고 결과를 예상할 수 있어야 하며 튼튼해야 하고 기능 구현부분이 바뀌면 자연스레 바뀌어야 한다.
- 좋은 인터페이스는 원칙을 따른다.

`구현의 세부 사항을 숨겨라`
- 인터페이스 뒤에 존재하는 구현된 코드는 이를 숨겨야 한다.
- 정보은닉, 캡슐화, 추상화, 모듈화 라고 불린다.
- 인터페이스는 사용자와 관련이 없는 구현에 관한 내용을 숨겨야 한다.
- **전역 변수 사용을 피해야 한다. 가능하다면 필요한 데이터는 함수 인자로 전달 받아라.**

> 어떤 형태든 데이터를 공개적으로 열어서는 안된다. \n
> 사용자가 변수를 마음대로 변경할 수 있따면 일관성있게 유지하기가 힘들어진다.

- C++ 과 자바의 클래스는 정보를 은닉하기 위해 발전된 메커니즘이자 언어의 핵심 기능이다.

`서로 겹치지 않게 기본 항목을 선택하라`
- 인터페이스는 딱 필요한 만큼의 기능만 제공해야 한다.
- 또한 지나치게 중첩되서는 안된다.
- 편의성을 위해 같은 일을 수행하는 방법을 여러개 제공하는 경우도 있는데 이는 피해야 한다.
  - C 의 표준 입출력 라이브러리는 츌력 스트림에 문자 1개를 쓰는 함수를 4개 이상 제공한다..
  
`사용자가 모르는 곳에서 일을 꾸미지 말라`
- 라이브러리 함수는 비밀 파일이나 변수를 만들어 사용한다거나 전역 데이터를 변경해서는 안된다.
- 호출자가 전달한 데이터를 수정하는 일도 피해야 한다.
- 단일 인터페이스를 사용할 때 해당 인터페이스 설계나 혹은 구현자의 편의를 위해 또다른 인터페이스를 만들어야 하는 일이 있어서는 안된다.

`어디서나 같은 일은 같은 방식으로 처리하라`
- 일관성과 규칙성은 중요하다.
- 비슷한 것들은 비슷한 수단으로 취해야 한다.
- C 언어 라이브러리의 기본적인 함수들은 문서가 없어도 사용하기 쉬운데 그 이유는 거의 모두 같은 방식으로 동작하기 때문이다.
- 외부에 대한 일관성, 즉 다른 것과 비슷하게 작동하는 일관성도 목표가 되어야 한다.

> 인터페이스를 잘 설계하는 데에도 한계는 있다. \n
> 오늘은 최고의 설계 였더라도 내일은 문제가 될 수 있다.

### 4-6. 자원 관리
- 라이브러리의 인터페이스를 설계할 때 가장 어려운 점은 라이브러리가 소유하거나 호출자와 공유하는 자원을 관리하는 문제이다.
- 이는 초기화, 상태 유지, 공유와 복사, 자원 해제의 문제로 분류할 수 있다.

`자원을 결자 해지하라`
- 자원 할당 및 해제를 제어하는 방법 중 하나는 동일한 라이브러리, 패키지, 인터페이스를 사용해서 자원을 할당한 곳에서 해제까지 책임 지게 하는 것이다.
- 어떤 자원을 할당하고 해제하는 동작이 인터페이스를 넘나들며 일어나선 안된다.

### 4-7. 중단, 재시도, 실패?
- 자신에게만 필요한 함수를 작성하는게 아니라 다른사람을 위해 라이브러리를 만든다고 생각하고 설계를 해야 한다.
- 에러 메세지를 출력하고 죽는 방법은 소규모 애플리케이션에서는 괜찮은 방법일 수도 있지만, 복구 가능성을 없애 버리기 때문에 좋은 방법이 아니다.
- 진단 내용을 담은 출력을 별도의 **로그 파일** 에 저장하라.
- 다른 프로그램에 영향을 최소화 하며 따로 열어 볼 수 있으므로 독립적인 모니터링이 가능하다.

`에러는 저수준에서 잡고, 고수준에서 처리하라`
- 일반적으로 에러는 가능하다면 **낮은 수준에서 잡고, 높은 수준에서 처리해야 한다.**
- 대부분의 경우 호출자가 에러를 어떻게 처리할지 결정한다.

`예외적 상황에서만 예외 처리를 하라`
- 몇몇 언어는 비정상적 상황을 감지하고 해당 상황을 벗어나기 위해 예외 매커니즘을 젝ㅇ한다.
- 이를 이용해 제어 흘므을 다른데로 돌릴 수 있다.
- 문제 해결을 하면서 리턴 값을 처리해야할 떄 예외를 사용해서는 안된다.
- 예외는 제어 흐름을 건들이기 떄문에 쉽게 남용될 수 있으며 버그가 발생하기 쉽게 구조가 꼬일 수 있다.

> 정말 예외적인 경우를 대비해 예외를 아껴야 한다.
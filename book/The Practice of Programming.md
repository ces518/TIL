# The Practice of Programming

## 1. 스타일
- 스타일의 목적은 읽기 좋은 코드를 만드는 것이다.
- 좋은 스타일은 좋은 프로그래밍에 결정적인 역할을 한다.
- 예전에 비해 최근의 프로그래밍을 잘한다는 기준은 많이 변화되었다.
- 이전에는 복잡하고 남들이 알아보기 힘들게 만들수록 잘한다 라는 느낌을 받았지만 요즘은 그렇지 않다.
- 읽기 쉬운 코드, 알아보기 쉬운 코드를 짜는 것이 프로그래밍을 잘한다의 기준이 되었다.

### 1-1. 네이밍
- 변수나 함수의 이름은 각 객체들을 구분 짓고 목적에 관한 정보를 전달한다.
- 이는 정보 면에서 유익함과 동시에 간결해야 하며 기억하기 쉬워야 한다.
- 문맥과 유효범위 (scope) 에서 많은 정보를 얻을 수 있고, 유효범위가 높을수록 이름은 더 많은 정보를 전달해야 한다.

`전역변수는 서술적인 이름을, 지역변수는 간결한 이름을 사용하라`
- **전역 변수** 는 유효범위가 크기 때문에 어디서든 사용될 여지가 있다.
- 가능하다면 해당 의미를 서술적으로 전달하는 것이 좋다.
- 필요에 따라 간단한 주석을 달아주는 것도 좋다.
- **지역 변수** 는 짧은 이름을 써도 충분하다.
- 관례로 많이 사용하는 경우에는 축약어를 사용해 주어도 좋다.
- 하지만 지나치게 축약어를 남용하는 경우에는 오히려 역효과를 부른다.

> 명명규칙과 지역적 관례는 다양하다.
> 
> 명명규칙을 준수하면 본인의 코드 또는 다른 사람의 코드도 쉽게 이해할 수 있다.

`일관성을 지켜라`
- 서로 관련이 있는 것들에는 연관된 이름을 붙여 상관관계를 보여줌과 동시에 차이점이 눈에 띄도록 해야한다.

```java
class UserQueue {
    int noOfItemInQ;
    int frontOfTheQueue;
    int queueCapacity;
    // ...
}
```
- 위와 같은 코드의 경우 queue 라는 이름이 불필요하게 중복되고 있다.
- 해당 지역변수는 userQueue 인스턴스를 통해서만 접근이 가능한데, 만약 사용한다면 다음과 같을 것이다.

```java
queue.queueCapacity;

// 개선된 버전
queue.capacity;
```

> 추가적으로 1명이 작성한 코드인데 파일마다 작성하는 방식이 다르다거나, 심한경우 각 함수마다 스타일이 전혀 다른 경우가 있다.
> 
> 이는 코드를 읽는 이로 하여금 혼란을 줄 수 있다.

`함수 명은 능동형을 사용하라`
- 함수 명에는 **능동형 동사** 를 써야하며 명사가 따라올 수 있다.
- 예를 들어 특정 조건을 만족하는지 확인한 후 논리값을 반환하는 함수의 경우 check~~ 보단 is~~~ 로 명확하게 논리값을 반환함을 알려주는 것이 좋다.

`정확한 이름을 사용하라`
- 잘못된 이름을 사용한다면 코드를 보는사람에게 잘못된 정보를 전달할뿐 아니라 예상치 못한 버그를 만들 수 있다.
- 함수의 이름과 동작이 일치해야한다.

### 1-2. 표현식과 문장
- 표현식과 문장도 의미를 최대한 드러내야 한다.
- 제대로 동작하는 가장 명료한 코드를 작성하라.
- 연산 단위가 눈에 잘 띄도록 연산자 주변에는 공백을 주어야 한다.

`들여쓰기로 구조를 알아보기 쉽게 하라`
- 일관성 있는 들여쓰기로 알아보기 쉽게 해야한다.
- IDE 에서 들여쓰기는 일반적으로 4 space(1 tab) 를 많이 사용한다.

`표현식을 자연스럽게 사용하라`
- 표현식을 말하는것 처럼 자연스럽게 사용해야 한다.
- 부정을 포함하는 조건식은 이해하기 힘들게 만든다.
- 가능하다면 부정문을 제거하라

`괄호를 사용해 애매함을 해소하라`
- 괄호는 연산에서 의미 단위를 명확하게 해준다.
- 의도를 분명히 하게 위해 사용해주면 도움이 된다.
- 연산자 우선순위와 상관없이 가독성을 위해 필요하다면 괄호를 사용하라.

`복잡한 표현을 잘게 쪼개라`
- C, C++, 자바는 표현식을 사용하는 문법과 연산자가 많아 한 문장안에 지나치게 많은 것을 집어넣는 일이 많다.
- 코드라인 줄이는것이 중요한게 아니다.
- 오히려 짧은 코드가 가독성을 해친다면 여러줄로 쪼개어야 한다.

`명료하게 사용하라`
- 간결하고 멋진 코드를 작성하는게 중요한게 아니다. **명료한 코드**를 사용하는 것이다.
- 명료성과 간결성을 동일하지 않다.
- 명료한 코드는 대게 짧은 편이지만, 조건식을 if-else 문을 사용해 풀어 쓰는 것 처럼 오히려 긴 코드가 명료한 경우도 존재한다.

> 코드 라인 수가 아닌 얼마나 이해하기 쉬운지가 기준이 되어야 한다.

`부수효과를 조심하라`
- ++ 와 같은 연산자는 값을 반환하는것 외에도 변수값 자체를 바꾸는 부수효과가 있다.
- 이런 부수효과는 편리하지만 예상치못한 문제를 일으킬 수 있다.
- 해결책은 대개 그렇듯이 코드를 여러 라인으로 쪼개는 것이다.

### 1-3. 일관성과 관용 표현
- 일관성을 유지하는 것은 좋은 프로그램을 만드는 길이다.
- 코드 스타일이 예측할 수 없이 달라지는 경우 동작하기 알아보기 힘들다.

`들여쓰기와 중괄호를 사용하는 스타일은 일관성을 지켜라`
- 들여쓰기와 중고라호는 구조를 쉽게 알 수 있게 한다.
- 중괄호를 꼭 쓸 필요없을 때도 사용 해야할까 ?
    - 이부분은 논쟁이 많다.
    - 가능하다면 중괄호는 반드시 써주는게 일관적이다.

> 본인이 작성하지 않은 코드를 수정할 때는 기존 코드 스타일을 유지하는 것이 좋다. \n
> 코드 수정시 자신의 스타일을 사용하지 않는 것이 좋다. \n
> 코드의 일관성은 개발자 본인의 스타일 보다 더 중요하다.

`일관성을 위해 관용 표현을 사용하라`
- 프로그래밍언어도 관용 표현과 일반적으로 사용하는 상용 표현들이 있다.
- 어떤 언어를 배우더라도 핵심은 이런 관용적인 표현에 익숙해지는 것이다.

`다중결정이 필요한 경우 else-if 를 사용하라`
- 다중 결정이 필요한 경우 보통 if-else if-else 를 엮어 사용한다.
- 중첩된 if 문은 오히려 가독성을 떨어뜨린다.

> 코드를 재활용 하려고 하다 보면 지나치게 꽉 짜인 프로그램이 될 수 있다.

### 1-4. 매크로 함수를 멀리하라.

### 1-5. 매직 넘버
- 매직 넘버란 프로그램 넹서 쓰이는 상수, 배열의 크기 등 여러 특정한 리터럴 값들을 말한다.

`매직 넘버에 이름을 달아라`
- 소스코드에서 0, 1 과 같은 숫자들은 어떤 것을 의미하는지 작성자 외에는 알기 힘들다.
- 각 값들이 어떤 의미를 갖는지 이름을 달아 주어야 한다.

`숫자는 상수로 정의하라`
- C 개발자들은 보통 매직넘버 값을 관리하기 위해 #define 을 사용했다.
- 이런 숫자값들은 const 또는 enum 을 이용한 상수를 선언하라.

`아스키 문자는 숫자 코드 말고 문자 상수로 사용하라`
- 아스키 코드는 숫자 혹은 문자로 사용할 수 있는데, 65 라는 값보다는 'A' 라는 값이 이해하기 더 쉽다.
- 가장 좋은 방법은 표준 라이브러리를 사용하는 것이다.

`언어에서 제공하는 함수를 이용해 객체의 크기를 계산하라`
- 어떤 자료에도 크기를 명시적인 숫자로 사용하지 말고 언어에서 제공하는 함수를 이용해야 한다.
- 자바의 length, size 와 같은 함수가 이런 예이다.
- 이런 객체의 크기도 명시적인 숫자로 사용한다면 매직넘버이다.

### 1-6. 주석
- 주석이 코드만으로 충분히 설명된 것을 반복해서 얘기하거나, 코드 내용과 모순되는 경우 도움이 되지 않는다.
- 좋은 주석은 핵심적인 세부 사항을 간결하게 지적해 이해를 도와야 한다.

`명확한 코드에는 주석을 달지 말라`
- 이런 주석은 모두 삭제해야 한다.
- 잘 지은 변수명과 같이 이미 충분한 정보를 전달하는 경우 의미가 없다.

`함수와 전역 데이터에 주석을 달아라`
- 주석은 유용한 경우가 많다.
- 함수, 정겨변수, 상수 와같이 짤막한 설명이 도움을 주는 곳이라면 어디든 주석을 붙인다.
- 주석이 전역변수에 사용된다면 필요한 경우 역할을 상기시켜줄 수 있다.

`나쁜코드에 대해 설명하지 말고 코드를 새로 짜라`
- 유별난 코드나 헷갈릴수 있는 코드에는 주석을 달아야 한다.
- 하지만 주석이 코드보다 긴 경우 코드를 고칠 필요야 있다는 생각을 해야 한다.

`주석과 코드가 모순되게 하지 말라`
- 대부분의 주석은 코드 작성 당시에는 제대로 맞지만, 프로그램이 변화하며, 주석이 그대로라면 코드와 맞지 않게 된다.
- 불일치 이유가 무엇이든, 주석이 코드와 맞지 않는다면 혼란 스럽고 디버깅이 오래 걸리게 된다.
- 코드를 변경하면 반드시 주석이 정확한지 확인해야 한다.

> 주석은 코드에 일치하는 것이 아닌 코드를 보충하는 것이 되어야 한다.

`혼란스럽게 하지 말고, 명확하게 하라`
- 주석은 도움을 주려고 하는것이 목적이지 방해하는 것이 아니다.
- 코드만으로 이해를 할수 있게, 즉 주석이 필요 없는 코드를 짜는것이 1차적인 목표이다.
- 좋은 코드는 나쁜 코드보다 주석이 적게 필요하다.

### 1-7. 왜 그렇게 귀찮게 구는가 ?
- 잘 짠 코드는 대충 던져놓고 한 번도 정리하지 않은 코드보다 읽기 쉽고 문제도 없다.
- 지저분한 코드는 나쁜 코드다. 읽기 힘든것뿐만이 아닌 잘 망가진다.
- 좋은 스타일이 습관이 되어야 한다.

## 2. 알고리즘과 데이터 구조
- 모든 프로그램은 알고리즘과 데이터 구조에 의지하지만, 새로운 알고리즘이나 데이터 구조를 발명해서 써야하는 일은 매우 드물다.
- 컴파일러 / 웹 브라우저등 과 같은 경우에도 내부 데이터 구조는 대부분 배열, 리스트, 트리, 해시 테이블을 사용한다.
- 대다수의 개발자들이 할일은 어떤 알고리즘과 어떤 데이터 구조를 사용할지 이를 파악하고 여러 대안중 하나를 선택하는 방법을 이해하는 것이다.

### 2-1. 검색
- 정적 테이블 형태의 데이터를 저장하는 데는 배열이 최선의 선택이다.
- 컴파일 시점에 초기화 되므로 비용도 적게 든다. (자바의 경우 실행 시점에 초기화)

`순차 검색 (sequential search)`
- 가장 단순한 검색 알고리즘
- 원하는 원소가 나올 떄 까지 모든 원소를 순차적으로 찾는 방식
- 데이터 개수가 적을 경우 순차 검색의 속도는 빠르다.
- 데이터 전체의 크기와 작업량이 정비레 한다는 단점이 있다.

> 실행 시간과 데이터 크기가 일차 함수 관계기 때문에 이를 선형 관계 라고 도 부르며, 선형 검색이라고 부르기도 한다.

`이진 탐색 (binary search)`
- 우리가 사전에서 단어를 찾아보는 방법을 규칙적으로 만들어놓은 방식
- 배열의 가운데 원소를 찾고, 해당 값의 크고 작음에 따라 검색 범위를 절반씩 줄여 나가는 것이다.
- 이러한 방식 때문에 **이진 탐색** 라고 부른다.
- 이진 탐색의 경우 배열이 **반드시 정렬** 되어 있어야 한다.

> 이진 탐색은 매 단계마다 검색 범위를 절반씩 줄여나가기 때문에 소수 이하를 무시한다면 log2n 이다. \n
> 선형 검색이 천번을 검색해야 한다면 이진 탐색은 10번이면 충분하다.

### 2-2. 정렬

`퀵 정렬`
- 1960년 C. A. R 호어가 고안해낸 정렬 알고리즘
- 어떤 상황에서 무난한 최고의 정렬 알고리즘 중 하나
- 이는 불필요한 계싼을 피하는 방법을 제시하는 좋은 예 이기도 하다.
- 배열의 모든 원소를 기준 값보다 작거나 큰 부분으로 나누는 방식으로 동작한다.
  - 배열 원소중 기준 (pivot) 을 선택
  - 다른 원소들을 두 집단으로 분할
    - 기준 보다 작은 값
    - 기준 보다 큰 값
  - 각 집단을 이런식으로 반복하여 정렬한다.

> 퀵 정렬이 빠른 이유는 pivot 보다 작다고 판단되면 해당 원소를 기준 값 보다 큰 원소들과 비교하지 않아도 되기 때문
> 일반 적으로 nlogn 에 비례한다.
> 하지만 퀵 정렬이 모든 경우에 최선인 경우는 아니다. \n
> 만약 데이터 분포가 일정하지않아 균등한 분할이 되지 않는다면 최악의 경우 n2 에 가까워 진다.

### 2-3. 라이브러리
- 라이브러리 루틴은 어떤 데이터 타입도 정렬할 수 있게 만들어 져 있지만 우리가 그 루틴의 인터페이스에 적응 해야 한다.

### 2-4. 자바의 퀵 정렬
- 자바의 초기 에는 표준 정렬 함수가 없어 직접 정렬 을 구현해야 했다.
- 비교적 최근에는 Comparable 인터페이스를 구현하는 클래스를 대상으로 sort 함수를 제공된다.

```java
interface Cmp {
    int cmp(Object x, Object y);
}

class Icmp implements Cmp {
    
    @Override
    public int cmp(Object o1, Object o2) {
      int i1 = ((Integer) o1).intValue();
      int i2 = ((Integer) o2).intValue();
      if (i1 < i2) {
          return -1;
      } else if (i1 == i2) {
          return 0;
      } else {
          return 1;
      }
    }
}

class QuickSort {
    static Random random = new Random();
    
    static void sort(Object[] v, int left, int right, Cmp cmp) {
        int i;
        int last;
        
        if (left >= right) { // 할일 없음 종료
            return;
        }
        swap(v, left, rand(left, right)); // 기준 원소를 v[left] 로 이동
        last = left;
        for (i = left + 1; i <= right; i++) { // 분할
            if (cmp.cmp(v[i], v[left]) < 0) {
                swap(v, ++last, i);
            }
        }
        swap(v, left, last); // 기준 복원
        sort(v, left, last - 1, cmp); // 각 부분을 재귀적으로 정렬
        sort(v, last + 1, right, cmp);
    }
    
    static void swap(Object[] v, int i, int j) {
        Object temp;
        temp = v[i];
        v[i] = v[j];
        v[j] = temp;
    }
    
    static int rand(int left, int right) {
        // 자바 난수 생성기는 음수도 생성하기 때문에 Math.abs 로 절대값을 생성한다.
        return left + Math.abs(rgen.nextInt()) % (right - left + 1);
    }
}
```

### 2-5. 빅오 표기법
- 어떤 특정 알고리즘이 수행하는 작업량을 좀 더 정확하게 표현하면서 하드웨어 혹은 그 외적인 요소들을 제외한 표현이 필요한 경우가 많다.
- 그 결과 탄생 한것이 빅오 표기법 이다.
- 기본 인자는 n (문제 인스턴스의 크기)
- 알고리즘의 복잡도나 실행시간은 n의 함수로 표현된다.

| 표기법 | 이름 | 예 |
| --- | --- | --- |
| O(1) | 상수 | 배열을 인덱스로 참조 |
| O(logn) | 로그 | 이진 탐색 |
| O(n) | 선형 | 문자열 비교 |
| O(nlogn) | nlogn | 퀵정렬 |
| O(n2) | 제곱 | 단순한 정렬 방법들 |
| O(n3) | 세제곱 | 행렬 곱셈 |
| O(2n) | 지수 | 집합 분할 |

> 여행하는 영업사원 문제 와 같이 지수알고리즘만으로 해결 가능한 문제들이 매우 많다. \n
> 이런 경우 해답의 근사치를 찾아내는 알고리즘으로 대체하는 경우가 많다.

### 2-6. 크기가 커지는 배열들
- 만약 배열에 들어갈 단어나 HTML 글자 테이블이 런타임 시점에 변경된다면 해시 테이블이 더 적절한 데이터 구조일 것이다.
- 정렬된 배열에 원소를 넣을때마다 배열의 크기가 커지는 연산은 O(n2) 연산이다.

### 2-7. 리스트
- 배열 다음으로 자주 사용되는 자료구조이다.
- 리스트 타입을 언어 레벨에서 제공하는 언어도 많고, Lisp 같은 언어들은 아에 언어 자체가 리스트 기반인 경우도 있다.

`단일 연결 리스트`
- 단일 연결 리스트는 각 데이터와 다음 노드를 가리키는 포인터를 가지는 아이템들의 집합이다.
- 리스트의 헤드는 첫 번째 노드를 가리키는 포인터 이고, 리스트의 마지막은 null 포인터로 표시한다.

> 배열과 리스트의 가장 큰 차이점은 배열은 크기가 고정되어 있지만, 리스트는 필요한 만큼만 메모리 공간을 사용한다는 점이다. \n
> 또 한가지는 배열은 메모리를 블록 단위로 옮겨야 하지만, 리스트는 포인터 몇 개만 바꾸면 순서 변경이 가능해 진다.

- 변경이 자주 일어나고, 임의 접근 방식도 필요하다면 트리 혹은 해시 테이블을 사용하는 것이 좋다.

### 2-8. 트리
- 트리는 노드 마다 어떤 값을 가지고 있고, 0 혹은 그 이상의 다른 아이템을 가진 계층형 데이터 구조이다.
- 트리의 루트는 조금 특별한데, 루트를 가리키는 노드는 없다.
- 트리는 종류가 여러가지가 있다.
- 문장 혹은 프로그램의 문법을 담아내는 **파스 트리 (parse tree)**, 족보 등도 트리로 표현이 가능하다.

`이진 검색 트리 (binary search tree)`
- 이진 검색 트리는 노드 마다 두 링크를 가진다.
- 또한 만들기도 쉽고, 트리의 중요한 특징을 모두 가지고 있다.
- 노드는 값 하나와 자식을 가지는 두개의 포인터를 가진다.
- 노드의 자식이 두개보다 적을 경우 포인터가 널 일 수 있다.
- 이진 검색 트리는 노드가 가진 값이 트리의 모양을 결정한다.
- 노드의 왼쪽에 있는 모든 자식은 해당 노드보다 값이 적어야 하며 오른쪽은 반대로 값이 커야 한다.

> 이러한 특성 때문에 리스트나 배열에서 O(n) 연산들이 트리에서는 O(logn) 만큼 걸린다.

루트 부터 모든 리프 노드 까지 길이가 거의 비슷한 트리를 **균형 트리 (balanced tree)** 라고도 한다.

> 트리의 균형을 보장해주는 트리를 만드는 것은 어렵기 때문에 트리의 종류가 많은 것이다.

`트리를 순회하는 방법`
- 중위 순회법
  - 왼쪽 하위 트리를 방문 한 뒤 해당 노드에 대한 연산을 수행한 뒤 오른쪽 하위 트리를 방문하는 방식
- 후위 순회법
  - 자식들을 모두 방문한 뒤 현재 노드에 대한 연산을 수행하는 방식
- 전위 순회법
  - 거의 사용되지 않음..

### 2-9 해시 테이블
- 해시 테이블은 컴퓨터 과학의 위대한 발명품 중 하나이다.
- 배열, 리스트, 수학 지식을 합쳐 만들었으며 동적인 데이터를 저장 / 넣고 빼기에 효과적인 데이터 구조
- 일반적으로 심벌 테이블을 관리할때 사용한다.
- 심벌 테이블은 동적인 키와 어떤 값을 연결해둔 테이블이다.
- 해시 테이블의 핵심은 **해시 함수** 를 사용해 적절하게 균등하게 분포되는 해시 값를 만드는 것이다.
  - 이는 결정적(deterministic) 이어야 하고, 빠르고 균일하게 분산되어야 한다.

### 2-10. 정리
- 알고리즘을 선택할 때는 여러단계를 거쳐야 한다.
- 알고리즘과 데이터 구조들을 평가 한뒤 처리해야할 데이터 양이 얼마나 많을지 예측해야 한다.
- 데이터양이 크지 않다면 간단한 기법을 사용하는 것이 좋다.
- 가능하다면 라이브러리 혹은 언어에서 기본적으로 제공하는 기능을 사용해야 한다.

## 3. 설계와 구현
- 프로그램을 만들 때 가장 중요한 것은 데이터 구조의 설계이다.
- 데이터 구조를 만들었다면, 알고리즘은 바로 결정이 가능하고 그에 따른 코드 작성도 비교적 쉽다.

### 3-1. 마르코프 체인 알고리즘
- 이 알고리즘은 각 어구를 여러 단어로 된 **접두사** 와 한 단어로 이뤄진 접미사로 나눈다.
- 또한 주어진 접두사에 대해 통계적 특성에 따라 선택한 접미사를 만들어 낸다.

### 3-2. 데이터 구조 후보들
- 일반적으로 책 한권 정도 분량을 입력한다면 십만 단어 이상의 입력을 처리할 수 있도록 만들어야 한다.
- 또한 초단위 수준에서 프로그램 실행이 완료되어야 한다.
- 마로코프 알고리즘은 출력을 만들기전 입력 데이터를 모두 검토하기 때문에 **전체 입력을 모두 저장** 해야 한다.
- 한 접두사와 여기에 딸린 여러 접미사를 표현할 데이터 구조가 필요하다.
  - 접두사를 **키** 로 사용하고, 접미사 목록을 **값** 으로 사용하는 해시 테이블이 필요하다.

### 3-3. C 에서 구현하기

### 3-4. 자바에서 구현하기
- 객체지향 언어를 사용할 때는 컴포넌트 사이의 인터페이스에 관심을 기울여야 한다.
- 자바는 C 보다 라이브러리가 풍부해서 여러 오브젝트들을 다양한 방법으로 관리할 **컨테이너 클래스** 들을 제공한다.
- 자바로 작성한 프로그램은 C 보다 크기가 작으며 신경쓸 부분도 적다.
- 하지만 모든것을 알아서 다 해주는것은 아니라는 것을 명심해야 한다.

### 3-5. C++

### 3-6. Awk 와 펄

### 3-7. 성능

### 3-8. 교훈
- 고수준 언어로 만들 프로그램이 저수준 언어보다 만들것 보다 느린 경향이 있다.
    - 이는 절대적인 것은 아니고 항상 그렇지도 않다.
- C++ STL 처럼 큰 컴포넌트나 스크립트 언어가 제공하는 결합 배열과 문자열 처리는 코드길이를 줄여주고 개발 시간도 단축시켜 준다.
    - 물론 성능이 떨어지는 대가를 치러야 한다.
- 단순한 알고리즘과 데이터 구조 선택이 중요하다.
- 사용할 알고리즘에 대한 지식을 토대로 데이터 구조를 상세하게 설계하는 것이 가장 좋다.
# The Practice of Programming

## 1. 스타일
- 스타일의 목적은 읽기 좋은 코드를 만드는 것이다.
- 좋은 스타일은 좋은 프로그래밍에 결정적인 역할을 한다.
- 예전에 비해 최근의 프로그래밍을 잘한다는 기준은 많이 변화되었다.
- 이전에는 복잡하고 남들이 알아보기 힘들게 만들수록 잘한다 라는 느낌을 받았지만 요즘은 그렇지 않다.
- 읽기 쉬운 코드, 알아보기 쉬운 코드를 짜는 것이 프로그래밍을 잘한다의 기준이 되었다.

### 1-1. 네이밍
- 변수나 함수의 이름은 각 객체들을 구분 짓고 목적에 관한 정보를 전달한다.
- 이는 정보 면에서 유익함과 동시에 간결해야 하며 기억하기 쉬워야 한다.
- 문맥과 유효범위 (scope) 에서 많은 정보를 얻을 수 있고, 유효범위가 높을수록 이름은 더 많은 정보를 전달해야 한다.

`전역변수는 서술적인 이름을, 지역변수는 간결한 이름을 사용하라`
- **전역 변수** 는 유효범위가 크기 때문에 어디서든 사용될 여지가 있다.
- 가능하다면 해당 의미를 서술적으로 전달하는 것이 좋다.
- 필요에 따라 간단한 주석을 달아주는 것도 좋다.
- **지역 변수** 는 짧은 이름을 써도 충분하다.
- 관례로 많이 사용하는 경우에는 축약어를 사용해 주어도 좋다.
- 하지만 지나치게 축약어를 남용하는 경우에는 오히려 역효과를 부른다.

> 명명규칙과 지역적 관례는 다양하다.
> 
> 명명규칙을 준수하면 본인의 코드 또는 다른 사람의 코드도 쉽게 이해할 수 있다.

`일관성을 지켜라`
- 서로 관련이 있는 것들에는 연관된 이름을 붙여 상관관계를 보여줌과 동시에 차이점이 눈에 띄도록 해야한다.

```java
class UserQueue {
    int noOfItemInQ;
    int frontOfTheQueue;
    int queueCapacity;
    // ...
}
```
- 위와 같은 코드의 경우 queue 라는 이름이 불필요하게 중복되고 있다.
- 해당 지역변수는 userQueue 인스턴스를 통해서만 접근이 가능한데, 만약 사용한다면 다음과 같을 것이다.

```java
queue.queueCapacity;

// 개선된 버전
queue.capacity;
```

> 추가적으로 1명이 작성한 코드인데 파일마다 작성하는 방식이 다르다거나, 심한경우 각 함수마다 스타일이 전혀 다른 경우가 있다.
> 
> 이는 코드를 읽는 이로 하여금 혼란을 줄 수 있다.

`함수 명은 능동형을 사용하라`
- 함수 명에는 **능동형 동사** 를 써야하며 명사가 따라올 수 있다.
- 예를 들어 특정 조건을 만족하는지 확인한 후 논리값을 반환하는 함수의 경우 check~~ 보단 is~~~ 로 명확하게 논리값을 반환함을 알려주는 것이 좋다.

`정확한 이름을 사용하라`
- 잘못된 이름을 사용한다면 코드를 보는사람에게 잘못된 정보를 전달할뿐 아니라 예상치 못한 버그를 만들 수 있다.
- 함수의 이름과 동작이 일치해야한다.

### 1-2. 표현식과 문장
- 표현식과 문장도 의미를 최대한 드러내야 한다.
- 제대로 동작하는 가장 명료한 코드를 작성하라.
- 연산 단위가 눈에 잘 띄도록 연산자 주변에는 공백을 주어야 한다.

`들여쓰기로 구조를 알아보기 쉽게 하라`
- 일관성 있는 들여쓰기로 알아보기 쉽게 해야한다.
- IDE 에서 들여쓰기는 일반적으로 4 space(1 tab) 를 많이 사용한다.

`표현식을 자연스럽게 사용하라`
- 표현식을 말하는것 처럼 자연스럽게 사용해야 한다.
- 부정을 포함하는 조건식은 이해하기 힘들게 만든다.
- 가능하다면 부정문을 제거하라

`괄호를 사용해 애매함을 해소하라`
- 괄호는 연산에서 의미 단위를 명확하게 해준다.
- 의도를 분명히 하게 위해 사용해주면 도움이 된다.
- 연산자 우선순위와 상관없이 가독성을 위해 필요하다면 괄호를 사용하라.

`복잡한 표현을 잘게 쪼개라`
- C, C++, 자바는 표현식을 사용하는 문법과 연산자가 많아 한 문장안에 지나치게 많은 것을 집어넣는 일이 많다.
- 코드라인 줄이는것이 중요한게 아니다.
- 오히려 짧은 코드가 가독성을 해친다면 여러줄로 쪼개어야 한다.

`명료하게 사용하라`
- 간결하고 멋진 코드를 작성하는게 중요한게 아니다. **명료한 코드**를 사용하는 것이다.
- 명료성과 간결성을 동일하지 않다.
- 명료한 코드는 대게 짧은 편이지만, 조건식을 if-else 문을 사용해 풀어 쓰는 것 처럼 오히려 긴 코드가 명료한 경우도 존재한다.

> 코드 라인 수가 아닌 얼마나 이해하기 쉬운지가 기준이 되어야 한다.

`부수효과를 조심하라`
- ++ 와 같은 연산자는 값을 반환하는것 외에도 변수값 자체를 바꾸는 부수효과가 있다.
- 이런 부수효과는 편리하지만 예상치못한 문제를 일으킬 수 있다.
- 해결책은 대개 그렇듯이 코드를 여러 라인으로 쪼개는 것이다.

### 1-3. 일관성과 관용 표현
- 일관성을 유지하는 것은 좋은 프로그램을 만드는 길이다.
- 코드 스타일이 예측할 수 없이 달라지는 경우 동작하기 알아보기 힘들다.

`들여쓰기와 중괄호를 사용하는 스타일은 일관성을 지켜라`
- 들여쓰기와 중고라호는 구조를 쉽게 알 수 있게 한다.
- 중괄호를 꼭 쓸 필요없을 때도 사용 해야할까 ?
    - 이부분은 논쟁이 많다.
    - 가능하다면 중괄호는 반드시 써주는게 일관적이다.

> 본인이 작성하지 않은 코드를 수정할 때는 기존 코드 스타일을 유지하는 것이 좋다. \n
> 코드 수정시 자신의 스타일을 사용하지 않는 것이 좋다. \n
> 코드의 일관성은 개발자 본인의 스타일 보다 더 중요하다.

`일관성을 위해 관용 표현을 사용하라`
- 프로그래밍언어도 관용 표현과 일반적으로 사용하는 상용 표현들이 있다.
- 어떤 언어를 배우더라도 핵심은 이런 관용적인 표현에 익숙해지는 것이다.

`다중결정이 필요한 경우 else-if 를 사용하라`
- 다중 결정이 필요한 경우 보통 if-else if-else 를 엮어 사용한다.
- 중첩된 if 문은 오히려 가독성을 떨어뜨린다.

> 코드를 재활용 하려고 하다 보면 지나치게 꽉 짜인 프로그램이 될 수 있다.

### 1-4. 매크로 함수를 멀리하라.

### 1-5. 매직 넘버
- 매직 넘버란 프로그램 넹서 쓰이는 상수, 배열의 크기 등 여러 특정한 리터럴 값들을 말한다.

`매직 넘버에 이름을 달아라`
- 소스코드에서 0, 1 과 같은 숫자들은 어떤 것을 의미하는지 작성자 외에는 알기 힘들다.
- 각 값들이 어떤 의미를 갖는지 이름을 달아 주어야 한다.

`숫자는 상수로 정의하라`
- C 개발자들은 보통 매직넘버 값을 관리하기 위해 #define 을 사용했다.
- 이런 숫자값들은 const 또는 enum 을 이용한 상수를 선언하라.

`아스키 문자는 숫자 코드 말고 문자 상수로 사용하라`
- 아스키 코드는 숫자 혹은 문자로 사용할 수 있는데, 65 라는 값보다는 'A' 라는 값이 이해하기 더 쉽다.
- 가장 좋은 방법은 표준 라이브러리를 사용하는 것이다.

`언어에서 제공하는 함수를 이용해 객체의 크기를 계산하라`
- 어떤 자료에도 크기를 명시적인 숫자로 사용하지 말고 언어에서 제공하는 함수를 이용해야 한다.
- 자바의 length, size 와 같은 함수가 이런 예이다.
- 이런 객체의 크기도 명시적인 숫자로 사용한다면 매직넘버이다.

### 1-6. 주석
- 주석이 코드만으로 충분히 설명된 것을 반복해서 얘기하거나, 코드 내용과 모순되는 경우 도움이 되지 않는다.
- 좋은 주석은 핵심적인 세부 사항을 간결하게 지적해 이해를 도와야 한다.

`명확한 코드에는 주석을 달지 말라`
- 이런 주석은 모두 삭제해야 한다.
- 잘 지은 변수명과 같이 이미 충분한 정보를 전달하는 경우 의미가 없다.

`함수와 전역 데이터에 주석을 달아라`
- 주석은 유용한 경우가 많다.
- 함수, 정겨변수, 상수 와같이 짤막한 설명이 도움을 주는 곳이라면 어디든 주석을 붙인다.
- 주석이 전역변수에 사용된다면 필요한 경우 역할을 상기시켜줄 수 있다.

`나쁜코드에 대해 설명하지 말고 코드를 새로 짜라`
- 유별난 코드나 헷갈릴수 있는 코드에는 주석을 달아야 한다.
- 하지만 주석이 코드보다 긴 경우 코드를 고칠 필요야 있다는 생각을 해야 한다.

`주석과 코드가 모순되게 하지 말라`
- 대부분의 주석은 코드 작성 당시에는 제대로 맞지만, 프로그램이 변화하며, 주석이 그대로라면 코드와 맞지 않게 된다.
- 불일치 이유가 무엇이든, 주석이 코드와 맞지 않는다면 혼란 스럽고 디버깅이 오래 걸리게 된다.
- 코드를 변경하면 반드시 주석이 정확한지 확인해야 한다.

> 주석은 코드에 일치하는 것이 아닌 코드를 보충하는 것이 되어야 한다.

`혼란스럽게 하지 말고, 명확하게 하라`
- 주석은 도움을 주려고 하는것이 목적이지 방해하는 것이 아니다.
- 코드만으로 이해를 할수 있게, 즉 주석이 필요 없는 코드를 짜는것이 1차적인 목표이다.
- 좋은 코드는 나쁜 코드보다 주석이 적게 필요하다.

### 1-7. 왜 그렇게 귀찮게 구는가 ?
- 잘 짠 코드는 대충 던져놓고 한 번도 정리하지 않은 코드보다 읽기 쉽고 문제도 없다.
- 지저분한 코드는 나쁜 코드다. 읽기 힘든것뿐만이 아닌 잘 망가진다.
- 좋은 스타일이 습관이 되어야 한다.

## 2. 알고리즘과 데이터 구조
- 모든 프로그램은 알고리즘과 데이터 구조에 의지하지만, 새로운 알고리즘이나 데이터 구조를 발명해서 써야하는 일은 매우 드물다.
- 컴파일러 / 웹 브라우저등 과 같은 경우에도 내부 데이터 구조는 대부분 배열, 리스트, 트리, 해시 테이블을 사용한다.
- 대다수의 개발자들이 할일은 어떤 알고리즘과 어떤 데이터 구조를 사용할지 이를 파악하고 여러 대안중 하나를 선택하는 방법을 이해하는 것이다.

### 2-1. 검색
- 정적 테이블 형태의 데이터를 저장하는 데는 배열이 최선의 선택이다.
- 컴파일 시점에 초기화 되므로 비용도 적게 든다. (자바의 경우 실행 시점에 초기화)

`순차 검색 (sequential search)`
- 가장 단순한 검색 알고리즘
- 원하는 원소가 나올 떄 까지 모든 원소를 순차적으로 찾는 방식
- 데이터 개수가 적을 경우 순차 검색의 속도는 빠르다.
- 데이터 전체의 크기와 작업량이 정비레 한다는 단점이 있다.

> 실행 시간과 데이터 크기가 일차 함수 관계기 때문에 이를 선형 관계 라고 도 부르며, 선형 검색이라고 부르기도 한다.

`이진 탐색 (binary search)`
- 우리가 사전에서 단어를 찾아보는 방법을 규칙적으로 만들어놓은 방식
- 배열의 가운데 원소를 찾고, 해당 값의 크고 작음에 따라 검색 범위를 절반씩 줄여 나가는 것이다.
- 이러한 방식 때문에 **이진 탐색** 라고 부른다.
- 이진 탐색의 경우 배열이 **반드시 정렬** 되어 있어야 한다.

> 이진 탐색은 매 단계마다 검색 범위를 절반씩 줄여나가기 때문에 소수 이하를 무시한다면 log2n 이다. \n
> 선형 검색이 천번을 검색해야 한다면 이진 탐색은 10번이면 충분하다.

### 2-2. 정렬

`퀵 정렬`
- 1960년 C. A. R 호어가 고안해낸 정렬 알고리즘
- 어떤 상황에서 무난한 최고의 정렬 알고리즘 중 하나
- 이는 불필요한 계싼을 피하는 방법을 제시하는 좋은 예 이기도 하다.
- 배열의 모든 원소를 기준 값보다 작거나 큰 부분으로 나누는 방식으로 동작한다.
  - 배열 원소중 기준 (pivot) 을 선택
  - 다른 원소들을 두 집단으로 분할
    - 기준 보다 작은 값
    - 기준 보다 큰 값
  - 각 집단을 이런식으로 반복하여 정렬한다.

> 퀵 정렬이 빠른 이유는 pivot 보다 작다고 판단되면 해당 원소를 기준 값 보다 큰 원소들과 비교하지 않아도 되기 때문
> 일반 적으로 nlogn 에 비례한다.
> 하지만 퀵 정렬이 모든 경우에 최선인 경우는 아니다. \n
> 만약 데이터 분포가 일정하지않아 균등한 분할이 되지 않는다면 최악의 경우 n2 에 가까워 진다.

### 2-3. 라이브러리
- 라이브러리 루틴은 어떤 데이터 타입도 정렬할 수 있게 만들어 져 있지만 우리가 그 루틴의 인터페이스에 적응 해야 한다.

### 2-4. 자바의 퀵 정렬
- 자바의 초기 에는 표준 정렬 함수가 없어 직접 정렬 을 구현해야 했다.
- 비교적 최근에는 Comparable 인터페이스를 구현하는 클래스를 대상으로 sort 함수를 제공된다.

```java
interface Cmp {
    int cmp(Object x, Object y);
}

class Icmp implements Cmp {
    
    @Override
    public int cmp(Object o1, Object o2) {
      int i1 = ((Integer) o1).intValue();
      int i2 = ((Integer) o2).intValue();
      if (i1 < i2) {
          return -1;
      } else if (i1 == i2) {
          return 0;
      } else {
          return 1;
      }
    }
}

class QuickSort {
    static Random random = new Random();
    
    static void sort(Object[] v, int left, int right, Cmp cmp) {
        int i;
        int last;
        
        if (left >= right) { // 할일 없음 종료
            return;
        }
        swap(v, left, rand(left, right)); // 기준 원소를 v[left] 로 이동
        last = left;
        for (i = left + 1; i <= right; i++) { // 분할
            if (cmp.cmp(v[i], v[left]) < 0) {
                swap(v, ++last, i);
            }
        }
        swap(v, left, last); // 기준 복원
        sort(v, left, last - 1, cmp); // 각 부분을 재귀적으로 정렬
        sort(v, last + 1, right, cmp);
    }
    
    static void swap(Object[] v, int i, int j) {
        Object temp;
        temp = v[i];
        v[i] = v[j];
        v[j] = temp;
    }
    
    static int rand(int left, int right) {
        // 자바 난수 생성기는 음수도 생성하기 때문에 Math.abs 로 절대값을 생성한다.
        return left + Math.abs(rgen.nextInt()) % (right - left + 1);
    }
}
```

### 2-5. 빅오 표기법
- 어떤 특정 알고리즘이 수행하는 작업량을 좀 더 정확하게 표현하면서 하드웨어 혹은 그 외적인 요소들을 제외한 표현이 필요한 경우가 많다.
- 그 결과 탄생 한것이 빅오 표기법 이다.
- 기본 인자는 n (문제 인스턴스의 크기)
- 알고리즘의 복잡도나 실행시간은 n의 함수로 표현된다.

| 표기법 | 이름 | 예 |
| --- | --- | --- |
| O(1) | 상수 | 배열을 인덱스로 참조 |
| O(logn) | 로그 | 이진 탐색 |
| O(n) | 선형 | 문자열 비교 |
| O(nlogn) | nlogn | 퀵정렬 |
| O(n2) | 제곱 | 단순한 정렬 방법들 |
| O(n3) | 세제곱 | 행렬 곱셈 |
| O(2n) | 지수 | 집합 분할 |

> 여행하는 영업사원 문제 와 같이 지수알고리즘만으로 해결 가능한 문제들이 매우 많다. \n
> 이런 경우 해답의 근사치를 찾아내는 알고리즘으로 대체하는 경우가 많다.

### 2-6. 크기가 커지는 배열들
- 만약 배열에 들어갈 단어나 HTML 글자 테이블이 런타임 시점에 변경된다면 해시 테이블이 더 적절한 데이터 구조일 것이다.
- 정렬된 배열에 원소를 넣을때마다 배열의 크기가 커지는 연산은 O(n2) 연산이다.

### 2-7. 리스트
- 배열 다음으로 자주 사용되는 자료구조이다.
- 리스트 타입을 언어 레벨에서 제공하는 언어도 많고, Lisp 같은 언어들은 아에 언어 자체가 리스트 기반인 경우도 있다.

`단일 연결 리스트`
- 단일 연결 리스트는 각 데이터와 다음 노드를 가리키는 포인터를 가지는 아이템들의 집합이다.
- 리스트의 헤드는 첫 번째 노드를 가리키는 포인터 이고, 리스트의 마지막은 null 포인터로 표시한다.

> 배열과 리스트의 가장 큰 차이점은 배열은 크기가 고정되어 있지만, 리스트는 필요한 만큼만 메모리 공간을 사용한다는 점이다. \n
> 또 한가지는 배열은 메모리를 블록 단위로 옮겨야 하지만, 리스트는 포인터 몇 개만 바꾸면 순서 변경이 가능해 진다.

- 변경이 자주 일어나고, 임의 접근 방식도 필요하다면 트리 혹은 해시 테이블을 사용하는 것이 좋다.

### 2-8. 트리
- 트리는 노드 마다 어떤 값을 가지고 있고, 0 혹은 그 이상의 다른 아이템을 가진 계층형 데이터 구조이다.
- 트리의 루트는 조금 특별한데, 루트를 가리키는 노드는 없다.
- 트리는 종류가 여러가지가 있다.
- 문장 혹은 프로그램의 문법을 담아내는 **파스 트리 (parse tree)**, 족보 등도 트리로 표현이 가능하다.

`이진 검색 트리 (binary search tree)`
- 이진 검색 트리는 노드 마다 두 링크를 가진다.
- 또한 만들기도 쉽고, 트리의 중요한 특징을 모두 가지고 있다.
- 노드는 값 하나와 자식을 가지는 두개의 포인터를 가진다.
- 노드의 자식이 두개보다 적을 경우 포인터가 널 일 수 있다.
- 이진 검색 트리는 노드가 가진 값이 트리의 모양을 결정한다.
- 노드의 왼쪽에 있는 모든 자식은 해당 노드보다 값이 적어야 하며 오른쪽은 반대로 값이 커야 한다.

> 이러한 특성 때문에 리스트나 배열에서 O(n) 연산들이 트리에서는 O(logn) 만큼 걸린다.

루트 부터 모든 리프 노드 까지 길이가 거의 비슷한 트리를 **균형 트리 (balanced tree)** 라고도 한다.

> 트리의 균형을 보장해주는 트리를 만드는 것은 어렵기 때문에 트리의 종류가 많은 것이다.

`트리를 순회하는 방법`
- 중위 순회법
  - 왼쪽 하위 트리를 방문 한 뒤 해당 노드에 대한 연산을 수행한 뒤 오른쪽 하위 트리를 방문하는 방식
- 후위 순회법
  - 자식들을 모두 방문한 뒤 현재 노드에 대한 연산을 수행하는 방식
- 전위 순회법
  - 거의 사용되지 않음..

### 2-9 해시 테이블
- 해시 테이블은 컴퓨터 과학의 위대한 발명품 중 하나이다.
- 배열, 리스트, 수학 지식을 합쳐 만들었으며 동적인 데이터를 저장 / 넣고 빼기에 효과적인 데이터 구조
- 일반적으로 심벌 테이블을 관리할때 사용한다.
- 심벌 테이블은 동적인 키와 어떤 값을 연결해둔 테이블이다.
- 해시 테이블의 핵심은 **해시 함수** 를 사용해 적절하게 균등하게 분포되는 해시 값를 만드는 것이다.
  - 이는 결정적(deterministic) 이어야 하고, 빠르고 균일하게 분산되어야 한다.

### 2-10. 정리
- 알고리즘을 선택할 때는 여러단계를 거쳐야 한다.
- 알고리즘과 데이터 구조들을 평가 한뒤 처리해야할 데이터 양이 얼마나 많을지 예측해야 한다.
- 데이터양이 크지 않다면 간단한 기법을 사용하는 것이 좋다.
- 가능하다면 라이브러리 혹은 언어에서 기본적으로 제공하는 기능을 사용해야 한다.

## 3. 설계와 구현
- 프로그램을 만들 때 가장 중요한 것은 데이터 구조의 설계이다.
- 데이터 구조를 만들었다면, 알고리즘은 바로 결정이 가능하고 그에 따른 코드 작성도 비교적 쉽다.

### 3-1. 마르코프 체인 알고리즘
- 이 알고리즘은 각 어구를 여러 단어로 된 **접두사** 와 한 단어로 이뤄진 접미사로 나눈다.
- 또한 주어진 접두사에 대해 통계적 특성에 따라 선택한 접미사를 만들어 낸다.

### 3-2. 데이터 구조 후보들
- 일반적으로 책 한권 정도 분량을 입력한다면 십만 단어 이상의 입력을 처리할 수 있도록 만들어야 한다.
- 또한 초단위 수준에서 프로그램 실행이 완료되어야 한다.
- 마로코프 알고리즘은 출력을 만들기전 입력 데이터를 모두 검토하기 때문에 **전체 입력을 모두 저장** 해야 한다.
- 한 접두사와 여기에 딸린 여러 접미사를 표현할 데이터 구조가 필요하다.
  - 접두사를 **키** 로 사용하고, 접미사 목록을 **값** 으로 사용하는 해시 테이블이 필요하다.

### 3-3. C 에서 구현하기

### 3-4. 자바에서 구현하기
- 객체지향 언어를 사용할 때는 컴포넌트 사이의 인터페이스에 관심을 기울여야 한다.
- 자바는 C 보다 라이브러리가 풍부해서 여러 오브젝트들을 다양한 방법으로 관리할 **컨테이너 클래스** 들을 제공한다.
- 자바로 작성한 프로그램은 C 보다 크기가 작으며 신경쓸 부분도 적다.
- 하지만 모든것을 알아서 다 해주는것은 아니라는 것을 명심해야 한다.

### 3-5. C++

### 3-6. Awk 와 펄

### 3-7. 성능

### 3-8. 교훈
- 고수준 언어로 만들 프로그램이 저수준 언어보다 만들것 보다 느린 경향이 있다.
    - 이는 절대적인 것은 아니고 항상 그렇지도 않다.
- C++ STL 처럼 큰 컴포넌트나 스크립트 언어가 제공하는 결합 배열과 문자열 처리는 코드길이를 줄여주고 개발 시간도 단축시켜 준다.
    - 물론 성능이 떨어지는 대가를 치러야 한다.
- 단순한 알고리즘과 데이터 구조 선택이 중요하다.
- 사용할 알고리즘에 대한 지식을 토대로 데이터 구조를 상세하게 설계하는 것이 가장 좋다.

## 4. 인터페이스
- 설계의 핵심은 서로 대립하는 목표와 제약 사이에서 균형을 잡는 것이다.
- 설계 단계에서 다뤄야할 문제
  - 인터페이스
      - 서비스 제공자와 서비스 사용자 사이의 계약
      - 일관성이 있으며 편리하면서도 무겁지 않으며 쉽게 사용할 수 있어야 한다.
  - 정보 은닉
      - 각 컴포넌트에 이르는 분명한 접근 경로를 제공해야 한다.
      - 세부 구현에 대한 정보는 숨겨야 한다.
  - 자원 관리
      - 메모리 공간 할당 및 해제나 공유 정보들의 관리 문제
  - 에러 처리
      - 누가 에러를 감지하고 누가 보고할 것인가 ?

### 4-1. 콤마 구분값
- **CSV (Comma-Separated-Values)** 는 표 형식의 자료를 표현하기 위하 자연스럽게 널리 쓰이는 표현 방식을 가리키는 용어
- 각 열은 텍스트 한줄이 되며, 각 필드는 콤마로 구분한다.

### 4-2. 프로토타입 라이브러리
- 좋은 라이브러리 설계 또는 좋은 인터페이스 설계는 한번에 이뤄지지 않는다.
- 프레드 브룩스의 말을 빌리면 "한 번은 버릴 마음을 먹어라." 라는 말이 있다.
- 예전에는 오랜시간 충분한 설계를 한뒤 개발을 진행하는 방식이 전통적인 개발 방식 이었다.
- 하지만 요즘은 **애자일 (Agile)** 방법론을 따른다.
- 빠른 피드백 사이클을 통해 점진적으로 더 좋은 소프트웨어를 만든다.

### 4-3. 다른 사람이 쓸 수 있는 라이브러리
- 다른 사람이 쓸 수 있는 라이브러리를 만들려면 인터페이스, 정보 은닉, 자원 관리, 에러 처리를 고려해야 한다.

`인터페이스`
- csvgetline (csv 파일 한줄을 읽는 함수) 는 어떤 값을 리턴해야 하는가 ?
  - 필드의 개수가 될 수도 있고, 입력 줄의 길이가 될 수도 있다.
- 원 입력줄을 가리키는 포인터를 리턴하고, 파일의 끝에 다다랐을 경우에는 NULL 을 리턴한다.
- csvfield (csv 의 필드를 가져오는 함수) 가 존재하지 않는 필드를 요청할 경우 어떤 값을 리턴해야 하는가 ?
  - 빈 문자열을 리턴할 수도 있다.
  - 하지만 이경우 필드가 빈 경우인지, 존재하지 않는 필드인지 구분할 방법이 없다.
  - 에러 메세지를 출력하거나 중단 시키는 방법도 존재하지만 바람직한 방법이 아니다.
- NULL 을 리턴하기로 한다. (C 언어에서 관습적으로 사용하는 값)

`정보 은닉`
- 우리가 만든 라이브러리는 입력줄의 길이나 필드 개수에 대해 제한을 두지 않는다.
- 호출자 혹은 피호출자중 하나가 메모리를 할당해서 제공해야 한다.
- 만약 피호출자가 관리하게끔 결정했다면 오직 csvgetline 함수 만이 메모리 관리에 대해 알아야 한다.
- 이 함수가 메모리를 어떻게 사용하는지 밖에서는 간섭할 수 없다.

`자원 관리`
- 누가 공유 정보를 책임질지 정해야 한다.
- 원본 데이터를 리턴할지, 복사본을 만들지 말이다.
- 누가 입력 파일을 열고 닫을지도 정해야 한다.
- 파일을 여느놋이 어디든 열었으면 반드시 닫아야 하며, 한쌍으로 같은 작업수준, 같은 위치에서 이루어 져야 한다.
- 파일을 피호출자에서 열고 닫는것은 호출자에서 이뤄지거나 하는 이런 일이 발생해서는 안된다.

`에러 처리`
- 원칙적으로 라이브러리 루틴은 에러가 났을때 그냥 죽어버리면 안된다.
- 호출자가 적절한 동작을 취할 수 있도록 에러 상태를 리턴해야 한다.

`명세서`
- 앞에서 내린 결정을 모아 서비스 목록과 사용법을 설명한 명세서를 만들어야 한다.
- 대규모 프로젝트의 경우 명세서 작성이 궇녀보다 먼저 이루어 진다.
- 하지만 현장에서 병렬적으로 진행되고 명세서와 코드가 같이 개발된다.
- 가장 좋은 방식은 명세서를 일찍 작성한 뒤, 구현하면서 변경되는 사항들을 게속 갱신하는 것이다.
- 더 정확하고 더 신중할수록 프로그램 완성도가 높아질 가능성이 높다.

### 4-4. 인터페이스 원칙
- 인터페이스는 서비스를 제공하는 코드와 서비스를 이용하는 코드 사이의 정교한 경계선이 된다.
- 인터페이스가 널리 사용되기 위해서는 그 목표에 잘 어울려야 한다.
- 단순하고, 범용적이며 규칙적이고 결과를 예상할 수 있어야 하며 튼튼해야 하고 기능 구현부분이 바뀌면 자연스레 바뀌어야 한다.
- 좋은 인터페이스는 원칙을 따른다.

`구현의 세부 사항을 숨겨라`
- 인터페이스 뒤에 존재하는 구현된 코드는 이를 숨겨야 한다.
- 정보은닉, 캡슐화, 추상화, 모듈화 라고 불린다.
- 인터페이스는 사용자와 관련이 없는 구현에 관한 내용을 숨겨야 한다.
- **전역 변수 사용을 피해야 한다. 가능하다면 필요한 데이터는 함수 인자로 전달 받아라.**

> 어떤 형태든 데이터를 공개적으로 열어서는 안된다. \n
> 사용자가 변수를 마음대로 변경할 수 있따면 일관성있게 유지하기가 힘들어진다.

- C++ 과 자바의 클래스는 정보를 은닉하기 위해 발전된 메커니즘이자 언어의 핵심 기능이다.

`서로 겹치지 않게 기본 항목을 선택하라`
- 인터페이스는 딱 필요한 만큼의 기능만 제공해야 한다.
- 또한 지나치게 중첩되서는 안된다.
- 편의성을 위해 같은 일을 수행하는 방법을 여러개 제공하는 경우도 있는데 이는 피해야 한다.
  - C 의 표준 입출력 라이브러리는 츌력 스트림에 문자 1개를 쓰는 함수를 4개 이상 제공한다..
  
`사용자가 모르는 곳에서 일을 꾸미지 말라`
- 라이브러리 함수는 비밀 파일이나 변수를 만들어 사용한다거나 전역 데이터를 변경해서는 안된다.
- 호출자가 전달한 데이터를 수정하는 일도 피해야 한다.
- 단일 인터페이스를 사용할 때 해당 인터페이스 설계나 혹은 구현자의 편의를 위해 또다른 인터페이스를 만들어야 하는 일이 있어서는 안된다.

`어디서나 같은 일은 같은 방식으로 처리하라`
- 일관성과 규칙성은 중요하다.
- 비슷한 것들은 비슷한 수단으로 취해야 한다.
- C 언어 라이브러리의 기본적인 함수들은 문서가 없어도 사용하기 쉬운데 그 이유는 거의 모두 같은 방식으로 동작하기 때문이다.
- 외부에 대한 일관성, 즉 다른 것과 비슷하게 작동하는 일관성도 목표가 되어야 한다.

> 인터페이스를 잘 설계하는 데에도 한계는 있다. \n
> 오늘은 최고의 설계 였더라도 내일은 문제가 될 수 있다.

### 4-6. 자원 관리
- 라이브러리의 인터페이스를 설계할 때 가장 어려운 점은 라이브러리가 소유하거나 호출자와 공유하는 자원을 관리하는 문제이다.
- 이는 초기화, 상태 유지, 공유와 복사, 자원 해제의 문제로 분류할 수 있다.

`자원을 결자 해지하라`
- 자원 할당 및 해제를 제어하는 방법 중 하나는 동일한 라이브러리, 패키지, 인터페이스를 사용해서 자원을 할당한 곳에서 해제까지 책임 지게 하는 것이다.
- 어떤 자원을 할당하고 해제하는 동작이 인터페이스를 넘나들며 일어나선 안된다.

### 4-7. 중단, 재시도, 실패?
- 자신에게만 필요한 함수를 작성하는게 아니라 다른사람을 위해 라이브러리를 만든다고 생각하고 설계를 해야 한다.
- 에러 메세지를 출력하고 죽는 방법은 소규모 애플리케이션에서는 괜찮은 방법일 수도 있지만, 복구 가능성을 없애 버리기 때문에 좋은 방법이 아니다.
- 진단 내용을 담은 출력을 별도의 **로그 파일** 에 저장하라.
- 다른 프로그램에 영향을 최소화 하며 따로 열어 볼 수 있으므로 독립적인 모니터링이 가능하다.

`에러는 저수준에서 잡고, 고수준에서 처리하라`
- 일반적으로 에러는 가능하다면 **낮은 수준에서 잡고, 높은 수준에서 처리해야 한다.**
- 대부분의 경우 호출자가 에러를 어떻게 처리할지 결정한다.

`예외적 상황에서만 예외 처리를 하라`
- 몇몇 언어는 비정상적 상황을 감지하고 해당 상황을 벗어나기 위해 예외 매커니즘을 젝ㅇ한다.
- 이를 이용해 제어 흘므을 다른데로 돌릴 수 있다.
- 문제 해결을 하면서 리턴 값을 처리해야할 떄 예외를 사용해서는 안된다.
- 예외는 제어 흐름을 건들이기 떄문에 쉽게 남용될 수 있으며 버그가 발생하기 쉽게 구조가 꼬일 수 있다.

> 정말 예외적인 경우를 대비해 예외를 아껴야 한다.

## 5. 디버깅
- 좋은 프로그래머는 코드 작성에 쓰는 시간가 비슷한 시간을 디버깅에 쏟으며 실수에서 배움을 얻으려고 한다.
- 디버깅은 힘든 작업이고 많은 시간이 소요될 수 있기 때문에 디버깅할 상황을 만들지 않는 것을 목표로 삼아야 한다.
- 디버깅 시간을 줄여주는 기술에는 좋은 설계, 좋은 스타일, 경계 조건 테스트, 단정문, 코드의 정상성 체크, 방어적 프로그래밍, 잘 설계된 인터페이스, 한정된 전역데이터, 검사 도구가 있다.
- 프로그래밍 언어를 진화시킨 동력중 하나는 언어 자체의 기능을 통해 버그를 예방하는 것이다.
- 인덱스를 이용한 범위 검사, 포인터를 제한적으로 사용 / 아에 사용하지 않는 언어 가비지 컬렉션, 문자열 타입, 엄격한 타입 검사 등이 있다.
- 고수준의 언어를 쓰면 단순한 버그가 사라지지만 고수준의 버그가 생기기 더 쉽다. 세상 어떤 언어도 휴먼 에러를 방지해 줄수는 없다.

### 5-1. 디버거
- 적절한 환경에서 숙련된 사용자가 사용하는 경우 좋은 디버거는 효율적이고 효과적인 디버깅을 도울 수 있다.
- 하지만 비주류 언어들은 디버거가 존재하지 않는 경우도 있으며 원시적인 디버깅 기능만 제공하는 경우도 존재한다.
- 디버거는 시스템 의존적이기 때문에 다른 시스템에서 작업할 경우 익숙한 디버거를 사용할 수 없다.
- 운영체제, 분산형 시스템은 더 저수준의 접근 방식으로 디버깅 해야한다.

### 5-2. 실마리가 뚜렷한 쉬운 버그
- 초보자는 컴파일러, 라이브러리 등 외부적인 요소를 탓하는 경향이 있다.
- 숙련자들도 같은 불평을 하지만 그들은 대부분의 문제가 자신의 실수라는 것을 알고 있다.
- 디버깅은 미궁에 빠진 사건을 해결하는 것과 비슷한 역방향 추론 개념이 포함된다.
- 결과에서 원인을 찾기 위해 역방향으로 생각해야 하는 일이 존재한다.

> 프로그램이 죽기 직전 디버깅용 출력을 확인하고, 가능하다면 디버거로 스택을 추적하라

`자주 나오는 패턴을 찾아라`
- 자주 나오는 문제 패턴인지 자문 하라.
- "예전에 본 적이 있어." 라는 것은 문제를 이해하기 시작했다는 의미이며 정답을 의미할 수도 있다.

`가장 최근에 변경한 부분을 검사하라`
- 버그는 새 코드에 있거나, 혹은 새 코드에 의해 드러났을 공산이 크다.
- 최근 변경을 주의 깊게 살펴보면 문제가 발생한 부분을 좁히는데 도움이 된다.

`같은 실수를 두 번 반복하지 말라`
- 버그를 고치면 다음에 똑같은 실수를 다른데서도 한건 아닌지 자문해 보아야 한다.
- 익숙하다고 해서 안심하면 쉬운 코드에도 버그가 생길 수 있다.

`오늘 할 디버깅을 내일로 미루지 말라`
- 프로그램이 죽었을때 무시하고 넘어지지말라.
- 손쓰기 너무 늦어지기 전 다시 발생하지 않도록 문제를 추적해야 해야 한다.

`스택 추적값을 확인하라`
- 디버거의 가장 일반적인 용도중 하나는 프로그램이 죽은 뒤 상태를 확인하는 것이다.
- 스택 추적값에서 나오는 문제가 생긴 부분의 소스 줄 번호는 가장 유용한 디버깅 정보이다.

`작성하기 전에 읽어라`
- 효과적이지만 중요성이 잘 알려지지 않는 테크닉이 코드를 읽은 뒤 한동안 생각해 보는 것이다.
- 키보드를 두드리고 싶은 열망에 저항하라. 생각하는게 가치 있는 대안이다.

`코드를 다른 사람에게 설명하라`
- 또 다른 효과적인 기법은 자신의 코드를 다른사람에게 설명하는 것이다.
- 많은 경우에 버그를 자기자신에게 설명하는 효과가 생긴다.

### 5-3. 실마리가 없는 어려운 버그

`버그를 재현할 수 있게 하라`
- 자유자재로 버그를 드러낼 수 있게 해야 한다.
- 약간 시간을 할애해서 문제를 확실하게 드러내는 입력과 매개변수 값을 마련한 뒤 버그를 재현할 수 있게 하라.

`각개격파하라`
- 문제를 발생시키는 입력의 범위를 더 좁히기 위한 좋은 방법은 버그가 나타나는 가장 작은 입력을 만들어서 가능성을 좁히는 것이다.
- 일반적으로 이진 탐색 방식을 이용해서 진행한다.

`수 가 의미하는 바를 연구하라`
- 때로는 문제를 발생시키는 숫자의 패턴이 탐색 범위를 좁힐 실마리를 주는 경우가 있다.

`결과를 출력해서 탐색 범위를 좁혀라`
- 프로그램을 이해할 수 없다면 더 많은 정보를 출력문에 추가하는게 가장 쉽고 효율적인 방법이 될 수 있다.

`자가검증 코드를 작성하라`
- 더 많은 정보가 필요하다면 조건을 테스트하고 관련된 변수값을 출력한 뒤 프로그램을 중단시키는 check 함수를 직접 작성하라.

`로그 파일을 작성하라`
- 디버깅용 고정 형식 스트림 출력을 담는 로그파일을 작성하는 것이다.
- 실행중 프로그램이 죽으면 죽기 직전 어떤 일이 발생햇는지 로그파일에 기록한다.
- 웹서버 혹은 기타 웹 프로그램은 광범위한 트래픽 로그를 남겨 자신과 클라이언트를 모니터링 한다.

`그림을 그려라`
- 테스트 및 디버깅을 할 때는 때로 글보다 그림이 더 효과적이다.
- 데이터 구조를 이해할 때, 그래픽 소프트웨어를 작성할때 특히 도움이 되지만 모든 종류의 프로그램에 활용할 수 있다.

`도구를 사용하라`
- 디버깅 환경이 제공하는 도구들을 잘 이용해야 한다.
- 예를 들면, diff 같은 파일 비교 프로그램은 디버깅용 코드를 실행할 때 문제 없는 경우와 잘못된 경우 출력을 비교해 바뀐 부분에 집중할 수 있게 해준다.

`기록하라`
- 버그를 찾고 시간이 흐르면 무엇을 시도했고, 무엇을 깨달았는지 잊어버리기 시작한다.
- 테스트와 그 결과를 기록해 두어야 한다.

### 5-4. 최후의 수단
- 위 조언들을 다 적용해도 해결되지 않을 경우 좋은 디버거를 써서 하나씩 살펴보아야 한다.
- 때로 오해는 아주 단순한 데서 비롯된다.
- 연산자 우선 순위가 잘못되었거나 연산자를 잘못 사용했거나 들여쓰기, 변수 스코프 등...
- 프로그래머들은 가끔 & 또는 | 가 == 이나 != 보다 우선순위가 낮다는걸 까먹고 버그를 알아채지 못한다.
- **'메모리 누수(leak)'** 는 더이상 사용하지 않는 메모리를 회수하지 않아 잘못된 동작을 일으키는 중요한 원인 중 하나이다.
- 메모리 누수가 있는 프로그램은 자원을 고갈시켜 원인 모를 증상을 보이는 경우도 있지만 재현도 안되는 경우가 많다.

`바이트 순서 문제`
- 2바이트 이상 데이터를 메모리에 기록할 때 어떤 번지부터 저장하는지에 따라 달라진다.
- 바이트 순서는 프로세서 표준마다 다르기 때문에 이기종간 포팅시 문제의 소지가 된다.
- Intel, Alpha 와 같은 CISC 계열 CPU 리틀 엔디안 (높은 번지 부터 기록)
- SPARC 같은 RISC 계열 CPU 는 빅 엔디안 (낮은 번지 부터 기록) 을 사용한다.

### 5-5. 재현 불가능한 버그
- 가만히 멈춰 있지 않는 버그를 잡기가 가장 어렵다.
- 하지만 증상을 정의할 수 없다는 사실 자체가 정보가 될 수 있다.
- 에러가 알고리즘에 있는게 아닌, 프로그램 실행시 바뀌는 정보를 이용하는 부분에 있을 가능성이 높다.

> 만약 디버깅용 코드를 넣자마자 버그 증상이 달라진다거나, 아예 사라진다면 메모리 할당 관련 에러일 확률이 높다.

### 5-6. 디버깅 툴
- 버그를 찾기 위해 디버거만 사용할 수 있는것은 아니다.
- 다양한 디버깅 툴킷이 존재하며 몇몇은 특별한 버그를 찾거나 특수한 프로그램을 분석하기 위한 용도로 만들어져 있다.

### 5-7. 다른 사람의 버그
- 대부분의 프로그래머는 새로운 시스템을 개발하는 것 보단 다른 사람이 만든 코드를 사용하고, 유지보수하고 수정하고 디버깅하는데 많은 시간을 쏟고 있다.
- 다른 사람의 코드를 디버깅할 때도 지금 까지의 모든 방법이 모두 적용된다.
- 타인의 프로그램에서 버그를 찾았다면, 가장 먼저 진짜 버그라는 사실을 확실히 검증해야 한다.
- 기존에 알려지지 않은 버그인지 확인하라.
- 사용하는 것이 최신 버전인지 ? 버그픽스 가 된건 아닌지 확인해 보아야한다.

### 5-8. 정리
- 올바른 태도로 임한다면 디버깅은 퍼즐을 푸는 것 처럼 재밌지만, 디버깅은 하나의 기술이며 정기적으로 계속 수행하게 된다.
- 하지만 중요한 것은 처음부터 코드를 제대로 작성해 버그를 없애도록 노력해야한다.
- 잘 작성된 코드는 처음부터 버그가 적고, 있는 버그도 찾아내기 쉽다.

## 6. 테스트
- **테스트는 제대로 돌아간다고 생각되는 프로그램을 의도적이고 체계적으로 망가뜨려보는 시도**
- 에처 다익스트라가 관찰했듯이 테스트는 버그가 존재함을 보여 줄 수 있지만 부재함을 보여줄 수 없다.

### 6-1. 코딩하면서 테스트하기

`경계에서 테스트하라`
- **경계 조건 테스트 (boundary condition testing)** 기법
- 코드를 조금씩 작성할 때 마다 조건 분기가 제대로 동작하는지, 루프가 적절하게 반복하는데 검사한다.
- 경계 조건 테스트라고 불리는 이유는 프로그램에 있는 태생적인 경계를 점검하기 때문이다.
- 대부분의 버그는 경계에서 발생하는 데서 착안한 것이다.

> 경계 조건 검사는 **오프바이원 (off-by-one) 에러** 를 찾는데 효과적이다.

`사전.사후 조건을 테스트하라`
- 어떤 코드가 실행되기 전 (사전조건)과 후 (사호조건) 을 검증하는 것이다.
- 입력값이 특정 범위 안에 들어오는지 확인한느 것은 사전조건 테스트의 흔한 예이다.

`단정문을 사용하라`
- C 와 C++ 은 assert.h 를 통해 사전조건 테스트와 사후조건 테스트를 넣을 수 있는 **단정문 (assertion)** 기능을 제공한다.
- 단정문이 실패한다면 프로그램이 중단되기 때문에 보통은 예상치 못한 문제가 생겨서 회복할 방법이 없는곳이 아니라면 자제해야 한다.
- 단정문은 특히 인터페이스 검증시 유용하다.

`방어적으로 프로그래밍 하라`
- '일어날리 없는' 경우나 그런 상황을 처리하는 코드를 추가해 두는 것도 쓸만한 기법이다.
- 논리적으로 불가능하지만 생길 수도 있는 상황이라는 뜻이다.
- 이는 프로그램을 오용하는 경우나 잘못된 데이터가 들어온 경우에도 프로그램이 버틸 수 있게 보호하는 것이다.

`리턴 값을 검사하라`
- 자주 경시되는 방어책이 라이브러리 함수나 시스템 콜 리턴값을 검사하는 것이다.

> 개발하는서 하는 테스트는 최소한의 노력으로 후한 결과를 가져다 준다. \n
> 프로그램을 작성하면서 동시에 테스트를 생각하면 더 나은 코드가 나온다.

### 6-2. 체계적인 테스트
- 각 단계마다 어떤 것을 테스트하는지, 어떤 결과가 나와야 하는지 확실히 인식할 수 있게 체계적으로 테스트 하는 것이 중요하다.

`점층적으로 테스트하라`
- 프로그램을 모두 작성한 뒤 한꺼번에 테스트하는 **빅 뱅** 식의 접근 방식은 점층적인 접근 방식보다 어렵고 시간도 더 많이 잡아먹는다.

`단순한 부분을 먼저 테스트하라`
- 점층적 접근 방식은 기능 테스트시에도 적용된다.
- 가장 단순하면서 일반적으로 실행되는 기능에 먼저 집중해야 한다.
- 쉬운 테스트는 쉬운 버그를 잡는다.

`어떤 결과가 나와야 하는지 알라`
- 모든 테스트에서 정답이 무엇인지 아는 것은 필수적이다.
- 만약 그것을 모른다면 시간 낭비일 뿐이다.
- 프로그램에 역 (inverse) 이 있다면 입력한 값을 되돌릴 수 있는지 확인하라.

`보존 속성을 검증하라`
- 많은 프로그램은 입력의 특정 속성들을 보존한다.
- wc, sum 과 같은 체크 툴은 결과가 같은 크기, 같은 단어 수, 같은 바이트를 특정 순서대로 갖고 있는지 등을 검증한다.

`독립적인 구현 버전을 비교하라`
- 라이브러리나 프로그램의 독립적인 구현 버전을 비교하면 같은 답이 나와야 한다.

`테스트 범위를 축정하라`
- 테스트의 목표 중 하나는 테스트하는 동안 프로그램의 모든 명령문 하나 하나를 실행하는 것이다.
- 최소 한번 이상 테스트를 통과하지 않은 코드가 남아 있다면 테스트 단계가 완벽하다고 할 수 없다.

### 6-3. 테스트 자동화
- 테스트는 사람과 달리 질리지도 않고 한눈을 파는 일도 없는 프로그램을 통해 수행해야 한다.
- 모든 테스트를 캡슐화 한 스크립트 / 단순화한 프로그램을 작성해 완전한 테스트 집합을 전부 버튼 한 개만 눌러 실행 가능하게 만들수 있다면 충분히 투자할 가치가 있다.

`회귀 테스트를 자동화하라`
- 자동화의 가장 기본적인 형태는 **회귀 테스트 (regression testing)** 이다.
- 이는 새 버전가 이전 버전을 비교하는 일련의 테스트를 수행하는 것이다.
- 회귀 테스트의 목적은 대상의 동작 방식이 예상 외의 방식으로 변하지 않았다는 것을 확인하는 것이다.
- 이는 **이전 버전이 정확한 답을 낸다는 것** 을 기본 가정으로 삼는다.

`자급자족형 테스트를 창조하라`
- 필요한 입력과 예상되는 출력까지 포함한 자급자족형 테스트는 회귀 테스트를 보완해 준다.

> 절대 테스트를 없애지 말라. 버그리포트가 유효한지 확인하거나 고친 문제를 기록하는 용도로 사용할 수 있다.

### 6-4. 테스트 작업발판
- 컴포넌트를 독립적으로 테스트하기 위해선 테스트가 돌아갈 때 시스템의 다른 부분에 대한 인터페이스를 제공하고, 그 외 역할을 하는 프레임워나 작업발판을 필수로 만들어야 한다.
- 다른 모든 테스트 방법처럼 테스트 작업발판에도 테스트 대상 연산을 검증하기 위한 정답이 필요하다.

### 6-5. 부하 테스트
- 컴퓨터가 생성하는 대량의 입력도 효과적인 테스트 기법이다.
- 이는 사람이 작성한 입력과 다른 차원의 부하를 준다.
- 하지만 정말 현실에서는 일어나기 힘들어서 고쳐봤자 별로 효과가 없는 문제를 찾아내게 되는 경우도 존재한다.

### 6-6. 테스트 팁
- 경험이 많은 테스트 인력은 업무를 생상적으로 하기 위한 비결과 테크닉을 많이 사용한다.
- 상수 하나를 리턴하는 해시 함수를 만들어 모든 원소를 같은 해시 버킷에 넣는다.
- 이는 최악인 경우의 성능을 측정할 수 있다.
- 테스트 케이스를 다양하게 만들어야 한다.
- 똑같은 것만 테스트하다보면 같은 곳만 맴돌다가. 다른데서 문제가 발생해도 알아차리지 못할 가능성이 높다.
- 알려진 버그가 있다면 새 기능을 구현하거나, 이미 존재하는 것들도 테스트해서는 안된다.
  - 이런 행동이 테스트 결과에 영향을 줄 수 있다.
- 테스트 출력은 모든 입력 매개변수 설정을 포함해야 한다.
  - 해당 테스트를 똑같이 재현할 수 있어야 한다.
- 프로그램 실행시 출력을 어느정도 제어할 수 있는 방법을 마련해야 한다.
  - 추가적인 정보를 출력하면 테스트가 쉬워진다.
- 여러 컴퓨터, 컴파일러, 운영체제 등 다양한 환경에서 테스트한다.

### 6-7. 누가 테스트하는가
- 개발자 혹은 소스에 접근 가능한 사람이 테스트 하는것을 **화이트박스 테스트 (white box testing)** 이라고 한다.
- 블랙박스 테스트에서 나온 용어이다.
- 별도의 테스트 조직이나 사용자가 자신을 위해 뭔가를 찾아 줄 것이라고 생각하지 말라.
- 자신이 얼마나 철저하게 테스트하는지 자만하기 쉽기 때문에 코드에 대해서 어려운 케이스를 생각하라.

> 테스트를 하는 이유는 버그를 찾기 위한 것이지, 프로그램이 잘 돌아간다고 주장하기 위한 것이 아니다.
> 테스트는 깐깐해야 하고 문제를 찾는다면 테스트를 잘했다는 것이지 두려워하거나 걱정하지 말라.

- 블랙박스 테스트는 테스터가 코드에 대해 전혀 모르거나 접근할 방법이 없는 것이다.
- 이런 테스트는 전혀 다른 관점에서 생각하기 때문에 또 다른 성격의 에러를 찾아낼 수 있다.

### 6-8. 정리
- 처음 부터 코드를 잘 작성할 수록 버그는 더 적고, 개발자도 더 자신감을 얻을 수 있다.
- 코딩하면서 경계 조건을 테스트하는 것은 많은 실수성 버그를 제거하는 효과적인 방법이다.
- 가능한 테스트를 자동화 하는것이 좋다.

> 테스트에서 무엇보다 중요한 규칙은 **테스트를 하는것** 이다.
 
## 7. 성능
- 옛날 프로그래머들은 프로그램을 효율적으로 짜기 위해 노력해야 했다.
- 하지만 오늘은 컴퓨터의 성능이 훨씬 좋아지고 저렴해졌기 때문에 절대적인 필요성은 확실히 줄었다.
- 그렇다고 성능에 대한 문제를 아에 배제해야 하는건 아니다.
- 최적화의 첫 번째 법칙은 **하지 않는다.** 
- 이미 괜찮은 퍼포먼스를 내고 있다면 더 빠르게 만들었을때 어떤 이익이 있는지를 먼저 생각해야 한다.
- 최적화를 위한 가장 좋은 전략은 가장 단순하면서 가장 분명한 알고리즘 / 자료구조를 선택하는 것이다.
- 성능 측정은 개선에서 가장 중요한 부분이다.
- 추론과 직관 보다는 시간 측정을 위한 명령어 및 프로파일러와 같은 툴로 보완해야 한다.
- 성능 개선은 테스트와 통하는 부분이 많으며, 자동화 / 철저한 기록 유지 / 회귀 테스트 등 같은 테크닉을 사용할 수 있다.

### 7-1. 병목현상
- 메일을 예로 들면, 메일은 게이트웨이라는 내부 / 외부 네트워크를 연결하는 컴퓨터를 통과해 들어온다.
- 이런 게이트웨이가 제공하는 서비스 중 하나는 **스팸을 걸러내는것** 이다.
- 게이트웨이의 성능이 충분하지 않다면, 이는 병목지점이 될 수 있다.
- 가장 중요한 것은, **성능이 정말 중요한 것인지 확인하는 것** 이다.

### 7-2. 시간 측정과 프로파일링

`시간 측정을 자동화 하라`
- 대부분의 시스템에는 프로그램 수행시간을 측정하는 명령어가 있다.
- Unix 의 경우 time 명령어가 존재한다.

```shell
%   time  slowprogram
    real  7.0
    user  6.2
    sys   0.1
    %
```
- 위 결과는 모두 **초 단위** 이다.
- real : 프로그램이 완료되기 까지 **경과 시간**
    - 경과시간 (elapsed time) : 시계 시간이라 표현하기도 한다. CPU 시간에 프로세스를 올리고 내리는 시간이다. 동기화/입출력/통신 등에 소비되는 시간을 모두 포함한다.
- user : 프로그램이 실행되는데 소비된 **CPU 기준 시간**
- sys : 프로그램 실행을 위해 **OS 에서 소비된 CPU 시간**

> 컴퓨터가 테스트 집합을 실행하고 결과를 측정하게 하라 \n
> **회귀 테스트** 를 통해 수정한 내용이 영향을 미치진 않았는지 계속 점검해야 한다.

`프로파일러를 사용하라`
- **프로파일러 (profiler)** 는 어떤 프로그램이 어디에서 시간을 소비하는지 측정한다.
- 각 함수의 목록 / 각 함수가 호출된 횟수 / 각 함수가 소비한 실행시간의 비율 등이 포함되어 있다.
- 프로파일링은 프로그램에서 **과열 지역 (hot spots)**, 대부분의 시간을 소비하는 함수나 코드를 찾아내는데 효과적이다.
- 하지만 프로파일에 나온 통계는 **근사치** 라는 것을 유의해야 한다.

> 1971년, 도널르 커누스는 프로파일링을 소개한 논문에서 다음과 같이 썻다. \n
> "보통 프로그램의 4퍼센트 이하 부분이 프로그램 실행시간의 대부분을 차지한다."

`과열지역에 집중하라`
- 대개 과열지역은 스팸 필터 사례에서 수행한 것 보다 훨씬 단순한 방법을 통해 제거하거나 최소한 식히는게 가능하다.

`그림을 그려보라`
- 그림은 성능이 어느 정보인지 표현하기에 좋다.
- 매개변수 변경 효과나 알고리즘과 데이터구조 비교도 가능하며 예상치 못한 동작 방식까지 보여준다.

### 7-3. 속도를 위한 전략
- 프로그램 최적화를 하기 위해 정말 그 프로그램이 느린것인지 확인해야 한다.
- 시간 측정 툴과 프로파일러를 이용해 어디서 시간이 소비되는데 찾아야 한다.

`더 나은 알고리즘이나 데이터 구조를 사용하라`
- 최적화의 가장 중요한 요소는 알고리즘 과 데이터 구조의 선택이다.
- 복잡성이 기대했던 것만큼인지 확인하라.
- 만약 그렇지 않다면 잠재적인 성능문제가 있을 수 있다.

`컴파일러 최적화 기능을 켜라`
- 노력이 들지 않으면서 상당한 개선을 가져다주는 변경 작업이다.
- 컴파일러의 최적화는 보통 실행시간을 몇 퍼센트 에서 두 배 정도까지도 개선할 수 있다.
- 하지만 때로는 오히려 더 느리게 만들기도 하기 때문에 반드시 측정이 필요하다.
- 한 가지 주의할 점은 **컴파일러가 공격적으로 최적화 할수록 컴파일된 프로그램에 버그를 초래할 가능성이 높아진다** 는 것이다.

`코드를 미세조정하라`
- 데이터 크기가 어느정도 된다면 알고리즘을 제대로 선택하는 것이 중요하다.
- 정확한 알고리즘을 사용했음에도 속도가 문제된다면 **코드의 미세조정 (tuning)** 을 시도해야 한다.

`중요하지 않은 것은 최적화하지 말라`
- 가끔 튜닝을 했음에도 효과가 없을때가 있는데, 이는 아무 효과가 없을 부분을 튜닝한 것이다.
- 최적화 대상이 정말 시간을 소비하는 부분인지 확인해야 한다.
- **운영체제의 휴지 루프 (idle loop)** 를 최적화 하는 일과 같은 일은 없어야 한다.
    - **휴지 루프 (idle loop)** 는 구동시킬 사용자 프로그램이 없을때 아무것도 하지 않는 루프에 들어가 있는데, 이를 휴지루프 라고 한다.

### 7-4. 코드 미세조정
- 과열지역을 찾았을때 최적화하는 기법은 많다.
- 모두 조심스럽게 적용해야 하며, 적용한 뒤에는 회귀테스트를 통해 코드가 계속 제대로 동작하는지 확인해야 한다.
> 무엇을 시도하든, 매번 측정해 그게 정말 도움이 되는지 확인해야한다.

`공통된 부분 표현식을 하나로 모아라`
- 비싼 계산 작업 한 개가 여러번 반복된다면, 한군데에서만 수행하고 결과를 기록해야 한다.

`비싼 연산을 싼 연산으로 대체하라`
- **연산강도의 감축 (reduction in strength)** 는 비싼 연산을 싼 연산으로 대체하는 최적화를 의미한다.
- 옛날에는 곱센 연산을 덧겜 혹은 시프트 연산으로 대체하는것을 의미했지만 요즘은 별 효과가 없다.
- 하지만 나눗셈과 나머지 연산을 곱셈보다 훨씬 느리므로 나눗셈을 곱셈의 역 역산으로 대체한다던가 나누는수가 2의 승수일때 마스킹 연산으로 대체하는 등 을 이용하기도 한다.

`루프를 펼치거나 제거하라`
- 루프를 준비하고 실행하는 데도 분명히 오버헤드가 존재한다.
- 루프 본문이 많이 길지 않거나 많이 반복되지 않는다면 각 반복주기 내용을 쭉 작성하는게 효율적일 수도 있다.

`빈번히 사용되는 값을 캐싱하라`
- 값을 캐싱한다면 다시 계산할 필요가 없다.
- 캐싱은 지역성, 즉 프로그램이 오래되고 먼 데이터보다 최근에 쓴 가까운 데이터를 재사용하는 경향을 이용하는 것이다.
- 컴퓨터 하드웨어는 캐싱을 광범위하게 이용한다.
- 캐시 메모리를 증설하면 겉으로 드러나는 속도향상이 상당하며, 소프트웨어에도 동일하게 적용된다.

`특수한 메모리 할당 함수를 작성하라`
- 프로그램의 유일한 과열지역이 malloc 혹은 new 를 많이 호출하는 메모리할당 부분인 경우가 많다.
- 대부분의 메모리 요청이 같은 블록 크기로 들어온다면 범용 메모리 할당 함수 호출부분을 특수 할당 함수로 대체하면 상당한 속도 개선을 꾀할 수 있다.

`입력과 출력을 버퍼링 하라`
- **버퍼링 (buffering)** 을 하면 트랜잭션들을 모아 한번에 처리하기 때문에 잦은 연산을 가능한 한 적은 오버헤드로 수행할 수 있다.

`특수한 경우를 따로 처리하라`
- 같은 크기의 객체들을 벼도 코드에서 처리하면, 범용 메모리 할당 함수의 시간 및 공간 오버헤드를 특수 메모리 할당함수를 통해 줄일수 있고, 조각화 비율도 줄일 수 있다.

`결과를 사전계산하라`
- 값을 사전계산해서 필요할 때 바로 쓸 수 있게 준비해 두면 프로그램을 더 빠르게 만들 수 있는 경우가 있다.
- 코드를 데이터로 대체하거나 컴파일할 때 계산을 해놓아서 시간을 절약하고 때로는 공간까지도 절약할 수 있는 경우가 많다.

`근사값을 사용하라`
- 정확성이 중요하지 않은 경우 정밀도가 더 떨어지는 데이터타입을 사용한다.
- 오래됬거나 소규모 시스템 에서 부동소수 시뮬레이션시 대개 **단정밀도 (single-precision)** 부동 소수를 사용 하는것이 배정밀도 타입을 사용하는 것 보다 빠르다.
- 때문에 double 보단 float 을 사용해 시간을 절약한다.

`저수준 언어로 재작성하라`
- 저수준 언어일수록 더 효율적인 경향이 있다.
- 특정 프로그램의 부분을 컴파일된 언어로 대체하면 수행 속도가 상당히 빨라질 수 있다.
- 하지만 이는 최후의 수단으로 선택해야 한다.
- 이는 호환성을 파괴하고 유지보수와 수정을 훨씬 어렵게 만든다.

### 7-5. 공간 효율성
- 예전에 비해 시대는 변했고, 메인 메모리와 보조 기억장치 모두 믿을수 없을 정도로 저렴해 졌다.
- 공간 최적화에 접근하는 제 1방침은 속도개선가 마찬가지로 **신경쓰지 않는다.** 이다.

`최소 데이터 타입을 사용해 공간을 절약하라`
- 공간 효율성을 얻는 방법중 하나는, 이미 있는 메모리를 더 잘 사용하기 위해 소규모 변경을 하는것이다.
- 가능한 최소 데이터 타입을 사용하는 것

`쉽게 재계산할 수 있는 값을 저장하지 말라`

### 7-6. 추정
- 프로그램이 얼마나 빨라질 지 미리 추정하는 것은 어려운 일이다.
- 하지만 한 언어나 한 시스템에서 **비용 모델 (cost model)** 을 구축하는 것은 쉬운일이며, 대략적으로 개념 정도는 잡아줄 수 있게 해준다.
- 프로그래밍 언어에서 자주 사용되는 접근 방식은 대표적인 코드 순열의 시간을 재는 방식이다.

### 7-7. 정리
- 올바른 알고리즘을 선택했다면, 성능 최적화란 보통 프로그램을 짜면서 제일 나중에 걱정할 만한 수준의 문제가 된다.
- 그래도 만약 최적화를 해야한다면 우선 측정하고, 조금의 변경으로 큰 차이를 만들 수 있는 부분에 집중한뒤 검증하고, 다시 측정하기를 반복하는 것이다.

# 이벤트 기반 마이크로 서비스 구축

## 1. 왜 이벤트 기반 마이크로서비스인가 ?
- 매클루언은 인류에게 영향을 주고 사회를 근본적으로 변화하게 만드는 것은 미디어 콘텐츠가 아닌 **미디어에 참여하는 것** 이라고 주장한다.
- 컴퓨터 시스템 아키텍쳐도 이와 동일하다.
- 네트워크 통신, RDB, 빅데이터 개발, 클라우드 컴퓨팅이 아키텍쳐를 구축하고 작업을 수행하는 방식이 큰 혁신을 가져 왔다.
- 특히, 비동기 방식으로 생산 및 소비되는 **이벤트** 라는 미디어는 현대 기술에 의해 근본부터 달라졌다.
- 과거에 마이크로서비스는 배치 기반의 빅데이터 솔루션에 불과 했지만, 필요에 따라 얼마든지 데이터를 저장 및 관리 할 수 있다.
- 대수롭지 않았던 이벤트 기반 미디어가 발전하며 컴퓨터 아키텍쳐는 물론 팀 / 사람 / 조직이 시스템 과 비즈니스를 만들어가는 방식까지 재정립 하게 되었다.

### 1.1 이벤트 기반 마이크로서비스란 ?
- 마이크로서비스와 마이크로서비스 스타일 아키텍쳐는 오래전부터 다양한 포맷과 명칭으로 불려왔던 기술이다.
- **서비스 지향 아키텍쳐 (SOA)** 는 서로 직접 비동기 통신하는 여러 마이크로서비스로 구성된다.
- 메세지전달 아키텍쳐는 소비 간으한 이벤트를 주고 받으면서 서로 비동기 통신을 한다.

`SOA 와 MSA 의 차이`
- SOA 는 모듈의 의존성을 줄이되 모듈 내 공유할 수 있는건 최대한 공유한다.
- MSA 는 가능한 공유는 하지 않고, 모듈듈이 독립적으로 운용될 수 있도록 아키텍쳐를 디자인 한다.

> SOA 는 여러 서비스들 중 **공통되는 부분을 하나의 버스로 묶어** 사용한다. \n
> MSA 는 여러 서비스를 **독립적** 으로 사용한다.

- 현대 이벤트 기반 마이크로서비스 아키텍쳐는 시스템이 **이벤트를 생산/소비** 하는 방식으로 통신한다.
- 이벤트를 소비하더라도, 바로 사라지는 것이 아니고 같은 메세지를 필요롤 하는 다른 컨슈머도 소비할 수 있게 보존된다.

- 서비스는 조직이 추구하는 비즈니스 목표를 달성할 수 있게 최대한 **작은 규모**로 만들어야 한다.

### 1.2 도메인 주도 설계와 경계 컨텍스트

`도메인 (domain)`
- 비즈니스가 차지하고 솔루션을 제공하는 문제공간, 규칙, 프로셋, 아이디어, 비즈니스 전문 용어 등 문제 공간과 조금이라도 관련된 모든것

`하위 도메인 (sub domain)`
- 메인 도메인을 구성하는 컴포넌트이다.
- 이는 특정 하위 업무에 집중하며, 일반적으로 비즈니스 조직 구조를 반영하낟.
- 하위 도메인 자체를 하나의 도메인으로 볼 수 있으며, 도메인처럼 문제 공간에 속한다.

`도메인 모델`
- 비즈니스 용도에 맞게 실제 도메인을 추상화한 모델
- 도메인 모델은 솔루션 공간의 일부이며 비즈니스 문제를 해결하기 위해 사용하는 구성체 이다.

`경계 콘텍스트 (Bounded Context)`
- 입출력, 이벤트, 요건, 프로세스, 데이터 모델 등 하위 도메인과 연관된 논리적 경계이다.
- 경계 콘텍스트와 하위 도메인이 완벽히 일치하는것이 이상적
- 경계 콘텍스트는 솔루션 공간의 속성이며, 마이크로서비스가 상호작용하는 방식에 많은 영향을 미친다.
- 경계 콘테스트는 응집력이 강해야 한다.
- 콘텍스트의 내부 기능은 집약적이여야 하고, 대부분의 통신이 경계를 넘나들지 않고 내부에서만 일어나야 한다.
- 경계 콘텍스트끼리는 **느스한 결합 (loose coupling)** 을 유지해야 한다.
- 느슨한 결합을 유지한다면 특정 콘텍스트에서 변경이 일어나더라도 외부 컨텍스트는 영향을 받지 않고 독립적으로 동작할 수 있다.

`도메인 모델과 경계 콘텍스트 활용`
- 도메인은 다시 하위도메인으로 나뉘고, 하위 도메인은 개발팀이 작고 **독립적인 서비스로 옮길 정도** 까지 분할된다.
- 경계 콘텍스트는 이런 하위 도메인을 중심으로 형성되어 마이크로서비스가 탄생하는 기반이 된다.

`비즈니스 요건에 따라 경계 콘텍스트를 조정`
- 비즈니스 요건 변경 없이 제푸므이 근본적인 **구현체를 뜯어 고치는 경우** 는 거의 없다.
- 경계 콘텍스트를 기술 요건이 아닌 비즈니스 요건 중심으로 정해야하는 이유가 바로 이것이다.
- 경계 콘텍스트를 비즈니스 요건에 맞추게 되면 팀별로 느슨하게 결합하고 고도로 응집된 마이크로서비스 구현체를 바꿀 수 있다.
- 반대로 기술요건에 맞추면 문제가 발생한다.
- 동기직 점대점 마이크로서비스, 모놀리식 시스템에서 흔히 찾아볼 수 있다.
- 가장 큰 문제점은 여러 경계 콘텍스트에 결쳐 비즈니스 기능을 수행할 책임이 여러 팀으로 분산된다.
- 특정한 팀이 100% 책임지고 구현하는게 아닌 여러 서비스가 여러 팀, API 경계를 넘나들며 결합되어 고치려면 어렵고 비용도 많이 필요하게 된다.

> 이벤트 기반 마이크로서비스는 비즈니스 요건에 따라 아키텍쳐를 모델링 하는것이 바람직하다.

### 1.3 통신 구조
- 한 조직의 팀 / 시스템 등이 목표를 추구하기 위해 서로 소통하는 과정에서 **통신 구조** 라는, 의존 관계가 서로 연결된 **토폴로지** 가 형성된다.

`비즈니스 통신 구조`
- **비즈니스 통신 구조** 는 팀과 부서간의 통신을 결정하며, 각 팀에 할당된 요건 및 책임에 따라 달라진다.
- 기술팀은 제품개발을, 판매팀은 고객에게 제품을 판매하고, 지원팀은 고객 만족을 위함 처럼 말이다.

`구현 통신 구조`
- **구현 통신 구조** 는 하위 도메인 모델에 대해 조직에서 규정한 데이터와 로직을 이용해 비즈니스 프로세스, 데이터 구조, 시스템 설계를 **정규화** 한 것이다.
- 소프트웨어 공학해서 구현 통신 구조의 전형적인 사례는 모놀리식 애플리케이션 이다.

`데이터 통신 구조`
- **데이터 통신 구조** 는 비즈니스 전반에 걸쳐 구현체 간에 데이터를 주고 받는 프로세스이다.
- 데이터 통신 구조는 일반적으로 한 시스템에서 다른 시스템으로 **애드혹** 통신을 하는 역할에 충실했다.

`애드혹`
- 특정한 목적을 위해 라는 라틴어의 뜻이다.
- 특정한 문제나 일을 위해 만들어진 관습적인 해결책, 일반화할 수 없는 해결책, 다른 몬적에 적응시킬 수 없는 해결책을 말한다.

`콘웨이의 법칙과 통신 구조`

> 시스템 구조는 그 시스템을 설계하는 조직의 통신 구조를 따라갈 수 밖에 없다 (멜빈 콘웨이)
 
- **콘웨이의 법칙** 은 팀이 조직의 통신 구조에 따라 제품을 만든다는 의미
- **비즈니스 통신 구조** 는 여러 팀으로 조직하고, 팀들은 텀 경계에 의해 구분된 제품을 생산한다.
- **구현 톹신 구조** 는 주어진 제품의 하위 도메인 데이터 모델로 접근하는 통로를 제공하지만, 통신 기능이 약하므로 다른 제품으로의 접근은 제한적이다.
    - 구현 통신구조는 통신 메커니즘으로 적당하지 않지만 자신의 경계 콘텍스트의 니즈를 충족시키는데는 탁월하고 제품 설계에 있어서 두가지 영향을 미친다.
        - 1. 조직 전체에 필요한 도메인 데이터를 통신하는 방식이 **비효율적** 이기 때문에 논리적으로 새로운 신제품을 만드는데 지장을 준다.
        - 2. 기존 도메인에는 쉽게 접근이 가능하지만 새로운 비즈니스 요건을 수용하기 위해 지속적으로 도메인을 확장해야 한다.
- **데이터 통신 구조** 는 제품 설계/개발 하는 방법이 핵심적인 비중을 차지하지만 이런 구조가 오랫동안 누락된 채 방치된 조직도 많다.

### 1.4 기존 컴퓨팅의 통신 구조
- 새로운 비즈니스 요건을 **새로운 서비스** 에 구현할 것인가 ? 혹은 **기존 서비스** 에 추가할 것인가 ?

`새로운 서비스에 구현`
- 비즈니스 요건 차이가 많다면 새로운 서비스를 만들어 구현하는게 나을수도 있다.
- 새로운 서비스기 기존 데이터를 참조해야 한다면 ?...
- 나중에 팀을 나눠야 할 경우가 발생할 수 있으므로 모듈화한 독립적인 시스템을 각각 두는 편이 소유권 분할하기가 쉽다.
- 하지만 역시 리스크가 존재한다.
    - 저장소 2개, 서비스 2개를 관리 하면서 데이터가 구조가 변경될 경우 의존하는 타 시스템에 영향이 없도록 두 서비스간에 동기화에 만전을 기해야 한다.

`기존 서비스에 추가`
- 필요한 데이터가 저장소에 존재하고, 이미 기존에 사용중인 프로세스도 존재하니 바로 구현에 착수할 수 있다.
- 이 방법 역시 리스크가 존재한다.
    - 여러 모듈이 동일한 코드베이스에 함께 엮이는 경우가 많아 변경할 일이 생긴다면 구현체 내부에서 경계가 모호해질 가능성이 있다.
    - 경계를 넘나들며 모듈을 직접 결합시키면 간단하고 빠른 추가가 가능하겠지만 이는 **결합도는 증가** 하고, **응집도** 와 **모듈성** 은 떨어진다.

### 1.5 이벤트 기반 통신 구조
- 이벤트 기반 통신은 기존의 구현/데이터 통신의 대안이다.
- 요청-응답 기반 통신을 한번에 대체할 수는 없지만, 완전히 다른 ㅓㅅ비스 간 통신 수단을 제시한다.
- **이벤트 스트리밍** 방식의 데이터 통신구조에서는 데이터를 생산/소유하는 것과 데이터에 접근하는 항위가 철저히 분리된다.

> 서비스는 직접 요청-응답 API 에 얽매이는 일 없이 이벤트 스트림 내부에 정의된 **이벤트를 매개 로 통신** 한다.

`이벤트는 통신의 근간이다`
- 공유 데이터는 모두 이벤트 스트림에 발행함으로 써 조직에서 일어난 모든 일은 지속적으로 정규화된 형태로 서술된다.
    - 이것이 여러 시스템이 서로 통신하는 **채널** 이 된다.
- 이벤트가 곧 데이터이며, 데이터가 어딘가에 준비 되어있다는 신호나 데이터를 다른 구현체로 실어나르는 수단이 아니다.

`이벤트 스트림은 단일 진실 공급원이다`
- 스트림에 존재하는 이벤트는 **사실 진술서 (statement of fact)** 이다.
- 이들은 취합하면 조직내 모든 시스템이 통신하는 근간인 **단일 진실 공급원 (single source of truth)** 이 된다.

> 통신 구조는 정보가 정확할 때만 유효하기 때문에 이벤트 스트림을 단일 진실 공급원으로 채택하는 것은 큰 의미가 있다.

`컨슈머가 스스로 모델링과 쿼리를 수행한다`
- 이벤트 기반 데이터 통신 구조는 데이터 쿼리/검색 기능이 있다는 점에서 과하게 확장된 구현 통신 구조와 다르다.
- 모든 비즈니스 및 애플리케이션 로직은 반드시 **이벤트 프로듀서 / 컨슈머 내부에 캡슐화 되어야 한다**

`조직 전반적으로 데이터 통신이 원할해진다`
- 데이터 통신 구조를 사용하면 모든 공유 데이터가 구현 통신 구조 외부에 노출된다.
- 모든 데이터를 공유해야 하는것은 아니기 때문에 전부 이벤트 스트림으로 발행할 필요는 없다.

> 다른팀 / 서비스에서 관심 있는 데이터는 공용 이벤트 스트림에 발행함으로써 **생산과 소유권을 완전히 분리** 할 수 있다.

`접근 가능한 데이터 덕분에 비즈니스 통신 변경이 가능하다`
- 이벤트 스트림에는 비즈니스 운영에 중심적인 핵심 도메인 이벤트가 있다.
- 핵심 도메인 이벤트가 특정 구현체에 의존하지 않기 때문에 비즈니스가 유연해 진다.

### 1.6 비동기식 이벤트 기반 마이크로 서비스

`세분성 (granularity)`
- 서비스가 경계 콘텍스트에 알맞게 매핑되고, 비즈니스 요건이 바뀌어도 쉽게 재작성이 가능하다.

`확장성 (scalability)`
- 개별 서비스는 필요시 규모를 늘리거나 줄일 수 있다.

`기술 유연성 (technological flexibility)`
- 서비스마다 가장 적합한 언어와 기술로 구현할 수 있고, 쉽게 프로토타이핑이 가능하다.

`비즈니스 요건 유연성 (business requirement flexibility)`
- 대규모 서비스보다 다른 팀에 덜 의존하기에 데이터 접근시 장애요소가 적고 조직은 비즈니스 요건 변화에 신속히 대응할 수 있다.

`느슨한 결합 (loose coupling)`
- 이벤트 기반 마이크로서비스는 도메인 데이터와 결합할 뿐 특정한 구현 API 에 구애받지 않는다.

`지속적 전달 지원 (continuous delivery support)`
- 작은 모듈로 나눈 마이크로서비스는 옮기기 쉽고 필요시 간편하게 롤백할 수 있다.

`우수한 시험성 (high testability)`
- 마이크로서비스는 모놀리스 보다 디펜던시가 적어 필요한 테스트 ㅇ네드포인트를 모킹하고 코드 커버리지를 적절히 유지하기 쉽다.

### 1.7 동기식 마이크로서비스
- 마이크로서비스는 이벤트를 이용해 비동기식으로 구현하거나 SOA 에서 많이 사용하는 동기식 방식으로도 구현한다.
- 동기식 마이크로서비스는 요청-응답 방식으로 직접 API 를 통해 소통한다.

`동기식 마이크로서비스의 단점`
- 점대점 요청-응답 마이크로서비스, 비동기 이벤트 기반 마이크로서비스 모두 어느쪽이 항상 더 낭느것은 아니다.
- 업무 성격에 따라 더 적합한 서비스도 있고 조직마다 쓰임새가 다르다.
- 이벤트 기반 마이크로서비스는 어마어마한 유연성이 존재한다.

`점대점 결합`
- 동기식 마이크로서비스는 결국 다른 서비스에 의존해서 할 수 밖에 없다.
- 의존관계가 꼬리에 꼬리를 물고 여러 서비스에 걸쳐 넓게 퍼지면 나중에 어떤 서비스가 어떤 비즈니스를 담당하는지 파악하기 힘들어 진다.

`의존적 확장`
- 한 서비스의 확장 가능 여부는, 서비스가 의존하는 다른 서비스가 확장 가능한지, 또 통신의 **팬 아웃** 정도와 직접 연관된다.
- 구현 기술 역시 확장의 병목이 될 가능성이 크다.

`서비스 실패 처리`
- 의존하는 서비스가 내려가는 예외 상황 발생시 처리 방법을 정해야 하낟.
- 데이터 정합성 보장시 서비스를 어떻게 처리하고, 언제 재시도하고 그래도 실패하면 어떻게 복구할 것인지 절차를 마련해야 한다.

`API 버저닝과 디펜던시 관리`
- 여러 API 정의와 서비스 버전이 동시에 혼재하기 쉽다.
- 기반 데이터 구조 변경이 불가피할 경우, 다수의 서비스를 상대로 API 변경을 적용하는 일 자체가 복잡할 수 있다.

`데이터 접근이 구현체에 종속된다`
- 동기식 마이크로서비스는 외부 데이터 접근시 기존 서비스와 동일한 문제가 발생한다.
- 데이터 접근과 확장성이라는 무거운 짐을 구현 통신 구조에 다시 지우는 셈이 된다.

`분산 모놀리스`
- 서비스가 분산 모놀리스 처럼 동작하도록 조합되어 서비스간 호출이 얽히고 설켜버린다.

`테스트`
- 각 서비스를 가동하려면 자신이 의존하는 서비스 역시 가동중이어야 하고, 통합테스트를 수행하기가 어렵다.

`동기식 마이크로서비스의 장점`
- 사용자 인증, A/B 테스트 등은 요청-응답 을 주고받는 방식이 더 유리하다.
- 여러 시스템에 걸쳐 작업을 추적하기도 용이하다.
- 경험 역시 중요한 요소이다.

### 1.8 정리
- 조직의 소프트웨어 개발/관리 방향은 통신 구조에 따라 결ㅈ어된다.
- 이벤트 기반 시스템에 내재된, 쉽게 접근하고 저장가능한 도메인 이벤트를 활용하면 더 작고 목적에 부합한 구현체를 만들 수 있다.

## 2. 이벤트 기반 마이크로서비스 기초
- **이벤트 기반 마이크로서비스** 는 특정한 경계 콘텍스트를 구현하기 위해 개발된 작은 애플리케이션이다.
- 컨슈머 서비스는 하나 이상의 이벤트 스트림으로 부터 이벤트를 **소비 및 처리** 하고, 프로듀서 서비스는 이벤트 스트림에 이벤트를 **생산** 한다.
- **이벤트 브로커** 는 이벤트 스트림을 제공하고, 마이크로서비스에서 의미있는 규모로 운영하라면 배포 파이프라인과 컨테이너 관리 시스템이 반드시 필요하다.

### 2.1 토폴로지 구성
- **토폴로지** 는 이벤트 기반 마이크로서비스를 이야기할 때 자주 등장하는 용어
- 기본적으로 마이크로서비스의 처리 로직을 의미하지만 마이크로서비스, 이벤트스트림, 요청-응답 API 간의 관계를 나타내기도 한다.

`마이크로서비스 토폴로지`
- **마이크로서비스 토폴로지** 는 마이크로서비스 **내부의 이벤트** 기반 토폴로지 이다.
- 변환, 저장, 방출 등 **이벤트에 수행할 데이터 주도 연산** 을 정의한다.
- 마이크로서비스가 이벤트를 인입, 처리, 출력하는 행위가 이 토폴로지의 구성이다.

`비즈니스 토폴로지`
- **비즈니스 토폴로지** 는 복잡한 비즈니스 로직을 처리하는 마이크로서비스, 이벤트 스트림, API 의 집합이다.
- 1장에서 살펴본 비즈니스 통신 구조가 비즈니스 토폴로지를 구성하는 요소이다.

### 2.2 이벤트 콘텐츠
- **이벤트** 는 비즈니스 통신 구조 범위에서 발생한 무엇이라도 가능하다.
    - 업무상 발생하는 모든 일이 이벤트가 될 수 있고, 비즈니스상 중요한 것이라면 이벤트가 될 수 있다.실
    
> 이벤트는 사건의 기록물이며, 로그와 비슷하면서도 **단일 진실 공급원** 이라는 차이가 있다.

### 2.3 이벤트 구조
- 이벤트 일반적으로 Key/Value 로 표현되며, 크게 3가지로 분류된다. 

`키 없는 이벤트`
- 키 없는 이벤트는 하나의 **사실을 진술한 형태** 로 나타낸 이벤트이다.
- 특정 고객이 특정 상품과 상호작용 했다는 사실을 이벤트로 표현할 수 있다.

| 키 | 값 |
| --- | --- |
| N/A | ISBN:37219, Timestamp:1538913600 |

`엔티티 이벤트`
- 엔티티는 유일하므로, **유일한 ID 가 키** 로 부여된다.
- 엔티티 이벤트는 특정시점의 엔티티 속성 및 상태를 기술한다.

| 키 | 값 |
| --- | --- |
| ISBN:37219 | Author:Ncucu |

> 엔티티의 상태에 대한 연속된 이력을 제공하고, 상태를 구체화 하는 용도로 사용가능한 엔티티 이벤트는, 이벤트 기반 아키텍쳐에서 매우 중요하다.
> 엔티티의 현재 상태를 알기위해 **마지막 엔티티 이벤트** 만 있어도 되기 때문이다.

`키가 있는 이벤트`
- 키가 있는 이벤트는 **키를 포함하지만, 엔티티를 나타내지 않는다.**
- 주로 이벤트 스트림의 파티션내에서 **데이터 지역성** 을 보장하기 위해 **이벤트 스트림** 을 파티셔닝 하는 용도로 사용된다.

| 키 | 값 |
| --- | --- |
| ISBN:372719 | UserId:A537FE |

### 2.4 엔티티 이벤트에서 상태를 구체화
- 엔티티 이벤트 스트림에서 들어온 엔티티 이벤트를 **순서대로 적용하면 상태 저장 테이블을 구체화** 할 수 있다.
- 각 엔티티 이벤트는 키/값 테이블에 업서트 되므로 키 별 가장 최근에 읽은 이벤트를 알 수 있고 각 업데이트를 이벤트 스트림에 발행하여 테이블을 엔티티 이벤트 스트림으로 발행할 수 있다.
- 이런 특성을 **테이블-스트림 이원성** 이라고 한다.
- 이벤트 기반 마이크로서비스에서 상태를 생성하는 기본 원리이다.
- 키가 있는 이벤트는 **툼스톤 이벤트 (값이 null 인 이벤트)** 를 만들어 삭제를 표현한다.
- 붙임 전용 불변 로그 (append-only) 는 컴팩션 (압착) 을 하지 않으면 무한정 커질 수 있다.
    - 컴팩션이란, 이벤트 브로커가 내부 로그 크기를 줄이기 위해 키별로 가장 최근 이벤트 하나만 보관하는 작업이다.

> 컴팩션을 수행하면 이벤트 스트림에 쌓인 로그 이력은 포기해야 하지만 디스크 사용량이 줄고, 현재 상태까지 도달하기 까지 처리해야할 이벤트 수도 감소하게 된다.

- 비즈니스 처리를 위해 **상태를 유지** 하는 것은 이벤트 기반 아키텍쳐에서 일반적인 패턴이다.

### 2.5 이벤트 데이터 정의와 스키마
- 이벤트 데이터는 서비스간 통신 수단은 물론 구현체와 뭄관한 장기 데이터 보관소 역할을 한다.
- 때문에 프로듀서와 컨슈머가 데이터의 의미를 동일하게 이해하는 것이 중요하다.
- 프로듀서/컨슈머 간에 원할한 소통을 위해 공통적인 언어가 필요하다.
- 아파치 아브로, 구글 프로토콜 버퍼 와 같은 스키마화 기술은 이벤트 기반 마이크로서비스에서 많이 쓰이는 두 기능을 제공해준다.
    - 1. 다운스트림 컨슈머가 코드를 변경하지 않아도 주어진 스키마 변경을 안전하게 처리할 수 있는 진화 프레임워크 역할을 한다.
    - 2. 스키마화 데이터를 언어의 일반 객체로 변환할 때 필요한 정형 클래스를 생성한다.

### 2.6 마이크로서비스 단일 작성자 원칙
- 이벤트 스트림은 정확히 하나의 생산 마이크로서비스를 가진다.
- 때문에 어떤 이벤트라도 이벤트스트림을 따라가면 해당 이벤트의 진실 공급원을 파악할 수 있다.

### 2.7 마이크로서비스를 이벤트 브로커로 강화
- **이벤트 브로커** 는 이벤트 기반 마이크로서비스 플랫폼의 핵심이다.
- 일반적으로 이벤트는 하부의 논리적 의미에 따라 여러 스트림으로 나누어 발행된다.
- 다수의 분산된 이벤트 브로커가 한 클러스터로 동작하며 이벤트 스트림의 생산/소비 플랫폼을 제공한다.

`확장성 (scalability)`
- 이벤트 브로커의 인스턴스를 추가하면 클러스터의 생산/소비 및 데이터 스토리지 용량을 늘릴 수 있다.

`보존성 (durability)`
- 노드 간에 이벤트 데이터가 복제되므로 브로커에 장애가 발생해도 데이터는 보존되고 서비스도 지속될 수 있다.

`고가용성 (High Availability)`
- 이벤트 브로커를 클러스터링하면 브로커에 장애가 발생하더라도 다른 노드에 접속할 수 있어 풀 가동 상태를 유지할 수 있다.

`고성능 (High-Performance)`
- 여러 브로커 노드가 생산 및 소비 부하를 분담한다.

#### 2.7.1 이벤트 보관 및 처리
- 브로커가 사용할 하부 (내부 기반) 데이터 스토리지의 최소 요건

`파티셔닝 (partitioning)`
- 이벤트 스트림은 개별 하위 스트림으로 나뉠 수 있고 프로듀서/컨슈머의 니즈에 따라 수가 결정된다.
- 이벤트 스트림을 파티셔닝 하면 여러 컨슈머 인스턴스가 병렬 처리함으로써 처리량을 늘릴 수 있다.

`순서 보장 (strict ordering)`
- 이벤트 스트림 파티션 내에서 데이터 순서는 반드시 보장되므로 발행된 순서대로 클라이언트에게 제공된다.

`불변성 (immutability)`
- 이벤트 데이터는 발행되면 불변이라 수정할 수 없다.
- 이전 데이터를 변경하려면 데이터를 업데이트 한 뒤 새로운 이벤트를 발행해야 한다.

`인덱싱 (indexing)`
- 이벤트는 이벤트 스트림에 기록되는 시점에 offset 이 할당 된다.
- 컨슈머는 이 offset 을 활용하여 데이터를 소비한다.
- 현재 인덱스와 마지막 인덱스의 간격을 **컨슈머 랙 (컨슈머 지연)** 이라고 한다.

`무기한 보존 (infinite retention)`
- 이벤트 스트림은 이벤트를 무기한 보존할 수 있어야 하며 이벤트 스트림에서 상태를 관리하려면 반드시 필요하다.

`재연성 (replayability)`
- 이벤트 스트림은 어떤 컨슈머라도 필요한 데이터를 골라 읽을 수 있도록 재연가능해야 한다.
- 단일 진실 공급원의 근간이자 마이크로서비스 간에 상태를 주고 받는 기반이 된다.

#### 2.7.2 추가 고려 사항

`지원 도구`
- 이벤트 기반 마이크로서비스를 효과적으로 개발하려면 지원 도구가 필요하다.
- 이는 대부분 다음가 같은 이벤트 브로커 구현체에 의존한다.
    - 이벤트와 스키마 데이터 조회
    - 쿼터 (할당량), 접근 제어, 토픽 관리
    - 모니터링, 처리량, 컨슈머 랙 측정

`호스티드 서비스`
- 호스티드 서비스로 이벤트 브로커 생성/관리를 아웃소싱 할 수 있다.

`클라이언트 라이브러리와 처리 프레임워크`
- 이벤트 브로커 제품은 종류가 많고 클라이언트를 지원하는 수준도 다양하다.
    - 필요한 언어 기반의 클라이언트 라이브러리 및 프레임워크 지원 여부 판단
    - 프레임워크를 사용할지 / 만들어 사용할지 판단

`커뮤니티 지원`
- 이벤트 브로커 선정시 커뮤니티 지원은 매우 중요한 요소이다.
    - 온라인 커뮤니티 지원 여부 판단
    - 기술적 성숙도 / 프로덕션 운영 가능 여부 판단
    - 보편화된 기술인지 ?
    - 직원들에게 매력적인 기술인지 ?

`장기 계층형 스토리지`
- 이벤트 스트림의 크기와 보존 기간에 따라 오래된 데이터 세그먼트는 저렴한 스토리지에 저장하는 것이 좋다.
- 계층형 스트로지는 접근 성능을 여러 계층 별로 나누어 제공한다.
    - 계층형 스토리지 지원 여부
    - 사용량에 따라 스토리지 계층 이동 가능 여부
    - 어디에 저장하더라도 끊김 없이 데이터를 조회할 수 있는가 ?

### 2.8 이벤트 브로커 와 메세지 브로커
- 이벤트 브로커는 메세지 브로커를 대신할 수 있지만, 메세지 브로커는 이벤트 브로커를 대신할 수 없다.
- **메세지 브로커** 는 대규모 메시지 기반 미들웨어 아키텍쳐에서 사용되어 왔다.
    - 발행/구독 메세지 큐를 통해 네트워크 전체 통신이 가능하다.
    - 컨슈머가 메세지를 소비하면 즉시 혹은 짧은 시간내에 삭제되는 구조이고, 이벤트 브로커와는 다른 종류의 문제를 처리하고자 설계되었다.
- **이벤트 브로커** 는 순서대로 쌓은 로그를 제공할 목적으로 설계 되었다.
    - 레코드 장부를 딱 하나만 보관하고, 인덱스를 통해 개별 액세스를 관리하므로 독립적인 여러 컨슈머가 필요한 이벤트를 마음대로 가져갈 수 있다.
    - 이벤트 브로커는 **업무상 필요한 시간동안 이벤트를 보존** 할 수 있다.
> 이벤트 브로커는 모든 애플리케이션에 대해 무기한 보관되고 전역 접근이 가능한 **단일 진실 공급원** 을 제공한다.

#### 2.8.1 불변 로그 소비
- 이벤트 브로커는 일반적으로 붙임 전용 불변 로그를 사용한다 (명확한 표준은 없다)
- 이벤트 로그 끝부분에 추가되고, AUTO-INCREMENTING Index ID 가 부여된다.
- 컨슈머는 Index ID 가 가리키는 위치부터 접근하여 이벤트 스트림이나 큐로 이벤트를 소비한다.

`이벤트 스트림으로 소비하기`
- 컨슈머는 이벤트 스트림에서 이전에 읽은 인덱스를 가리키는 위치를 관리한다.
- 이를 offset 이라고 하며, 오프셋 덕분에 이벤트 스트림에 여러 스트림이 서로 독립적으로 데이터를 소비 할 수 있다.
- **컨슈머 그룹** 은 여러 컨슈머를 하나의 동일한 엔티티로 나타낸 논리적 단위이며 메세지 소비를 **수평 확장** 하는데 활용 된다.
    - 컨슈머 그룹에 새로운 컨슈머가 들어오면, 이벤트 스트림의 파티션을 재할당하고 새로운 컨슈머는 할당된 파티션의 이벤트만 소비하게 된다.
    
`큐로 소비하기`
- 각 이벤트는 오직 하나의 마이크로서비스 인스턴스만 소비한다.
- 이벤트 브로커는 소비가 끝난 이벤트를 **소비됨 (consumed)** 으로 표시하고 달느 컨슈머들에게 제공하지 않는다.

> 큐에서 받은 이벤트는 순서가 보장되지 않는다는 점을 유의해야 한다. \n
> 모든 이벤트 브로커가 큐를 지원하는 것은 아니고, 아파치 카프카는 지원하지 않는다.

#### 2.8.2 단일 진실 공급원 제공
- 이벤트 브로커는 서비스가 데이터를 생산/소비 하는 유일한 장소가 되어 모든 컨슈머에게 반드시 같은 데이터 사본을 전달한다.
- 이벤트 브로커가 단일 진실 공급원이 되려면 조직 문화도 변화되어야 한다.
    - 모놀리스 데이터도 반드시 이벤트 브로커로 발행해야 한다.
- 이벤트 기반 마이크로서비스가 정착되면 이벤트 브로커만 있어도 데이터 저장/조회가 가능한 서비스 개발이 가능해진다.

### 2.9 대규모 마이크로서비스 관리
- 마이크로서비스는 서비스가 늘어날 수록 관리하기 어려워 진다.
- 대부분 컨테이너/가상화 기술을 해당 관리 시스템과 함께 사용하고 팀별로 단일 배포단위를 통해 커스터마이징 한다.

`마이크로서비스를 컨테이너에 넣기`
- 도커로 대중화된 컨테이너 기술을 이용하면 애플리케이션을 서로 격리 시킬 수 있다.
- 다수의 컨테이너가 **공유 커널 모델** 을 사용하여 호스트 운영체제를 활용한다.
    - 환경 변수, 라이브러리 등은 각자 컨테이너 별로 동작함
- 여러 컨테이너가 호스트 OS 를 공유하기 때문에 커널이 뚫리면 전체 컨테이너가 위험해 질 수 있다.

`마이크로서비스를 가상 머신에 넣기`
- VM 을 쓰면 컨테이너의 단점은 극복할 수 있지만 사용 사례는 점점 줄어든다.
- 보안 측면에서는 컨테이너보다 우수하나 비용 및 시동 시간도 느리다.

`컨테이너와 가상 머신 관리`
- 컨테이너와 VM 은 CMS 를 이용해 관리한다.
    - 컨테이너 배포, 리소스 할당, 하부 컴퓨팅 리소스와 통합하는 등의 기능을 제공
- 쿠버네티스, 도커 엔진, 메소스 마라톤, 아마존 ECS, 노매드 등이 잘 알려져 있다.
- 마이크로서비스는 워크로드 (작업 부하) 변경, 서비스 수준 협약 (SLA), 성능 요건에 따라 규모를 늘리고 줄일 수 있어야 한다.
    - 스케일업 / 스케일 아웃은 필수 기능
    
### 2.10 마이크로서비스 세금 납부
- 마이크로서비스 아키텍쳐 도구 및 컴포넌트를 구현하는데 투입되는 금전 / 인력 / 기회 비용을 포함한 모든 비용을 마이크로서비스 세금 이라고 한다.
- 이는 결코 사소한 문제가 아니며 실제로 이벤트 기반 마이크로서비스를 시작하려는 조직에서 갖아 큰 걸림돌이 될 때가 많다.

## 3. 통신 및 데이터 규약
- 통신의 최고 난제는 **프로듀서가 생산한 메세지를 컨슈머가 똑같이 이해하고 있어야 한다** 는 점
- 이벤트 기반 시스템에서 이벤트란, 무슨일이 일어났고 그 이유는 무엇인지 정확하게 기술하는 **메세지** 이자 통신의 기본단위 이다.

### 3.1 이벤트 데이터 규약
- **데이터 규약**은 주고 받은 데이터의 포맷과 생성 로직을 정의한다.
- 프로듀서와 컨슈머 사이의 일종의 계약
- 이벤트 규약을 이용하면 이벤트가 생상되는 콘텍스트 이상의 의미를 부여하고 데이터 사용성을 넓힐 수 있다.
- 데이터 규약에는 **데이터 정의** 와 **트리거 로직** 두가지 요소가 포함된다.
    - 데이터 정의 : 생산할 것들 (필드, 타입, 그외 자료 구조)
    - 트리거 로직 : 생산한 이유 (이벤트 생성을 일으킨 특정 비즈니스 로직)

`명시적인 스키마를 규약으로 활용`
- 데이터 규약을 강제하여 일관성을 유지하는 가장 좋은 방법은 각 이벤트마다 **스키마를 정의** 하는 것이다.
- 프로듀서가 데이터 정의 및 트리거 로직이 상술된 스키마를 정의하여 같은 타입의 이벤트는 모두 같은 포맷을 따르게 하는 것이다.

> 명시적인 스키마가 없다면 프로듀서와 컨슈머간의 이벤트 기반 통신은 **암묵적 스키마** 에 의존할 수 밖에 없다. \n
> 명시적인 스키마는 프로듀서/컨슈머 모두에게 보안과 안정성을 가져다준다.

- 암묵적인 스키마로 인해 이벤트 데이터 정의 변경사실을 모를 수 있고, 컨슈머가 실패할 때 까지도 알 수 없는 경우도 있다.

`스키마 정의 주석`
- 스키마 정의에서 통합된 **주석** 과 **메타데이터** 는 이벤트 의미를 전달하기 위해 반드시 필요하다.
- 이벤트 트리거 논리를 명시
    - 스키마 정의 맨 앞의 블록 헤더에 이벤트가 생성된 이유를 명확히 밝힌다.
- 구조화한 스키마의 특정 필드에 대해 콘텍스트를 부여
    - datetime 필드의 날짜/시간 포맷이 UTC, ISO, 유닉스 타임 중 어느 것인지 주석에 명시한다.
    
`완전한 스키마 진화`
- 스키마 포맷은 **반드시 스키마 진화 규칙의 전체 범위를 지원** 해야한다.
- 업무 변경시 필드 추가 혹은 deprecated 표시가 필요한데, 스키마 프레임워크는 이런 변경사항을 안전하게 적용해 프로듀서와 컨슈머를 서로 독립적인 진화가 가능하게 한다.
    - 스키마 진화가 없다면 서비스 업데이트 비용이 매우크다.
    - 프로듀서가 데이터 스키마 변경시마다 모든 컨슈머가 서비스를 업데이트 해야하는 말도안되는 일이 발생한다.
- 스키마 진화 규칙은 호환성 종류에 따라 세가지로 분류된다.

`정방향 호환성`
- 새 스키마로 생성한 데이터를 이전 스키마로 생성한 것 처럼 읽을 수 있다.
- 이벤트 기반 아키텍쳐에서 유용한 진화 조건

`역방향 호환성`
- 옛 스키마로 생성한 데이터를 새 스키마로 생성한 것 처럼 읽을 수 있다.
- 역방향 호환성이 유용한 경우는 다음과 같은 경우이다.
    1. 프로듀서가 전달한 새 기능을 컨슈머가 대기하지 않고, 새 스키마가 정의되어 있다면 미리 업데이트를 릴리즈 할 수 있다.
    2. 옛 버전과 호환성을 유지하며 프롣류서가 릴리즈한 최신 스키마 포맷으로 업데이트가 가능하다. 
> 역방향 호환성이 없다면 컨슈머는 최신 포맷의 메세지만 읽을 수 있다.

`양방향 호환성`
- 정방향 + 역방향 호환성의 조합이야 말고 최고의 조건이다.
- 호환성 요건을 완화하기는 쉽지만 높이는것은 어렵기 때문에 가능하다면 양방향 호환성은 항상 적용하는것이 좋다.

`코드 생성기 지원`
- 코드 생성기는 이벤트 스키마를 클래스 정의 또는 프로그래밍 언어에서 그와 동등한 구조로 변환한다.
- 컨슈머는 이벤트를 읽어 그 안에 인코딩된 스키마 버전으로 이벤트를 역직렬화 한다.
    - 이벤트 포맷은 메세지에 넣는것 보단 **스키마 레지스트리** 또는 **온디맨드** 방식으로 접근한다.

`중대한 스키마 변경`
- 스키마 진화의 전체 흐름을 깨트릴 수 밖에 없는 중대한 스키마 변경이 있을 수 있다.
- 컨슈머는 영향이 크기 때문에 신중히 결정해야 한다.

`엔티티의 중대한 스키마 변경 적용`
- 엔티티 스키마에 중대한 변경이 일어나면 현재 모델을 더 이상 확장할 수 없기 때문에 기존 모델을 재정의 해야한다.
- 이런 데이터 정의를 두 갈래로 분기하는 방법인 두 가지가 있다.
    - 옛 스키마와 현재 스키마를 함께 둔다.
    - 모든 엔티티를 새 스키마 포맷으로 재생성한다.

> 프로듀서 입장에선 첫 번째 방법이 가장 쉽지만, 이는 위험한 방법이고 컨슈머에게 책임을 전가하는것은 나쁜 습관이다.

`이벤트에 대한 중대한 스키마 변경 적용`
- 엔티티가 아닌 이벤트는 중대한 스키마 변경을 통합해서 더 간단히 처리 할 수 있다.
- 가장 간단하게는 새 이벤트 스트림을 만들어 새 이벤트를 생산하는 것이다.

> 하나의 이벤트 스트림에 여러 종류의 이벤트 타입, 스키마 진화 측면에서 더이상 호환되지 않는 이벤트 타입은 섞어 쓰지 말아야한다.

### 3.2 이벤트 포맷 선택
- 데이터 규약은 아브로, 스리프트, 프로토콜 버퍼처럼 엄격하게 정의된 포맷을 사용하는 것이 좋다.
- 이벤트 브로커 프레임워크는 대부분 이런 포맷의 직렬화를 지원한다.

### 3.3 이벤트 설계
- 이벤트 정의시 반드시 피해야할 안티패턴도 존재

`오직 진실만을 말해야한다`
- 잘 정의된 이벤트는 **뭔가 일어났음을 전하는 메세지** 가 아닌, 이벤트가 발생한 동안의 **모든 일** 을 빠짐없이 기술한다.
- 이벤트를 단일 진실 공급원으로 간주해 컨슈머가 소비할 불변의 팩트로 기록되어야 한다.

`스트림당 이벤트 정의는 하나만 사용해야 한다`
- 종류가 다른 이벤트들을 이벤트 스트림에 섞어놓으면 이벤트 실체와 스트림 정체성에 혼란을 줄 수 있다.

`가장 좁은 범위의 데이터 타입 사용`
- 이벤트 데이터의 타입은 가장 좁은 범위의 것을 사용해야 하낟.
- 코드 생성시, 프로그래밍 언어의 타입 체크 기능 등을 통해 데이터 경계를 확인할 수 있다.
- 다음은 실전에서 피해야할 몇가지 사례이다.
    1. 문자열을 이용한 숫자 값 저장
    2. 정수를 불리언으로 사용
    3. 문자열을 이늄으로 사용
        - 프로듀서가 발생한 값이 컨슈머가 사용할 이늄 에 있어야 함을 보장해야 한다.

`이벤트는 하나의 목적만 가져야 한다`
- 이벤트 정의에 타입 필드를 추가해 하위 속성을 두는 것은 안티패턴중 하나이다.
- 비슷하지만 다른 데이터를 처리하려고 이렇게 하지만 이벤트를 다목적으로 사용하려고 오해한 결과이다.
- 다용도 스키마는 비즈니스 요건이 조금만 달라져도 엄청나게 복잡해 진다.
- 이벤트의 의미를 오버로드 하는 타입 필드는 절대 이벤트에 추가해서는 안된다.

> 이벤트는 수많은 종류의 데이터를 기록하는 이벤트가 아닌, 하나의 비즈니스 액션에 관한 것이여야 한다. \n
> 다양한 타입 매개변수를 지닌 제네릭한 이벤트만 있어도 된다면 경계콘텍스트가 제대로 정의되어 있지 않다는 것이다.

`이벤트 크기 최소화`
- 이벤트는 크기가 작고 잘 정의되어 있고 쉽게 처리할 수 있어야 좋지만 때때로 큰 이벤트도 발생할 수 있다.
- 큰 이벤트를 발행해야 한다면 정말 필요한 이벤트인지 검토해 보아야한다.
- 부가적인 기능을 별도의 서비스로 나누어 범위를 축소하는 것도 방법이다.

`미래의 컨슈머도 이벤트 설계에 반영`
- 새 이벤트 설계시 해당 이벤트를 소비할 것으로 예상되는 컨슈머와도 협의가 필요하다.

`이벤트를 세마포어나 시그널로 사용하지 않는다`
- 이벤트를 세마포어나 시그널로 사용하지 말아야 한다.
- 이런 이벤트는 어떤 결과의 진실 공급원이 아닌 뭔가가 일어났음을 알릴 뿐이다.

### 3.4 정리
- 비동기식 이벤트 기반 아키텍쳐는 이벤트 품질에 크게 의존한다.
- 진화가능한 스키마로 명시한 고품질의 이벤트를 지향해야한다.
- 암묵적 스키마는 프로듀서입장에서 구현/관리하기는 쉽지만 스키마 해석의 책임을 컨슈머에게 전가한다.
    - 이는 좋지않는 방식이다.
    - 이벤트 데이터 누락 또는 의도치않은 변경 때문에 예기치 못한 장애가 발생할 수 있다.
- 이벤트 정의는 가급적 범위를 좁혀 이벤트 도메인에 집중해야 한다.
    - 어떤 비즈니스 사건을 나타내며, 어떤 일이 일어났는지에 대한 적절한 필드가 포함되어 있어야 한다.

